[
  "char mybuf2[450] ;\nint main (int argc, char *argv[])\n{\n\tHANDLE hHeap;\n\tchar *buf1, *buf2;\n\tint i;\n    \nfor(int i=0;i<450;i++){\n mybuf2[i]='a';\n}\t\nLoadLibrary(\"user32\");\n\thHeap=HeapCreate(HEAP_GENERATE_EXCEPTIONS, 0x10000, 0xfffff);\n\tbuf1 =(char*) HeapAlloc(hHeap, 0, 200);\n\tstrcpy(buf1,mybuf2);\n\tbuf2 =(char*) HeapAlloc(hHeap, 0, 200);\n\tHeapFree(hHeap, 0, buf1);\n\tHeapFree(hHeap, 0, buf2);\n\treturn 0;\n}\n",
  "#define PORT 1500\n#define BUFFLEN 32\n#define COPYLEN 64\n\n#include <stdio.h>\n#include <windows.h>\n#include <winsock.h>\n\nint main()\n{\n\n  WSADATA        wsd;\n  SOCKET        sListen, sClient;\n  struct        sockaddr_in local, client;\n  int            iAddrSize;\n  HANDLE        hHeap;\n   \n  char        *buf1, *buf2;\n  char        buff[4096];\n   \n  if (WSAStartup(MAKEWORD(2,2), &wsd) != 0)\n  {\n    printf(\"Failed to load Winsock!\\n\");\n    return 1;\n  }\n\n  //建立一个socket监听1500端口\n  sListen = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);\n\n  local.sin_addr.s_addr = htonl(INADDR_ANY);\n  local.sin_family = AF_INET;\n  local.sin_port = htons(PORT);\n\n  if (bind(sListen, &local, sizeof(local)) == SOCKET_ERROR)\n  {\n    printf(\"bind() failed: %d\\n\", WSAGetLastError());\n    return 1;\n  }\n\n  listen(sListen, 8);\n  iAddrSize = sizeof(client);\n  sClient = accept(sListen, &client, &iAddrSize);\n\n  if (sClient == INVALID_SOCKET)\n  {\n    printf(\"accept() failed: %d\\n\", WSAGetLastError());\n    return 1;\n  }\n\n  printf(\"connect form: %s:%d\\n\", inet_ntoa(client.sin_addr), ntohs(client.sin_port));\n\n  //我们自己建立一个HEAP，以免破坏掉进程默认HEAP以后shellcode无法正常运行\n  hHeap = HeapCreate(HEAP_GENERATE_EXCEPTIONS, 0x10000, 0xfffff);\n\n  //动态分配一块BUFFLEN大小的(32 bytes)的内存buf1\n  buf1 = HeapAlloc(hHeap, 0, BUFFLEN);\n  recv(sClient, buff, 4096, 0);\n\n  //注意：这里溢出的不是buff，而是buf1，\n  //buff是在栈中开辟的缓冲区，它的大小是4096，上面recv的也是4096，所以不会溢出\n  printf(\"recv1: %s\\n\", buff);\n\n  //将从客户端接受到的内容（即buff）拷贝到buf1中\n  //如果接受到的内容大于32字节将发生溢出\n  //这里错误的使用了COPYLEN(64 bytes)，因此造成溢出\n  memcpy(buf1, buff, COPYLEN);\n\n  //如果覆盖到HEAP中的管理结构，那么当再次动态分配内存时将可能被利用\n  buf2 = HeapAlloc(hHeap, 0, BUFFLEN);\n\n  recv(sClient, buff, 4096, 0);\n  printf(\"recv2: %s\\n\", buf2);\n  HeapFree(hHeap, 0, buf1);\n  HeapFree(hHeap, 0, buf2);\n  closesocket(sListen);\n\n  WSACleanup();\n  \n  HANDLE hHeap;\n  char *buf1, *buf2;\n  char mybuf[] = \"AAAAAAAAAAAAAAAABBBBBBBBXXXXYYYY\";\n\n  //在进程的默认HEAP当中分配内存\n  hHeap=GetProcessHeap();\n\n  //先分配一块16字节内存buf1\n  buf1 = HeapAlloc(hHeap, 0, 16);\n \n  //把32字节的mybuf拷贝到16字节的buf1里面，发生溢出！\n  strcpy(buf1,mybuf);\n\n  //再次分配一块16字节的内存buf2，此时buf1还没有被释放\n  //由于buf1溢出了，所以当写内存的时候就会出错\n  buf2 = HeapAlloc(hHeap, 0, 16);\n\n  //释放这两块内存\n  HeapFree(hHeap, 0, buf1);\n  HeapFree(hHeap, 0, buf2);\n\n  return 0;\n}"
]
