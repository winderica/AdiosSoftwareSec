[
  "static const char en85[] = {\n\t'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n\t'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\n\t'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',\n\t'U', 'V', 'W', 'X', 'Y', 'Z',\n\t'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n\t'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n\t'u', 'v', 'w', 'x', 'y', 'z',\n\t'!', '#', '$', '%', '&', '(', ')', '*', '+', '-',\n\t';', '<', '=', '>', '?', '@', '^', '_',\t'`', '{',\n\t'|', '}', '~'\n};\n\nstatic char de85[256];\nstatic void prep_base85(void)\n{\n\tint i;\n\tif (de85['Z'])\n\t\treturn;\n\tfor (i = 0; i < ARRAY_SIZE(en85); i++) {\n\t\tint ch = en85[i];\n\t\tde85[ch] = i + 1;\n\t}\n}\n\nint decode_85(char *dst, const char *buffer, int len)\n{\n\tprep_base85();\n\n\tsay2(\"decode 85 <%.*s>\", len / 4 * 5, buffer);\n\twhile (len) {\n\t\tunsigned acc = 0;\n\t\tint de, cnt = 4;\n\t\tunsigned char ch;\n\t\tdo {\n\t\t\tch = *buffer++;\n\t\t\tde = de85[ch];\n\t\t\tif (--de < 0)\n\t\t\t\treturn error(\"invalid base85 alphabet %c\", ch);\n\t\t\tacc = acc * 85 + de;\n\t\t} while (--cnt);\n\t\tch = *buffer++;\n\t\tde = de85[ch];\n\t\tif (--de < 0)\n\t\t\treturn error(\"invalid base85 alphabet %c\", ch);\n\t\t/* Detect overflow. */\n\t\tif (0xffffffff / 85 < acc ||\n\t\t    0xffffffff - de < (acc *= 85))\n\t\t\treturn error(\"invalid base85 sequence %.5s\", buffer-5);\n\t\tacc += de;\n\t\tsay1(\" %08x\", acc);\n\n\t\tcnt = (len < 4) ? len : 4;\n\t\tlen -= cnt;\n\t\tdo {\n\t\t\tacc = (acc << 8) | (acc >> 24);\n\t\t\t*dst++ = acc;\n\t\t} while (--cnt);\n\t}\n\tsay(\"\\n\");\n\n\treturn 0;\n}\n\nvoid encode_85(char *buf, const unsigned char *data, int bytes)\n{\n\tsay(\"encode 85\");\n\twhile (bytes) {\n\t\tunsigned acc = 0;\n\t\tint cnt;\n\t\tfor (cnt = 24; cnt >= 0; cnt -= 8) {\n\t\t\tunsigned ch = *data++;\n\t\t\tacc |= ch << cnt;\n\t\t\tif (--bytes == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tsay1(\" %08x\", acc);\n\t\tfor (cnt = 4; cnt >= 0; cnt--) {\n\t\t\tint val = acc % 85;\n\t\t\tacc /= 85;\n\t\t\tbuf[cnt] = en85[val];\n\t\t}\n\t\tbuf += 5;\n\t}\n\tsay(\"\\n\");\n\n\t*buf = 0;\n}\n\nint main(int ac, char **av)\n{\n\tchar buf[1024];\n\n\tif (!strcmp(av[1], \"-e\")) {\n\t\tint len = strlen(av[2]);\n\t\tencode_85(buf, av[2], len);\n\t\tif (len <= 26) len = len + 'A' - 1;\n\t\telse len = len + 'a' - 26 - 1;\n\t\tprintf(\"encoded: %c%s\\n\", len, buf);\n\t\treturn 0;\n\t}\n\tif (!strcmp(av[1], \"-d\")) {\n\t\tint len = *av[2];\n\t\tif ('A' <= len && len <= 'Z') len = len - 'A' + 1;\n\t\telse len = len - 'a' + 26 + 1;\n\t\tdecode_85(buf, av[2]+1, len);\n\t\tprintf(\"decoded: %.*s\\n\", len, buf);\n\t\treturn 0;\n\t}\n\tif (!strcmp(av[1], \"-t\")) {\n\t\tchar t[4] = { -1,-1,-1,-1 };\n\t\tencode_85(buf, t, 4);\n\t\tprintf(\"encoded: D%s\\n\", buf);\n\t\treturn 0;\n\t}\n}",
  "static const char en85[] = {\n\t'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n\t'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\n\t'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',\n\t'U', 'V', 'W', 'X', 'Y', 'Z',\n\t'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n\t'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n\t'u', 'v', 'w', 'x', 'y', 'z',\n\t'!', '#', '$', '%', '&', '(', ')', '*', '+', '-',\n\t';', '<', '=', '>', '?', '@', '^', '_',\t'`', '{',\n\t'|', '}', '~'\n};\n\nstatic char de85[256];\nstatic void prep_base85(void)\n{\n\tint i;\n\tif (de85['Z'])\n\t\treturn;\n\tfor (i = 0; i < ARRAY_SIZE(en85); i++) {\n\t\tint ch = en85[i];\n\t\tde85[ch] = i + 1;\n\t}\n}\n\nint decode_85(char *dst, const char *buffer, int len)\n{\n\tprep_base85();\n\n\tsay2(\"decode 85 <%.*s>\", len/4*5, buffer);\n\twhile (len) {\n\t\tunsigned acc = 0;\n\t\tint de, cnt = 4;\n\t\tunsigned char ch;\n\t\tdo {\n\t\t\tch = *buffer++;\n\t\t\tde = de85[ch];\n\t\t\tif (--de < 0)\n\t\t\t\treturn error(\"invalid base85 alphabet %c\", ch);\n\t\t\tacc = acc * 85 + de;\n\t\t} while (--cnt);\n\t\tch = *buffer++;\n\t\tde = de85[ch];\n\t\tif (--de < 0)\n\t\t\treturn error(\"invalid base85 alphabet %c\", ch);\n\t\t/* Detect overflow. */\n\t\tif (0xffffffff / 85 < acc ||\n\t\t    0xffffffff - de < (acc *= 85))\n\t\t\treturn error(\"invalid base85 sequence %.5s\", buffer-5);\n\t\tacc += de;\n\t\tsay1(\" %08x\", acc);\n\n\t\tcnt = (len < 4) ? len : 4;\n\t\tlen -= cnt;\n\t\tdo {\n\t\t\tacc = (acc << 8) | (acc >> 24);\n\t\t\t*dst++ = acc;\n\t\t} while (--cnt);\n\t}\n\tsay(\"\\n\");\n\n\treturn 0;\n}\n\nvoid encode_85(char *buf, const unsigned char *data, int bytes)\n{\n\tsay(\"encode 85\");\n\twhile (bytes) {\n\t\tunsigned acc = 0;\n\t\tint cnt;\n\t\tfor (cnt = 24; cnt >= 0; cnt -= 8) {\n\t\t\tint ch = *data++;\n\t\t\tacc |= ch << cnt;\n\t\t\tif (--bytes == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tsay1(\" %08x\", acc);\n\t\tfor (cnt = 4; cnt >= 0; cnt--) {\n\t\t\tint val = acc % 85;\n\t\t\tacc /= 85;\n\t\t\tbuf[cnt] = en85[val];\n\t\t}\n\t\tbuf += 5;\n\t}\n\tsay(\"\\n\");\n\n\t*buf = 0;\n}\n\nint main(int ac, char **av)\n{\n\tchar buf[1024];\n\n\tif (!strcmp(av[1], \"-e\")) {\n\t\tint len = strlen(av[2]);\n\t\tencode_85(buf, av[2], len);\n\t\tif (len <= 26) len = len + 'A' - 1;\n\t\telse len = len + 'a' - 26 - 1;\n\t\tprintf(\"encoded: %c%s\\n\", len, buf);\n\t\treturn 0;\n\t}\n\tif (!strcmp(av[1], \"-d\")) {\n\t\tint len = *av[2];\n\t\tif ('A' <= len && len <= 'Z') len = len - 'A' + 1;\n\t\telse len = len - 'a' + 26 + 1;\n\t\tdecode_85(buf, av[2]+1, len);\n\t\tprintf(\"decoded: %.*s\\n\", len, buf);\n\t\treturn 0;\n\t}\n\tif (!strcmp(av[1], \"-t\")) {\n\t\tchar t[4] = { -1,-1,-1,-1 };\n\t\tencode_85(buf, t, 4);\n\t\tprintf(\"encoded: D%s\\n\", buf);\n\t\treturn 0;\n\t}\n}",
  "static const char en85[] = {\n\t'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n\t'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\n\t'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',\n\t'U', 'V', 'W', 'X', 'Y', 'Z',\n\t'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n\t'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n\t'u', 'v', 'w', 'x', 'y', 'z',\n\t'!', '#', '$', '%', '&', '(', ')', '*', '+', '-',\n\t';', '<', '=', '>', '?', '@', '^', '_',\t'`', '{',\n\t'|', '}', '~'\n};\n\nstatic char de85[256];\nstatic void prep_base85(void)\n{\n\tint i;\n\tif (de85['Z'])\n\t\treturn;\n\tfor (i = 0; i < ARRAY_SIZE(en85); i++) {\n\t\tint ch = en85[i];\n\t\tde85[ch] = i + 1;\n\t}\n}\n\nint decode_85(char *dst, const char *buffer, int len)\n{\n\tprep_base85();\n\n\tsay2(\"decode 85 <%.*s>\", len/4*5, buffer);\n\twhile (len) {\n\t\tunsigned acc = 0;\n\t\tint de, cnt = 4;\n\t\tunsigned char ch;\n\t\tdo {\n\t\t\tch = *buffer++;\n\t\t\tde = de85[ch];\n\t\t\tif (--de < 0)\n\t\t\t\treturn error(\"invalid base85 alphabet %c\", ch);\n\t\t\tacc = acc * 85 + de;\n\t\t} while (--cnt);\n\t\tch = *buffer++;\n\t\tde = de85[ch];\n\t\tif (--de < 0)\n\t\t\treturn error(\"invalid base85 alphabet %c\", ch);\n\t\t/*\n\t\t * Detect overflow.  The largest\n\t\t * 5-letter possible is \"|NsC0\" to\n\t\t * encode 0xffffffff, and \"|NsC\" gives\n\t\t * 0x03030303 at this point (i.e.\n\t\t * 0xffffffff = 0x03030303 * 85).\n\t\t */\n\t\tif (0x03030303 < acc ||\n\t\t    0xffffffff - de < (acc *= 85))\n\t\t\treturn error(\"invalid base85 sequence %.5s\", buffer-5);\n\t\tacc += de;\n\t\tsay1(\" %08x\", acc);\n\n\t\tcnt = (len < 4) ? len : 4;\n\t\tlen -= cnt;\n\t\tdo {\n\t\t\tacc = (acc << 8) | (acc >> 24);\n\t\t\t*dst++ = acc;\n\t\t} while (--cnt);\n\t}\n\tsay(\"\\n\");\n\n\treturn 0;\n}\n\nvoid encode_85(char *buf, const unsigned char *data, int bytes)\n{\n\tsay(\"encode 85\");\n\twhile (bytes) {\n\t\tunsigned acc = 0;\n\t\tint cnt;\n\t\tfor (cnt = 24; cnt >= 0; cnt -= 8) {\n\t\t\tint ch = *data++;\n\t\t\tacc |= ch << cnt;\n\t\t\tif (--bytes == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tsay1(\" %08x\", acc);\n\t\tfor (cnt = 4; cnt >= 0; cnt--) {\n\t\t\tint val = acc % 85;\n\t\t\tacc /= 85;\n\t\t\tbuf[cnt] = en85[val];\n\t\t}\n\t\tbuf += 5;\n\t}\n\tsay(\"\\n\");\n\n\t*buf = 0;\n}\n\nint main(int ac, char **av)\n{\n\tchar buf[1024];\n\n\tif (!strcmp(av[1], \"-e\")) {\n\t\tint len = strlen(av[2]);\n\t\tencode_85(buf, av[2], len);\n\t\tif (len <= 26) len = len + 'A' - 1;\n\t\telse len = len + 'a' - 26 - 1;\n\t\tprintf(\"encoded: %c%s\\n\", len, buf);\n\t\treturn 0;\n\t}\n\tif (!strcmp(av[1], \"-d\")) {\n\t\tint len = *av[2];\n\t\tif ('A' <= len && len <= 'Z') len = len - 'A' + 1;\n\t\telse len = len - 'a' + 26 + 1;\n\t\tdecode_85(buf, av[2]+1, len);\n\t\tprintf(\"decoded: %.*s\\n\", len, buf);\n\t\treturn 0;\n\t}\n\tif (!strcmp(av[1], \"-t\")) {\n\t\tchar t[4] = { -1,-1,-1,-1 };\n\t\tencode_85(buf, t, 4);\n\t\tprintf(\"encoded: D%s\\n\", buf);\n\t\treturn 0;\n\t}\n}",
  "static const char en85[] = {\n\t'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n\t'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\n\t'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',\n\t'U', 'V', 'W', 'X', 'Y', 'Z',\n\t'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n\t'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n\t'u', 'v', 'w', 'x', 'y', 'z',\n\t'!', '#', '$', '%', '&', '(', ')', '*', '+', '-',\n\t';', '<', '=', '>', '?', '@', '^', '_',\t'`', '{',\n\t'|', '}', '~'\n};\n\nstatic char de85[256];\nstatic void prep_base85(void)\n{\n\tint i;\n\tif (de85['Z'])\n\t\treturn;\n\tfor (i = 0; i < ARRAY_SIZE(en85); i++) {\n\t\tint ch = en85[i];\n\t\tde85[ch] = i + 1;\n\t}\n}\n\nint decode_85(char *dst, const char *buffer, int len)\n{\n\tprep_base85();\n\n\tsay2(\"decode 85 <%.*s>\", len/4*5, buffer);\n\twhile (len) {\n\t\tunsigned acc = 0;\n\t\tint de, cnt = 4;\n\t\tunsigned char ch;\n\t\tdo {\n\t\t\tch = *buffer++;\n\t\t\tde = de85[ch];\n\t\t\tif (--de < 0)\n\t\t\t\treturn error(\"invalid base85 alphabet %c\", ch);\n\t\t\tacc = acc * 85 + de;\n\t\t} while (--cnt);\n\t\tch = *buffer++;\n\t\tde = de85[ch];\n\t\tif (--de < 0)\n\t\t\treturn error(\"invalid base85 alphabet %c\", ch);\n\t\t/*\n\t\t * Detect overflow.  The largest\n\t\t * 5-letter possible is \"|NsC0\" to\n\t\t * encode 0xffffffff, and \"|NsC\" gives\n\t\t * 0x03030303 at this point (i.e.\n\t\t * 0xffffffff = 0x03030303 * 85).\n\t\t */\n\t\tif (0x03030303 < acc ||\n\t\t    0xffffffff - de < (acc *= 85))\n\t\t\terror(\"invalid base85 sequence %.5s\", buffer-5);\n\t\tacc += de;\n\t\tsay1(\" %08x\", acc);\n\n\t\tcnt = (len < 4) ? len : 4;\n\t\tlen -= cnt;\n\t\tdo {\n\t\t\tacc = (acc << 8) | (acc >> 24);\n\t\t\t*dst++ = acc;\n\t\t} while (--cnt);\n\t}\n\tsay(\"\\n\");\n\n\treturn 0;\n}\n\nvoid encode_85(char *buf, const unsigned char *data, int bytes)\n{\n\tprep_base85();\n\n\tsay(\"encode 85\");\n\twhile (bytes) {\n\t\tunsigned acc = 0;\n\t\tint cnt;\n\t\tfor (cnt = 24; cnt >= 0; cnt -= 8) {\n\t\t\tint ch = *data++;\n\t\t\tacc |= ch << cnt;\n\t\t\tif (--bytes == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tsay1(\" %08x\", acc);\n\t\tfor (cnt = 4; cnt >= 0; cnt--) {\n\t\t\tint val = acc % 85;\n\t\t\tacc /= 85;\n\t\t\tbuf[cnt] = en85[val];\n\t\t}\n\t\tbuf += 5;\n\t}\n\tsay(\"\\n\");\n\n\t*buf = 0;\n}\n\nint main(int ac, char **av)\n{\n\tchar buf[1024];\n\n\tif (!strcmp(av[1], \"-e\")) {\n\t\tint len = strlen(av[2]);\n\t\tencode_85(buf, av[2], len);\n\t\tif (len <= 26) len = len + 'A' - 1;\n\t\telse len = len + 'a' - 26 + 1;\n\t\tprintf(\"encoded: %c%s\\n\", len, buf);\n\t\treturn 0;\n\t}\n\tif (!strcmp(av[1], \"-d\")) {\n\t\tint len = *av[2];\n\t\tif ('A' <= len && len <= 'Z') len = len - 'A' + 1;\n\t\telse len = len - 'a' + 26 + 1;\n\t\tdecode_85(buf, av[2]+1, len);\n\t\tprintf(\"decoded: %.*s\\n\", len, buf);\n\t\treturn 0;\n\t}\n\tif (!strcmp(av[1], \"-t\")) {\n\t\tchar t[4] = { -1,-1,-1,-1 };\n\t\tencode_85(buf, t, 4);\n\t\tprintf(\"encoded: D%s\\n\", buf);\n\t\treturn 0;\n\t}\n}",
  "\nstatic const char en85[] = {\n\t'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n\t'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\n\t'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',\n\t'U', 'V', 'W', 'X', 'Y', 'Z',\n\t'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n\t'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n\t'u', 'v', 'w', 'x', 'y', 'z',\n\t'!', '#', '$', '%', '&', '(', ')', '*', '+', '-',\n\t';', '<', '=', '>', '?', '@', '^', '_',\t'`', '{',\n\t'|', '}', '~'\n};\n\nstatic char de85[256];\nstatic void prep_base85(void)\n{\n\tint i;\n\tif (de85['Z'])\n\t\treturn;\n\tfor (i = 0; i < ARRAY_SIZE(en85); i++) {\n\t\tint ch = en85[i];\n\t\tde85[ch] = i + 1;\n\t}\n}\n\nint decode_85(char *dst, char *buffer, int len)\n{\n\tprep_base85();\n\n\tsay2(\"decode 85 <%.*s>\", len/4*5, buffer);\n\twhile (len) {\n\t\tunsigned acc = 0;\n\t\tint de, cnt = 4;\n\t\tunsigned char ch;\n\t\tdo {\n\t\t\tch = *buffer++;\n\t\t\tde = de85[ch];\n\t\t\tif (--de < 0)\n\t\t\t\treturn error(\"invalid base85 alphabet %c\", ch);\n\t\t\tacc = acc * 85 + de;\n\t\t} while (--cnt);\n\t\tch = *buffer++;\n\t\tde = de85[ch];\n\t\tif (--de < 0)\n\t\t\treturn error(\"invalid base85 alphabet %c\", ch);\n\t\t/*\n\t\t * Detect overflow.  The largest\n\t\t * 5-letter possible is \"|NsC0\" to\n\t\t * encode 0xffffffff, and \"|NsC\" gives\n\t\t * 0x03030303 at this point (i.e.\n\t\t * 0xffffffff = 0x03030303 * 85).\n\t\t */\n\t\tif (0x03030303 < acc ||\n\t\t    0xffffffff - de < (acc *= 85))\n\t\t\terror(\"invalid base85 sequence %.5s\", buffer-5);\n\t\tacc += de;\n\t\tsay1(\" %08x\", acc);\n\n\t\tcnt = (len < 4) ? len : 4;\n\t\tlen -= cnt;\n\t\tdo {\n\t\t\tacc = (acc << 8) | (acc >> 24);\n\t\t\t*dst++ = acc;\n\t\t} while (--cnt);\n\t}\n\tsay(\"\\n\");\n\n\treturn 0;\n}\n\nvoid encode_85(char *buf, unsigned char *data, int bytes)\n{\n\tprep_base85();\n\n\tsay(\"encode 85\");\n\twhile (bytes) {\n\t\tunsigned acc = 0;\n\t\tint cnt;\n\t\tfor (cnt = 24; cnt >= 0; cnt -= 8) {\n\t\t\tint ch = *data++;\n\t\t\tacc |= ch << cnt;\n\t\t\tif (--bytes == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tsay1(\" %08x\", acc);\n\t\tfor (cnt = 4; cnt >= 0; cnt--) {\n\t\t\tint val = acc % 85;\n\t\t\tacc /= 85;\n\t\t\tbuf[cnt] = en85[val];\n\t\t}\n\t\tbuf += 5;\n\t}\n\tsay(\"\\n\");\n\n\t*buf = 0;\n}\n\nint main(int ac, char **av)\n{\n\tchar buf[1024];\n\n\tif (!strcmp(av[1], \"-e\")) {\n\t\tint len = strlen(av[2]);\n\t\tencode_85(buf, av[2], len);\n\t\tif (len <= 26) len = len + 'A' - 1;\n\t\telse len = len + 'a' - 26 + 1;\n\t\tprintf(\"encoded: %c%s\\n\", len, buf);\n\t\treturn 0;\n\t}\n\tif (!strcmp(av[1], \"-d\")) {\n\t\tint len = *av[2];\n\t\tif ('A' <= len && len <= 'Z') len = len - 'A' + 1;\n\t\telse len = len - 'a' + 26 + 1;\n\t\tdecode_85(buf, av[2]+1, len);\n\t\tprintf(\"decoded: %.*s\\n\", len, buf);\n\t\treturn 0;\n\t}\n\tif (!strcmp(av[1], \"-t\")) {\n\t\tchar t[4] = { -1,-1,-1,-1 };\n\t\tencode_85(buf, t, 4);\n\t\tprintf(\"encoded: D%s\\n\", buf);\n\t\treturn 0;\n\t}\n}",
  "/* return length of 's' in letters, ANSI escapes stripped */\nstatic int item_length(const char *s)\n{\n\tint len, i = 0;\n\tstruct strbuf str = STRBUF_INIT;\n\n\tstrbuf_addstr(&str, s);\n\twhile ((s = strstr(str.buf + i, \"\\033[\")) != NULL) {\n\t\tint len = strspn(s + 2, \"0123456789;\");\n\t\ti = s - str.buf;\n\t\tstrbuf_remove(&str, i, len + 3); /* \\033[<len><func char> */\n\t}\n\tlen = utf8_strwidth(str.buf);\n\tstrbuf_release(&str);\n\treturn len;\n}\n\n/*\n * Calculate cell width, rows and cols for a table of equal cells, given\n * table width and how many spaces between cells.\n */\nstatic void layout(struct column_data *data, int *width)\n{\n\tint i;\n\n\t*width = 0;\n\tfor (i = 0; i < data->list->nr; i++)\n\t\tif (*width < data->len[i])\n\t\t\t*width = data->len[i];\n\n\t*width += data->opts.padding;\n\n\tdata->cols = (data->opts.width - strlen(data->opts.indent)) / *width;\n\tif (data->cols == 0)\n\t\tdata->cols = 1;\n\n\tdata->rows = DIV_ROUND_UP(data->list->nr, data->cols);\n}\n\nstatic void compute_column_width(struct column_data *data)\n{\n\tint i, x, y;\n\tfor (x = 0; x < data->cols; x++) {\n\t\tdata->width[x] = XY2LINEAR(data, x, 0);\n\t\tfor (y = 0; y < data->rows; y++) {\n\t\t\ti = XY2LINEAR(data, x, y);\n\t\t\tif (i < data->list->nr &&\n\t\t\t    data->len[data->width[x]] < data->len[i])\n\t\t\t\tdata->width[x] = i;\n\t\t}\n\t}\n}\n\n/*\n * Shrink all columns by shortening them one row each time (and adding\n * more columns along the way). Hopefully the longest cell will be\n * moved to the next column, column is shrunk so we have more space\n * for new columns. The process ends when the whole thing no longer\n * fits in data->total_width.\n */\nstatic void shrink_columns(struct column_data *data)\n{\n\tREALLOC_ARRAY(data->width, data->cols);\n\twhile (data->rows > 1) {\n\t\tint x, total_width, cols, rows;\n\t\trows = data->rows;\n\t\tcols = data->cols;\n\n\t\tdata->rows--;\n\t\tdata->cols = DIV_ROUND_UP(data->list->nr, data->rows);\n\t\tif (data->cols != cols)\n\t\t\tREALLOC_ARRAY(data->width, data->cols);\n\t\tcompute_column_width(data);\n\n\t\ttotal_width = strlen(data->opts.indent);\n\t\tfor (x = 0; x < data->cols; x++) {\n\t\t\ttotal_width += data->len[data->width[x]];\n\t\t\ttotal_width += data->opts.padding;\n\t\t}\n\t\tif (total_width > data->opts.width) {\n\t\t\tdata->rows = rows;\n\t\t\tdata->cols = cols;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcompute_column_width(data);\n}\n\n/* Display without layout when not enabled */\nstatic void display_plain(const struct string_list *list,\n\t\t\t  const char *indent, const char *nl)\n{\n\tint i;\n\n\tfor (i = 0; i < list->nr; i++)\n\t\tprintf(\"%s%s%s\", indent, list->items[i].string, nl);\n}\n\n/* Print a cell to stdout with all necessary leading/traling space */\nstatic int display_cell(struct column_data *data, int initial_width,\n\t\t\tconst char *empty_cell, int x, int y)\n{\n\tint i, len, newline;\n\n\ti = XY2LINEAR(data, x, y);\n\tif (i >= data->list->nr)\n\t\treturn -1;\n\n\tlen = data->len[i];\n\tif (data->width && data->len[data->width[x]] < initial_width) {\n\t\t/*\n\t\t * empty_cell has initial_width chars, if real column\n\t\t * is narrower, increase len a bit so we fill less\n\t\t * space.\n\t\t */\n\t\tlen += initial_width - data->len[data->width[x]];\n\t\tlen -= data->opts.padding;\n\t}\n\n\tif (COL_LAYOUT(data->colopts) == COL_COLUMN)\n\t\tnewline = i + data->rows >= data->list->nr;\n\telse\n\t\tnewline = x == data->cols - 1 || i == data->list->nr - 1;\n\n\tprintf(\"%s%s%s\",\n\t       x == 0 ? data->opts.indent : \"\",\n\t       data->list->items[i].string,\n\t       newline ? data->opts.nl : empty_cell + len);\n\treturn 0;\n}\n\n/* Display COL_COLUMN or COL_ROW */\nstatic void display_table(const struct string_list *list,\n\t\t\t  unsigned int colopts,\n\t\t\t  const struct column_options *opts)\n{\n\tstruct column_data data;\n\tint x, y, i, initial_width;\n\tchar *empty_cell;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.list = list;\n\tdata.colopts = colopts;\n\tdata.opts = *opts;\n\n\tALLOC_ARRAY(data.len, list->nr);\n\tfor (i = 0; i < list->nr; i++)\n\t\tdata.len[i] = item_length(list->items[i].string);\n\n\tlayout(&data, &initial_width);\n\n\tif (colopts & COL_DENSE)\n\t\tshrink_columns(&data);\n\n\tempty_cell = xmallocz(initial_width);\n\tmemset(empty_cell, ' ', initial_width);\n\tfor (y = 0; y < data.rows; y++) {\n\t\tfor (x = 0; x < data.cols; x++)\n\t\t\tif (display_cell(&data, initial_width, empty_cell, x, y))\n\t\t\t\tbreak;\n\t}\n\n\tfree(data.len);\n\tfree(data.width);\n\tfree(empty_cell);\n}\n",
  "/* return length of 's' in letters, ANSI escapes stripped */\nstatic int item_length(unsigned int colopts, const char *s)\n{\n\tint len, i = 0;\n\tstruct strbuf str = STRBUF_INIT;\n\n\tstrbuf_addstr(&str, s);\n\twhile ((s = strstr(str.buf + i, \"\\033[\")) != NULL) {\n\t\tint len = strspn(s + 2, \"0123456789;\");\n\t\ti = s - str.buf;\n\t\tstrbuf_remove(&str, i, len + 3); /* \\033[<len><func char> */\n\t}\n\tlen = utf8_strwidth(str.buf);\n\tstrbuf_release(&str);\n\treturn len;\n}\n\n/*\n * Calculate cell width, rows and cols for a table of equal cells, given\n * table width and how many spaces between cells.\n */\nstatic void layout(struct column_data *data, int *width)\n{\n\tint i;\n\n\t*width = 0;\n\tfor (i = 0; i < data->list->nr; i++)\n\t\tif (*width < data->len[i])\n\t\t\t*width = data->len[i];\n\n\t*width += data->opts.padding;\n\n\tdata->cols = (data->opts.width - strlen(data->opts.indent)) / *width;\n\tif (data->cols == 0)\n\t\tdata->cols = 1;\n\n\tdata->rows = DIV_ROUND_UP(data->list->nr, data->cols);\n}\n\nstatic void compute_column_width(struct column_data *data)\n{\n\tint i, x, y;\n\tfor (x = 0; x < data->cols; x++) {\n\t\tdata->width[x] = XY2LINEAR(data, x, 0);\n\t\tfor (y = 0; y < data->rows; y++) {\n\t\t\ti = XY2LINEAR(data, x, y);\n\t\t\tif (i < data->list->nr &&\n\t\t\t    data->len[data->width[x]] < data->len[i])\n\t\t\t\tdata->width[x] = i;\n\t\t}\n\t}\n}\n\n/*\n * Shrink all columns by shortening them one row each time (and adding\n * more columns along the way). Hopefully the longest cell will be\n * moved to the next column, column is shrunk so we have more space\n * for new columns. The process ends when the whole thing no longer\n * fits in data->total_width.\n */\nstatic void shrink_columns(struct column_data *data)\n{\n\tREALLOC_ARRAY(data->width, data->cols);\n\twhile (data->rows > 1) {\n\t\tint x, total_width, cols, rows;\n\t\trows = data->rows;\n\t\tcols = data->cols;\n\n\t\tdata->rows--;\n\t\tdata->cols = DIV_ROUND_UP(data->list->nr, data->rows);\n\t\tif (data->cols != cols)\n\t\t\tREALLOC_ARRAY(data->width, data->cols);\n\t\tcompute_column_width(data);\n\n\t\ttotal_width = strlen(data->opts.indent);\n\t\tfor (x = 0; x < data->cols; x++) {\n\t\t\ttotal_width += data->len[data->width[x]];\n\t\t\ttotal_width += data->opts.padding;\n\t\t}\n\t\tif (total_width > data->opts.width) {\n\t\t\tdata->rows = rows;\n\t\t\tdata->cols = cols;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcompute_column_width(data);\n}\n\n/* Display without layout when not enabled */\nstatic void display_plain(const struct string_list *list,\n\t\t\t  const char *indent, const char *nl)\n{\n\tint i;\n\n\tfor (i = 0; i < list->nr; i++)\n\t\tprintf(\"%s%s%s\", indent, list->items[i].string, nl);\n}\n\n/* Print a cell to stdout with all necessary leading/traling space */\nstatic int display_cell(struct column_data *data, int initial_width,\n\t\t\tconst char *empty_cell, int x, int y)\n{\n\tint i, len, newline;\n\n\ti = XY2LINEAR(data, x, y);\n\tif (i >= data->list->nr)\n\t\treturn -1;\n\n\tlen = data->len[i];\n\tif (data->width && data->len[data->width[x]] < initial_width) {\n\t\t/*\n\t\t * empty_cell has initial_width chars, if real column\n\t\t * is narrower, increase len a bit so we fill less\n\t\t * space.\n\t\t */\n\t\tlen += initial_width - data->len[data->width[x]];\n\t\tlen -= data->opts.padding;\n\t}\n\n\tif (COL_LAYOUT(data->colopts) == COL_COLUMN)\n\t\tnewline = i + data->rows >= data->list->nr;\n\telse\n\t\tnewline = x == data->cols - 1 || i == data->list->nr - 1;\n\n\tprintf(\"%s%s%s\",\n\t       x == 0 ? data->opts.indent : \"\",\n\t       data->list->items[i].string,\n\t       newline ? data->opts.nl : empty_cell + len);\n\treturn 0;\n}\n\n/* Display COL_COLUMN or COL_ROW */\nstatic void display_table(const struct string_list *list,\n\t\t\t  unsigned int colopts,\n\t\t\t  const struct column_options *opts)\n{\n\tstruct column_data data;\n\tint x, y, i, initial_width;\n\tchar *empty_cell;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.list = list;\n\tdata.colopts = colopts;\n\tdata.opts = *opts;\n\n\tALLOC_ARRAY(data.len, list->nr);\n\tfor (i = 0; i < list->nr; i++)\n\t\tdata.len[i] = item_length(colopts, list->items[i].string);\n\n\tlayout(&data, &initial_width);\n\n\tif (colopts & COL_DENSE)\n\t\tshrink_columns(&data);\n\n\tempty_cell = xmallocz(initial_width);\n\tmemset(empty_cell, ' ', initial_width);\n\tfor (y = 0; y < data.rows; y++) {\n\t\tfor (x = 0; x < data.cols; x++)\n\t\t\tif (display_cell(&data, initial_width, empty_cell, x, y))\n\t\t\t\tbreak;\n\t}\n\n\tfree(data.len);\n\tfree(data.width);\n\tfree(empty_cell);\n}\n",
  "/* return length of 's' in letters, ANSI escapes stripped */\nstatic int item_length(unsigned int colopts, const char *s)\n{\n\tint len, i = 0;\n\tstruct strbuf str = STRBUF_INIT;\n\n\tstrbuf_addstr(&str, s);\n\twhile ((s = strstr(str.buf + i, \"\\033[\")) != NULL) {\n\t\tint len = strspn(s + 2, \"0123456789;\");\n\t\ti = s - str.buf;\n\t\tstrbuf_remove(&str, i, len + 3); /* \\033[<len><func char> */\n\t}\n\tlen = utf8_strwidth(str.buf);\n\tstrbuf_release(&str);\n\treturn len;\n}\n\n/*\n * Calculate cell width, rows and cols for a table of equal cells, given\n * table width and how many spaces between cells.\n */\nstatic void layout(struct column_data *data, int *width)\n{\n\tint i;\n\n\t*width = 0;\n\tfor (i = 0; i < data->list->nr; i++)\n\t\tif (*width < data->len[i])\n\t\t\t*width = data->len[i];\n\n\t*width += data->opts.padding;\n\n\tdata->cols = (data->opts.width - strlen(data->opts.indent)) / *width;\n\tif (data->cols == 0)\n\t\tdata->cols = 1;\n\n\tdata->rows = DIV_ROUND_UP(data->list->nr, data->cols);\n}\n\nstatic void compute_column_width(struct column_data *data)\n{\n\tint i, x, y;\n\tfor (x = 0; x < data->cols; x++) {\n\t\tdata->width[x] = XY2LINEAR(data, x, 0);\n\t\tfor (y = 0; y < data->rows; y++) {\n\t\t\ti = XY2LINEAR(data, x, y);\n\t\t\tif (i < data->list->nr &&\n\t\t\t    data->len[data->width[x]] < data->len[i])\n\t\t\t\tdata->width[x] = i;\n\t\t}\n\t}\n}\n\n/*\n * Shrink all columns by shortening them one row each time (and adding\n * more columns along the way). Hopefully the longest cell will be\n * moved to the next column, column is shrunk so we have more space\n * for new columns. The process ends when the whole thing no longer\n * fits in data->total_width.\n */\nstatic void shrink_columns(struct column_data *data)\n{\n\tdata->width = xrealloc(data->width,\n\t\t\t       sizeof(*data->width) * data->cols);\n\twhile (data->rows > 1) {\n\t\tint x, total_width, cols, rows;\n\t\trows = data->rows;\n\t\tcols = data->cols;\n\n\t\tdata->rows--;\n\t\tdata->cols = DIV_ROUND_UP(data->list->nr, data->rows);\n\t\tif (data->cols != cols)\n\t\t\tdata->width = xrealloc(data->width,\n\t\t\t\t\t       sizeof(*data->width) * data->cols);\n\t\tcompute_column_width(data);\n\n\t\ttotal_width = strlen(data->opts.indent);\n\t\tfor (x = 0; x < data->cols; x++) {\n\t\t\ttotal_width += data->len[data->width[x]];\n\t\t\ttotal_width += data->opts.padding;\n\t\t}\n\t\tif (total_width > data->opts.width) {\n\t\t\tdata->rows = rows;\n\t\t\tdata->cols = cols;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcompute_column_width(data);\n}\n\n/* Display without layout when not enabled */\nstatic void display_plain(const struct string_list *list,\n\t\t\t  const char *indent, const char *nl)\n{\n\tint i;\n\n\tfor (i = 0; i < list->nr; i++)\n\t\tprintf(\"%s%s%s\", indent, list->items[i].string, nl);\n}\n\n/* Print a cell to stdout with all necessary leading/traling space */\nstatic int display_cell(struct column_data *data, int initial_width,\n\t\t\tconst char *empty_cell, int x, int y)\n{\n\tint i, len, newline;\n\n\ti = XY2LINEAR(data, x, y);\n\tif (i >= data->list->nr)\n\t\treturn -1;\n\n\tlen = data->len[i];\n\tif (data->width && data->len[data->width[x]] < initial_width) {\n\t\t/*\n\t\t * empty_cell has initial_width chars, if real column\n\t\t * is narrower, increase len a bit so we fill less\n\t\t * space.\n\t\t */\n\t\tlen += initial_width - data->len[data->width[x]];\n\t\tlen -= data->opts.padding;\n\t}\n\n\tif (COL_LAYOUT(data->colopts) == COL_COLUMN)\n\t\tnewline = i + data->rows >= data->list->nr;\n\telse\n\t\tnewline = x == data->cols - 1 || i == data->list->nr - 1;\n\n\tprintf(\"%s%s%s\",\n\t       x == 0 ? data->opts.indent : \"\",\n\t       data->list->items[i].string,\n\t       newline ? data->opts.nl : empty_cell + len);\n\treturn 0;\n}\n\n/* Display COL_COLUMN or COL_ROW */\nstatic void display_table(const struct string_list *list,\n\t\t\t  unsigned int colopts,\n\t\t\t  const struct column_options *opts)\n{\n\tstruct column_data data;\n\tint x, y, i, initial_width;\n\tchar *empty_cell;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.list = list;\n\tdata.colopts = colopts;\n\tdata.opts = *opts;\n\n\tdata.len = xmalloc(sizeof(*data.len) * list->nr);\n\tfor (i = 0; i < list->nr; i++)\n\t\tdata.len[i] = item_length(colopts, list->items[i].string);\n\n\tlayout(&data, &initial_width);\n\n\tif (colopts & COL_DENSE)\n\t\tshrink_columns(&data);\n\n\tempty_cell = xmalloc(initial_width + 1);\n\tmemset(empty_cell, ' ', initial_width);\n\tempty_cell[initial_width] = '\\0';\n\tfor (y = 0; y < data.rows; y++) {\n\t\tfor (x = 0; x < data.cols; x++)\n\t\t\tif (display_cell(&data, initial_width, empty_cell, x, y))\n\t\t\t\tbreak;\n\t}\n\n\tfree(data.len);\n\tfree(data.width);\n\tfree(empty_cell);\n}\n",
  "/* return length of 's' in letters, ANSI escapes stripped */\nstatic int item_length(unsigned int colopts, const char *s)\n{\n\tint len, i = 0;\n\tstruct strbuf str = STRBUF_INIT;\n\n\tstrbuf_addstr(&str, s);\n\twhile ((s = strstr(str.buf + i, \"\\033[\")) != NULL) {\n\t\tint len = strspn(s + 2, \"0123456789;\");\n\t\ti = s - str.buf;\n\t\tstrbuf_remove(&str, i, len + 3); /* \\033[<len><func char> */\n\t}\n\tlen = utf8_strwidth(str.buf);\n\tstrbuf_release(&str);\n\treturn len;\n}\n\n/*\n * Calculate cell width, rows and cols for a table of equal cells, given\n * table width and how many spaces between cells.\n */\nstatic void layout(struct column_data *data, int *width)\n{\n\tint i;\n\n\t*width = 0;\n\tfor (i = 0; i < data->list->nr; i++)\n\t\tif (*width < data->len[i])\n\t\t\t*width = data->len[i];\n\n\t*width += data->opts.padding;\n\n\tdata->cols = (data->opts.width - strlen(data->opts.indent)) / *width;\n\tif (data->cols == 0)\n\t\tdata->cols = 1;\n\n\tdata->rows = DIV_ROUND_UP(data->list->nr, data->cols);\n}\n\n/* Display without layout when not enabled */\nstatic void display_plain(const struct string_list *list,\n\t\t\t  const char *indent, const char *nl)\n{\n\tint i;\n\n\tfor (i = 0; i < list->nr; i++)\n\t\tprintf(\"%s%s%s\", indent, list->items[i].string, nl);\n}\n\n/* Print a cell to stdout with all necessary leading/traling space */\nstatic int display_cell(struct column_data *data, int initial_width,\n\t\t\tconst char *empty_cell, int x, int y)\n{\n\tint i, len, newline;\n\n\ti = XY2LINEAR(data, x, y);\n\tif (i >= data->list->nr)\n\t\treturn -1;\n\tlen = data->len[i];\n\tif (COL_LAYOUT(data->colopts) == COL_COLUMN)\n\t\tnewline = i + data->rows >= data->list->nr;\n\telse\n\t\tnewline = x == data->cols - 1 || i == data->list->nr - 1;\n\n\tprintf(\"%s%s%s\",\n\t       x == 0 ? data->opts.indent : \"\",\n\t       data->list->items[i].string,\n\t       newline ? data->opts.nl : empty_cell + len);\n\treturn 0;\n}\n\n/* Display COL_COLUMN or COL_ROW */\nstatic void display_table(const struct string_list *list,\n\t\t\t  unsigned int colopts,\n\t\t\t  const struct column_options *opts)\n{\n\tstruct column_data data;\n\tint x, y, i, initial_width;\n\tchar *empty_cell;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.list = list;\n\tdata.colopts = colopts;\n\tdata.opts = *opts;\n\n\tdata.len = xmalloc(sizeof(*data.len) * list->nr);\n\tfor (i = 0; i < list->nr; i++)\n\t\tdata.len[i] = item_length(colopts, list->items[i].string);\n\n\tlayout(&data, &initial_width);\n\n\tempty_cell = xmalloc(initial_width + 1);\n\tmemset(empty_cell, ' ', initial_width);\n\tempty_cell[initial_width] = '\\0';\n\tfor (y = 0; y < data.rows; y++) {\n\t\tfor (x = 0; x < data.cols; x++)\n\t\t\tif (display_cell(&data, initial_width, empty_cell, x, y))\n\t\t\t\tbreak;\n\t}\n\n\tfree(data.len);\n\tfree(empty_cell);\n}",
  "/* return length of 's' in letters, ANSI escapes stripped */\nstatic int item_length(unsigned int colopts, const char *s)\n{\n\tint len, i = 0;\n\tstruct strbuf str = STRBUF_INIT;\n\n\tstrbuf_addstr(&str, s);\n\twhile ((s = strstr(str.buf + i, \"\\033[\")) != NULL) {\n\t\tint len = strspn(s + 2, \"0123456789;\");\n\t\ti = s - str.buf;\n\t\tstrbuf_remove(&str, i, len + 3); /* \\033[<len><func char> */\n\t}\n\tlen = utf8_strwidth(str.buf);\n\tstrbuf_release(&str);\n\treturn len;\n}\n\n/*\n * Calculate cell width, rows and cols for a table of equal cells, given\n * table width and how many spaces between cells.\n */\nstatic void layout(struct column_data *data, int *width)\n{\n\tint i;\n\n\t*width = 0;\n\tfor (i = 0; i < data->list->nr; i++)\n\t\tif (*width < data->len[i])\n\t\t\t*width = data->len[i];\n\n\t*width += data->opts.padding;\n\n\tdata->cols = (data->opts.width - strlen(data->opts.indent)) / *width;\n\tif (data->cols == 0)\n\t\tdata->cols = 1;\n\n\tdata->rows = DIV_ROUND_UP(data->list->nr, data->cols);\n}\n\nstatic void compute_column_width(struct column_data *data)\n{\n\tint i, x, y;\n\tfor (x = 0; x < data->cols; x++) {\n\t\tdata->width[x] = XY2LINEAR(data, x, 0);\n\t\tfor (y = 0; y < data->rows; y++) {\n\t\t\ti = XY2LINEAR(data, x, y);\n\t\t\tif (i < data->list->nr &&\n\t\t\t    data->len[data->width[x]] < data->len[i])\n\t\t\t\tdata->width[x] = i;\n\t\t}\n\t}\n}\n\n/*\n * Shrink all columns by shortening them one row each time (and adding\n * more columns along the way). Hopefully the longest cell will be\n * moved to the next column, column is shrunk so we have more space\n * for new columns. The process ends when the whole thing no longer\n * fits in data->total_width.\n */\nstatic void shrink_columns(struct column_data *data)\n{\n\tREALLOC_ARRAY(data->width, data->cols);\n\twhile (data->rows > 1) {\n\t\tint x, total_width, cols, rows;\n\t\trows = data->rows;\n\t\tcols = data->cols;\n\n\t\tdata->rows--;\n\t\tdata->cols = DIV_ROUND_UP(data->list->nr, data->rows);\n\t\tif (data->cols != cols)\n\t\t\tREALLOC_ARRAY(data->width, data->cols);\n\t\tcompute_column_width(data);\n\n\t\ttotal_width = strlen(data->opts.indent);\n\t\tfor (x = 0; x < data->cols; x++) {\n\t\t\ttotal_width += data->len[data->width[x]];\n\t\t\ttotal_width += data->opts.padding;\n\t\t}\n\t\tif (total_width > data->opts.width) {\n\t\t\tdata->rows = rows;\n\t\t\tdata->cols = cols;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcompute_column_width(data);\n}\n\n/* Display without layout when not enabled */\nstatic void display_plain(const struct string_list *list,\n\t\t\t  const char *indent, const char *nl)\n{\n\tint i;\n\n\tfor (i = 0; i < list->nr; i++)\n\t\tprintf(\"%s%s%s\", indent, list->items[i].string, nl);\n}\n\n/* Print a cell to stdout with all necessary leading/traling space */\nstatic int display_cell(struct column_data *data, int initial_width,\n\t\t\tconst char *empty_cell, int x, int y)\n{\n\tint i, len, newline;\n\n\ti = XY2LINEAR(data, x, y);\n\tif (i >= data->list->nr)\n\t\treturn -1;\n\n\tlen = data->len[i];\n\tif (data->width && data->len[data->width[x]] < initial_width) {\n\t\t/*\n\t\t * empty_cell has initial_width chars, if real column\n\t\t * is narrower, increase len a bit so we fill less\n\t\t * space.\n\t\t */\n\t\tlen += initial_width - data->len[data->width[x]];\n\t\tlen -= data->opts.padding;\n\t}\n\n\tif (COL_LAYOUT(data->colopts) == COL_COLUMN)\n\t\tnewline = i + data->rows >= data->list->nr;\n\telse\n\t\tnewline = x == data->cols - 1 || i == data->list->nr - 1;\n\n\tprintf(\"%s%s%s\",\n\t       x == 0 ? data->opts.indent : \"\",\n\t       data->list->items[i].string,\n\t       newline ? data->opts.nl : empty_cell + len);\n\treturn 0;\n}\n\n/* Display COL_COLUMN or COL_ROW */\nstatic void display_table(const struct string_list *list,\n\t\t\t  unsigned int colopts,\n\t\t\t  const struct column_options *opts)\n{\n\tstruct column_data data;\n\tint x, y, i, initial_width;\n\tchar *empty_cell;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.list = list;\n\tdata.colopts = colopts;\n\tdata.opts = *opts;\n\n\tdata.len = xmalloc(sizeof(*data.len) * list->nr);\n\tfor (i = 0; i < list->nr; i++)\n\t\tdata.len[i] = item_length(colopts, list->items[i].string);\n\n\tlayout(&data, &initial_width);\n\n\tif (colopts & COL_DENSE)\n\t\tshrink_columns(&data);\n\n\tempty_cell = xmalloc(initial_width + 1);\n\tmemset(empty_cell, ' ', initial_width);\n\tempty_cell[initial_width] = '\\0';\n\tfor (y = 0; y < data.rows; y++) {\n\t\tfor (x = 0; x < data.cols; x++)\n\t\t\tif (display_cell(&data, initial_width, empty_cell, x, y))\n\t\t\t\tbreak;\n\t}\n\n\tfree(data.len);\n\tfree(data.width);\n\tfree(empty_cell);\n}\n",
  "/*\n * Reads the patches into a string list, with the `util` field being populated\n * as struct object_id (will need to be free()d).\n */\nstatic int read_patches(const char *range, struct string_list *list)\n{\n\tstruct child_process cp = CHILD_PROCESS_INIT;\n\tstruct strbuf buf = STRBUF_INIT, contents = STRBUF_INIT;\n\tstruct patch_util *util = NULL;\n\tint in_header = 1;\n\tchar *line, *current_filename = NULL;\n\tint offset, len;\n\tsize_t size;\n\n\targv_array_pushl(&cp.args, \"log\", \"--no-color\", \"-p\", \"--no-merges\",\n\t\t\t\"--reverse\", \"--date-order\", \"--decorate=no\",\n\t\t\t/*\n\t\t\t * Choose indicators that are not used anywhere\n\t\t\t * else in diffs, but still look reasonable\n\t\t\t * (e.g. will not be confusing when debugging)\n\t\t\t */\n\t\t\t\"--output-indicator-new=>\",\n\t\t\t\"--output-indicator-old=<\",\n\t\t\t\"--output-indicator-context=#\",\n\t\t\t\"--no-abbrev-commit\", range,\n\t\t\tNULL);\n\tcp.out = -1;\n\tcp.no_stdin = 1;\n\tcp.git_cmd = 1;\n\n\tif (start_command(&cp))\n\t\treturn error_errno(_(\"could not start `log`\"));\n\tif (strbuf_read(&contents, cp.out, 0) < 0) {\n\t\terror_errno(_(\"could not read `log` output\"));\n\t\tfinish_command(&cp);\n\t\treturn -1;\n\t}\n\n\tline = contents.buf;\n\tsize = contents.len;\n\tfor (offset = 0; size > 0; offset += len, size -= len, line += len) {\n\t\tconst char *p;\n\n\t\tlen = find_end_of_line(line, size);\n\t\tline[len - 1] = '\\0';\n\t\tif (skip_prefix(line, \"commit \", &p)) {\n\t\t\tif (util) {\n\t\t\t\tstring_list_append(list, buf.buf)->util = util;\n\t\t\t\tstrbuf_reset(&buf);\n\t\t\t}\n\t\t\tutil = xcalloc(sizeof(*util), 1);\n\t\t\tif (get_oid(p, &util->oid)) {\n\t\t\t\terror(_(\"could not parse commit '%s'\"), p);\n\t\t\t\tfree(util);\n\t\t\t\tstring_list_clear(list, 1);\n\t\t\t\tstrbuf_release(&buf);\n\t\t\t\tstrbuf_release(&contents);\n\t\t\t\tfinish_command(&cp);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tutil->matching = -1;\n\t\t\tin_header = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (starts_with(line, \"diff --git\")) {\n\t\t\tstruct patch patch = { 0 };\n\t\t\tstruct strbuf root = STRBUF_INIT;\n\t\t\tint linenr = 0;\n\n\t\t\tin_header = 0;\n\t\t\tstrbuf_addch(&buf, '\\n');\n\t\t\tif (!util->diff_offset)\n\t\t\t\tutil->diff_offset = buf.len;\n\t\t\tline[len - 1] = '\\n';\n\t\t\tlen = parse_git_diff_header(&root, &linenr, 1, line,\n\t\t\t\t\t\t    len, size, &patch);\n\t\t\tif (len < 0)\n\t\t\t\tdie(_(\"could not parse git header '%.*s'\"), (int)len, line);\n\t\t\tstrbuf_addstr(&buf, \" ## \");\n\t\t\tif (patch.is_new > 0)\n\t\t\t\tstrbuf_addf(&buf, \"%s (new)\", patch.new_name);\n\t\t\telse if (patch.is_delete > 0)\n\t\t\t\tstrbuf_addf(&buf, \"%s (deleted)\", patch.old_name);\n\t\t\telse if (patch.is_rename)\n\t\t\t\tstrbuf_addf(&buf, \"%s => %s\", patch.old_name, patch.new_name);\n\t\t\telse\n\t\t\t\tstrbuf_addstr(&buf, patch.new_name);\n\n\t\t\tfree(current_filename);\n\t\t\tif (patch.is_delete > 0)\n\t\t\t\tcurrent_filename = xstrdup(patch.old_name);\n\t\t\telse\n\t\t\t\tcurrent_filename = xstrdup(patch.new_name);\n\n\t\t\tif (patch.new_mode && patch.old_mode &&\n\t\t\t    patch.old_mode != patch.new_mode)\n\t\t\t\tstrbuf_addf(&buf, \" (mode change %06o => %06o)\",\n\t\t\t\t\t    patch.old_mode, patch.new_mode);\n\n\t\t\tstrbuf_addstr(&buf, \" ##\");\n\t\t} else if (in_header) {\n\t\t\tif (starts_with(line, \"Author: \")) {\n\t\t\t\tstrbuf_addstr(&buf, \" ## Metadata ##\\n\");\n\t\t\t\tstrbuf_addstr(&buf, line);\n\t\t\t\tstrbuf_addstr(&buf, \"\\n\\n\");\n\t\t\t\tstrbuf_addstr(&buf, \" ## Commit message ##\\n\");\n\t\t\t} else if (starts_with(line, \"    \")) {\n\t\t\t\tp = line + len - 2;\n\t\t\t\twhile (isspace(*p) && p >= line)\n\t\t\t\t\tp--;\n\t\t\t\tstrbuf_add(&buf, line, p - line + 1);\n\t\t\t\tstrbuf_addch(&buf, '\\n');\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else if (skip_prefix(line, \"@@ \", &p)) {\n\t\t\tp = strstr(p, \"@@\");\n\t\t\tstrbuf_addstr(&buf, \"@@\");\n\t\t\tif (current_filename && p[2])\n\t\t\t\tstrbuf_addf(&buf, \" %s:\", current_filename);\n\t\t\tif (p)\n\t\t\t\tstrbuf_addstr(&buf, p + 2);\n\t\t} else if (!line[0])\n\t\t\t/*\n\t\t\t * A completely blank (not ' \\n', which is context)\n\t\t\t * line is not valid in a diff.  We skip it\n\t\t\t * silently, because this neatly handles the blank\n\t\t\t * separator line between commits in git-log\n\t\t\t * output.\n\t\t\t */\n\t\t\tcontinue;\n\t\telse if (line[0] == '>') {\n\t\t\tstrbuf_addch(&buf, '+');\n\t\t\tstrbuf_addstr(&buf, line + 1);\n\t\t} else if (line[0] == '<') {\n\t\t\tstrbuf_addch(&buf, '-');\n\t\t\tstrbuf_addstr(&buf, line + 1);\n\t\t} else if (line[0] == '#') {\n\t\t\tstrbuf_addch(&buf, ' ');\n\t\t\tstrbuf_addstr(&buf, line + 1);\n\t\t} else {\n\t\t\tstrbuf_addch(&buf, ' ');\n\t\t\tstrbuf_addstr(&buf, line);\n\t\t}\n\n\t\tstrbuf_addch(&buf, '\\n');\n\t\tutil->diffsize++;\n\t}\n\tstrbuf_release(&contents);\n\n\tif (util)\n\t\tstring_list_append(list, buf.buf)->util = util;\n\tstrbuf_release(&buf);\n\tfree(current_filename);\n\n\tif (finish_command(&cp))\n\t\treturn -1;\n\n\treturn 0;\n}\n",
  "/*\n * Reads the patches into a string list, with the `util` field being populated\n * as struct object_id (will need to be free()d).\n */\nstatic int read_patches(const char *range, struct string_list *list)\n{\n\tstruct child_process cp = CHILD_PROCESS_INIT;\n\tstruct strbuf buf = STRBUF_INIT, contents = STRBUF_INIT;\n\tstruct patch_util *util = NULL;\n\tint in_header = 1;\n\tchar *line, *current_filename = NULL;\n\tint offset, len;\n\tsize_t size;\n\n\targv_array_pushl(&cp.args, \"log\", \"--no-color\", \"-p\", \"--no-merges\",\n\t\t\t\"--reverse\", \"--date-order\", \"--decorate=no\",\n\t\t\t/*\n\t\t\t * Choose indicators that are not used anywhere\n\t\t\t * else in diffs, but still look reasonable\n\t\t\t * (e.g. will not be confusing when debugging)\n\t\t\t */\n\t\t\t\"--output-indicator-new=>\",\n\t\t\t\"--output-indicator-old=<\",\n\t\t\t\"--output-indicator-context=#\",\n\t\t\t\"--no-abbrev-commit\", range,\n\t\t\tNULL);\n\tcp.out = -1;\n\tcp.no_stdin = 1;\n\tcp.git_cmd = 1;\n\n\tif (start_command(&cp))\n\t\treturn error_errno(_(\"could not start `log`\"));\n\tif (strbuf_read(&contents, cp.out, 0) < 0) {\n\t\terror_errno(_(\"could not read `log` output\"));\n\t\tfinish_command(&cp);\n\t\treturn -1;\n\t}\n\n\tline = contents.buf;\n\tsize = contents.len;\n\tfor (offset = 0; size > 0; offset += len, size -= len, line += len) {\n\t\tconst char *p;\n\n\t\tlen = find_end_of_line(line, size);\n\t\tline[len - 1] = '\\0';\n\t\tif (skip_prefix(line, \"commit \", &p)) {\n\t\t\tif (util) {\n\t\t\t\tstring_list_append(list, buf.buf)->util = util;\n\t\t\t\tstrbuf_reset(&buf);\n\t\t\t}\n\t\t\tutil = xcalloc(sizeof(*util), 1);\n\t\t\tif (get_oid(p, &util->oid)) {\n\t\t\t\terror(_(\"could not parse commit '%s'\"), p);\n\t\t\t\tfree(util);\n\t\t\t\tstring_list_clear(list, 1);\n\t\t\t\tstrbuf_release(&buf);\n\t\t\t\tstrbuf_release(&contents);\n\t\t\t\tfinish_command(&cp);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tutil->matching = -1;\n\t\t\tin_header = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (starts_with(line, \"diff --git\")) {\n\t\t\tstruct patch patch = { 0 };\n\t\t\tstruct strbuf root = STRBUF_INIT;\n\t\t\tint linenr = 0;\n\n\t\t\tin_header = 0;\n\t\t\tstrbuf_addch(&buf, '\\n');\n\t\t\tif (!util->diff_offset)\n\t\t\t\tutil->diff_offset = buf.len;\n\t\t\tline[len - 1] = '\\n';\n\t\t\tlen = parse_git_diff_header(&root, &linenr, 1, line,\n\t\t\t\t\t\t    len, size, &patch);\n\t\t\tif (len < 0)\n\t\t\t\tdie(_(\"could not parse git header '%.*s'\"), (int)len, line);\n\t\t\tstrbuf_addstr(&buf, \" ## \");\n\t\t\tif (patch.is_new > 0)\n\t\t\t\tstrbuf_addf(&buf, \"%s (new)\", patch.new_name);\n\t\t\telse if (patch.is_delete > 0)\n\t\t\t\tstrbuf_addf(&buf, \"%s (deleted)\", patch.old_name);\n\t\t\telse if (patch.is_rename)\n\t\t\t\tstrbuf_addf(&buf, \"%s => %s\", patch.old_name, patch.new_name);\n\t\t\telse\n\t\t\t\tstrbuf_addstr(&buf, patch.new_name);\n\n\t\t\tfree(current_filename);\n\t\t\tif (patch.is_delete > 0)\n\t\t\t\tcurrent_filename = xstrdup(patch.old_name);\n\t\t\telse\n\t\t\t\tcurrent_filename = xstrdup(patch.new_name);\n\n\t\t\tif (patch.new_mode && patch.old_mode &&\n\t\t\t    patch.old_mode != patch.new_mode)\n\t\t\t\tstrbuf_addf(&buf, \" (mode change %06o => %06o)\",\n\t\t\t\t\t    patch.old_mode, patch.new_mode);\n\n\t\t\tstrbuf_addstr(&buf, \" ##\");\n\t\t} else if (in_header) {\n\t\t\tif (starts_with(line, \"Author: \")) {\n\t\t\t\tstrbuf_addstr(&buf, line);\n\t\t\t\tstrbuf_addstr(&buf, \"\\n\\n\");\n\t\t\t} else if (starts_with(line, \"    \")) {\n\t\t\t\tp = line + len - 2;\n\t\t\t\twhile (isspace(*p) && p >= line)\n\t\t\t\t\tp--;\n\t\t\t\tstrbuf_add(&buf, line, p - line + 1);\n\t\t\t\tstrbuf_addch(&buf, '\\n');\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else if (skip_prefix(line, \"@@ \", &p)) {\n\t\t\tp = strstr(p, \"@@\");\n\t\t\tstrbuf_addstr(&buf, \"@@\");\n\t\t\tif (current_filename && p[2])\n\t\t\t\tstrbuf_addf(&buf, \" %s:\", current_filename);\n\t\t\tif (p)\n\t\t\t\tstrbuf_addstr(&buf, p + 2);\n\t\t} else if (!line[0])\n\t\t\t/*\n\t\t\t * A completely blank (not ' \\n', which is context)\n\t\t\t * line is not valid in a diff.  We skip it\n\t\t\t * silently, because this neatly handles the blank\n\t\t\t * separator line between commits in git-log\n\t\t\t * output.\n\t\t\t */\n\t\t\tcontinue;\n\t\telse if (line[0] == '>') {\n\t\t\tstrbuf_addch(&buf, '+');\n\t\t\tstrbuf_addstr(&buf, line + 1);\n\t\t} else if (line[0] == '<') {\n\t\t\tstrbuf_addch(&buf, '-');\n\t\t\tstrbuf_addstr(&buf, line + 1);\n\t\t} else if (line[0] == '#') {\n\t\t\tstrbuf_addch(&buf, ' ');\n\t\t\tstrbuf_addstr(&buf, line + 1);\n\t\t} else {\n\t\t\tstrbuf_addch(&buf, ' ');\n\t\t\tstrbuf_addstr(&buf, line);\n\t\t}\n\n\t\tstrbuf_addch(&buf, '\\n');\n\t\tutil->diffsize++;\n\t}\n\tstrbuf_release(&contents);\n\n\tif (util)\n\t\tstring_list_append(list, buf.buf)->util = util;\n\tstrbuf_release(&buf);\n\tfree(current_filename);\n\n\tif (finish_command(&cp))\n\t\treturn -1;\n\n\treturn 0;\n}",
  "\n/*\n * Reads the patches into a string list, with the `util` field being populated\n * as struct object_id (will need to be free()d).\n */\nstatic int read_patches(const char *range, struct string_list *list)\n{\n\tstruct child_process cp = CHILD_PROCESS_INIT;\n\tFILE *in;\n\tstruct strbuf buf = STRBUF_INIT, line = STRBUF_INIT;\n\tstruct patch_util *util = NULL;\n\tint in_header = 1;\n\n\targv_array_pushl(&cp.args, \"log\", \"--no-color\", \"-p\", \"--no-merges\",\n\t\t\t\"--reverse\", \"--date-order\", \"--decorate=no\",\n\t\t\t\"--no-abbrev-commit\", range,\n\t\t\tNULL);\n\tcp.out = -1;\n\tcp.no_stdin = 1;\n\tcp.git_cmd = 1;\n\n\tif (start_command(&cp))\n\t\treturn error_errno(_(\"could not start `log`\"));\n\tin = fdopen(cp.out, \"r\");\n\tif (!in) {\n\t\terror_errno(_(\"could not read `log` output\"));\n\t\tfinish_command(&cp);\n\t\treturn -1;\n\t}\n\n\twhile (strbuf_getline(&line, in) != EOF) {\n\t\tconst char *p;\n\n\t\tif (skip_prefix(line.buf, \"commit \", &p)) {\n\t\t\tif (util) {\n\t\t\t\tstring_list_append(list, buf.buf)->util = util;\n\t\t\t\tstrbuf_reset(&buf);\n\t\t\t}\n\t\t\tutil = xcalloc(sizeof(*util), 1);\n\t\t\tif (get_oid(p, &util->oid)) {\n\t\t\t\terror(_(\"could not parse commit '%s'\"), p);\n\t\t\t\tfree(util);\n\t\t\t\tstring_list_clear(list, 1);\n\t\t\t\tstrbuf_release(&buf);\n\t\t\t\tstrbuf_release(&line);\n\t\t\t\tfclose(in);\n\t\t\t\tfinish_command(&cp);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tutil->matching = -1;\n\t\t\tin_header = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (starts_with(line.buf, \"diff --git\")) {\n\t\t\tin_header = 0;\n\t\t\tstrbuf_addch(&buf, '\\n');\n\t\t\tif (!util->diff_offset)\n\t\t\t\tutil->diff_offset = buf.len;\n\t\t\tstrbuf_addbuf(&buf, &line);\n\t\t} else if (in_header) {\n\t\t\tif (starts_with(line.buf, \"Author: \")) {\n\t\t\t\tstrbuf_addbuf(&buf, &line);\n\t\t\t\tstrbuf_addstr(&buf, \"\\n\\n\");\n\t\t\t} else if (starts_with(line.buf, \"    \")) {\n\t\t\t\tstrbuf_addbuf(&buf, &line);\n\t\t\t\tstrbuf_addch(&buf, '\\n');\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else if (starts_with(line.buf, \"@@ \"))\n\t\t\tstrbuf_addstr(&buf, \"@@\");\n\t\telse if (!line.buf[0] || starts_with(line.buf, \"index \"))\n\t\t\t/*\n\t\t\t * A completely blank (not ' \\n', which is context)\n\t\t\t * line is not valid in a diff.  We skip it\n\t\t\t * silently, because this neatly handles the blank\n\t\t\t * separator line between commits in git-log\n\t\t\t * output.\n\t\t\t *\n\t\t\t * We also want to ignore the diff's `index` lines\n\t\t\t * because they contain exact blob hashes in which\n\t\t\t * we are not interested.\n\t\t\t */\n\t\t\tcontinue;\n\t\telse\n\t\t\tstrbuf_addbuf(&buf, &line);\n\n\t\tstrbuf_addch(&buf, '\\n');\n\t\tutil->diffsize++;\n\t}\n\tfclose(in);\n\tstrbuf_release(&line);\n\n\tif (util)\n\t\tstring_list_append(list, buf.buf)->util = util;\n\tstrbuf_release(&buf);\n\n\tif (finish_command(&cp))\n\t\treturn -1;\n\n\treturn 0;\n}\n",
  "/*\n * Reads the patches into a string list, with the `util` field being populated\n * as struct object_id (will need to be free()d).\n */\nstatic int read_patches(const char *range, struct string_list *list)\n{\n\tstruct child_process cp = CHILD_PROCESS_INIT;\n\tFILE *in;\n\tstruct strbuf buf = STRBUF_INIT, line = STRBUF_INIT;\n\tstruct patch_util *util = NULL;\n\tint in_header = 1;\n\n\targv_array_pushl(&cp.args, \"log\", \"--no-color\", \"-p\", \"--no-merges\",\n\t\t\t\"--reverse\", \"--date-order\", \"--decorate=no\",\n\t\t\t\"--no-abbrev-commit\", range,\n\t\t\tNULL);\n\tcp.out = -1;\n\tcp.no_stdin = 1;\n\tcp.git_cmd = 1;\n\n\tif (start_command(&cp))\n\t\treturn error_errno(_(\"could not start `log`\"));\n\tin = fdopen(cp.out, \"r\");\n\tif (!in) {\n\t\terror_errno(_(\"could not read `log` output\"));\n\t\tfinish_command(&cp);\n\t\treturn -1;\n\t}\n\n\twhile (strbuf_getline(&line, in) != EOF) {\n\t\tconst char *p;\n\n\t\tif (skip_prefix(line.buf, \"commit \", &p)) {\n\t\t\tif (util) {\n\t\t\t\tstring_list_append(list, buf.buf)->util = util;\n\t\t\t\tstrbuf_reset(&buf);\n\t\t\t}\n\t\t\tutil = xcalloc(sizeof(*util), 1);\n\t\t\tif (get_oid(p, &util->oid)) {\n\t\t\t\terror(_(\"could not parse commit '%s'\"), p);\n\t\t\t\tfree(util);\n\t\t\t\tstring_list_clear(list, 1);\n\t\t\t\tstrbuf_release(&buf);\n\t\t\t\tstrbuf_release(&line);\n\t\t\t\tfclose(in);\n\t\t\t\tfinish_command(&cp);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tutil->matching = -1;\n\t\t\tin_header = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (starts_with(line.buf, \"diff --git\")) {\n\t\t\tin_header = 0;\n\t\t\tstrbuf_addch(&buf, '\\n');\n\t\t\tif (!util->diff_offset)\n\t\t\t\tutil->diff_offset = buf.len;\n\t\t\tstrbuf_addbuf(&buf, &line);\n\t\t} else if (in_header) {\n\t\t\tif (starts_with(line.buf, \"Author: \")) {\n\t\t\t\tstrbuf_addbuf(&buf, &line);\n\t\t\t\tstrbuf_addstr(&buf, \"\\n\\n\");\n\t\t\t} else if (starts_with(line.buf, \"    \")) {\n\t\t\t\tstrbuf_rtrim(&line);\n\t\t\t\tstrbuf_addbuf(&buf, &line);\n\t\t\t\tstrbuf_addch(&buf, '\\n');\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else if (starts_with(line.buf, \"@@ \"))\n\t\t\tstrbuf_addstr(&buf, \"@@\");\n\t\telse if (!line.buf[0] || starts_with(line.buf, \"index \"))\n\t\t\t/*\n\t\t\t * A completely blank (not ' \\n', which is context)\n\t\t\t * line is not valid in a diff.  We skip it\n\t\t\t * silently, because this neatly handles the blank\n\t\t\t * separator line between commits in git-log\n\t\t\t * output.\n\t\t\t *\n\t\t\t * We also want to ignore the diff's `index` lines\n\t\t\t * because they contain exact blob hashes in which\n\t\t\t * we are not interested.\n\t\t\t */\n\t\t\tcontinue;\n\t\telse\n\t\t\tstrbuf_addbuf(&buf, &line);\n\n\t\tstrbuf_addch(&buf, '\\n');\n\t\tutil->diffsize++;\n\t}\n\tfclose(in);\n\tstrbuf_release(&line);\n\n\tif (util)\n\t\tstring_list_append(list, buf.buf)->util = util;\n\tstrbuf_release(&buf);\n\n\tif (finish_command(&cp))\n\t\treturn -1;\n\n\treturn 0;\n}\n",
  "\n/*\n * Reads the patches into a string list, with the `util` field being populated\n * as struct object_id (will need to be free()d).\n */\nstatic int read_patches(const char *range, struct string_list *list)\n{\n\tstruct child_process cp = CHILD_PROCESS_INIT;\n\tFILE *in;\n\tstruct strbuf buf = STRBUF_INIT, line = STRBUF_INIT;\n\tstruct patch_util *util = NULL;\n\tint in_header = 1;\n\n\targv_array_pushl(&cp.args, \"log\", \"--no-color\", \"-p\", \"--no-merges\",\n\t\t\t\"--reverse\", \"--date-order\", \"--decorate=no\",\n\t\t\t/*\n\t\t\t * Choose indicators that are not used anywhere\n\t\t\t * else in diffs, but still look reasonable\n\t\t\t * (e.g. will not be confusing when debugging)\n\t\t\t */\n\t\t\t\"--output-indicator-new=>\",\n\t\t\t\"--output-indicator-old=<\",\n\t\t\t\"--output-indicator-context=#\",\n\t\t\t\"--no-abbrev-commit\", range,\n\t\t\tNULL);\n\tcp.out = -1;\n\tcp.no_stdin = 1;\n\tcp.git_cmd = 1;\n\n\tif (start_command(&cp))\n\t\treturn error_errno(_(\"could not start `log`\"));\n\tin = fdopen(cp.out, \"r\");\n\tif (!in) {\n\t\terror_errno(_(\"could not read `log` output\"));\n\t\tfinish_command(&cp);\n\t\treturn -1;\n\t}\n\n\twhile (strbuf_getline(&line, in) != EOF) {\n\t\tconst char *p;\n\n\t\tif (skip_prefix(line.buf, \"commit \", &p)) {\n\t\t\tif (util) {\n\t\t\t\tstring_list_append(list, buf.buf)->util = util;\n\t\t\t\tstrbuf_reset(&buf);\n\t\t\t}\n\t\t\tutil = xcalloc(sizeof(*util), 1);\n\t\t\tif (get_oid(p, &util->oid)) {\n\t\t\t\terror(_(\"could not parse commit '%s'\"), p);\n\t\t\t\tfree(util);\n\t\t\t\tstring_list_clear(list, 1);\n\t\t\t\tstrbuf_release(&buf);\n\t\t\t\tstrbuf_release(&line);\n\t\t\t\tfclose(in);\n\t\t\t\tfinish_command(&cp);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tutil->matching = -1;\n\t\t\tin_header = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (starts_with(line.buf, \"diff --git\")) {\n\t\t\tin_header = 0;\n\t\t\tstrbuf_addch(&buf, '\\n');\n\t\t\tif (!util->diff_offset)\n\t\t\t\tutil->diff_offset = buf.len;\n\t\t\tstrbuf_addbuf(&buf, &line);\n\t\t} else if (in_header) {\n\t\t\tif (starts_with(line.buf, \"Author: \")) {\n\t\t\t\tstrbuf_addbuf(&buf, &line);\n\t\t\t\tstrbuf_addstr(&buf, \"\\n\\n\");\n\t\t\t} else if (starts_with(line.buf, \"    \")) {\n\t\t\t\tstrbuf_rtrim(&line);\n\t\t\t\tstrbuf_addbuf(&buf, &line);\n\t\t\t\tstrbuf_addch(&buf, '\\n');\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else if (starts_with(line.buf, \"@@ \"))\n\t\t\tstrbuf_addstr(&buf, \"@@\");\n\t\telse if (!line.buf[0] || starts_with(line.buf, \"index \"))\n\t\t\t/*\n\t\t\t * A completely blank (not ' \\n', which is context)\n\t\t\t * line is not valid in a diff.  We skip it\n\t\t\t * silently, because this neatly handles the blank\n\t\t\t * separator line between commits in git-log\n\t\t\t * output.\n\t\t\t *\n\t\t\t * We also want to ignore the diff's `index` lines\n\t\t\t * because they contain exact blob hashes in which\n\t\t\t * we are not interested.\n\t\t\t */\n\t\t\tcontinue;\n\t\telse if (line.buf[0] == '>') {\n\t\t\tstrbuf_addch(&buf, '+');\n\t\t\tstrbuf_add(&buf, line.buf + 1, line.len - 1);\n\t\t} else if (line.buf[0] == '<') {\n\t\t\tstrbuf_addch(&buf, '-');\n\t\t\tstrbuf_add(&buf, line.buf + 1, line.len - 1);\n\t\t} else if (line.buf[0] == '#') {\n\t\t\tstrbuf_addch(&buf, ' ');\n\t\t\tstrbuf_add(&buf, line.buf + 1, line.len - 1);\n\t\t} else {\n\t\t\tstrbuf_addbuf(&buf, &line);\n\t\t}\n\n\t\tstrbuf_addch(&buf, '\\n');\n\t\tutil->diffsize++;\n\t}\n\tfclose(in);\n\tstrbuf_release(&line);\n\n\tif (util)\n\t\tstring_list_append(list, buf.buf)->util = util;\n\tstrbuf_release(&buf);\n\n\tif (finish_command(&cp))\n\t\treturn -1;\n\n\treturn 0;\n}\n",
  "/*\n * Generic implementation of background process infrastructure.\n */\n#include \"sub-process.h\"\n#include \"sigchain.h\"\n#include \"pkt-line.h\"\n\nint cmd2process_cmp(const void *unused_cmp_data,\n\t\t    const void *entry,\n\t\t    const void *entry_or_key,\n\t\t    const void *unused_keydata)\n{\n\tconst struct subprocess_entry *e1 = entry;\n\tconst struct subprocess_entry *e2 = entry_or_key;\n\n\treturn strcmp(e1->cmd, e2->cmd);\n}\n\nstruct subprocess_entry *subprocess_find_entry(struct hashmap *hashmap, const char *cmd)\n{\n\tstruct subprocess_entry key;\n\n\thashmap_entry_init(&key, strhash(cmd));\n\tkey.cmd = cmd;\n\treturn hashmap_get(hashmap, &key, NULL);\n}\n\nint subprocess_read_status(int fd, struct strbuf *status)\n{\n\tstruct strbuf **pair;\n\tchar *line;\n\tint len;\n\n\tfor (;;) {\n\t\tlen = packet_read_line_gently(fd, NULL, &line);\n\t\tif ((len < 0) || !line)\n\t\t\tbreak;\n\t\tpair = strbuf_split_str(line, '=', 2);\n\t\tif (pair[0] && pair[0]->len && pair[1]) {\n\t\t\t/* the last \"status=<foo>\" line wins */\n\t\t\tif (!strcmp(pair[0]->buf, \"status=\")) {\n\t\t\t\tstrbuf_reset(status);\n\t\t\t\tstrbuf_addbuf(status, pair[1]);\n\t\t\t}\n\t\t}\n\t\tstrbuf_list_free(pair);\n\t}\n\n\treturn (len < 0) ? len : 0;\n}\n\nvoid subprocess_stop(struct hashmap *hashmap, struct subprocess_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tentry->process.clean_on_exit = 0;\n\tkill(entry->process.pid, SIGTERM);\n\tfinish_command(&entry->process);\n\n\thashmap_remove(hashmap, entry, NULL);\n}\n\nstatic void subprocess_exit_handler(struct child_process *process)\n{\n\tsigchain_push(SIGPIPE, SIG_IGN);\n\t/* Closing the pipe signals the subprocess to initiate a shutdown. */\n\tclose(process->in);\n\tclose(process->out);\n\tsigchain_pop(SIGPIPE);\n\t/* Finish command will wait until the shutdown is complete. */\n\tfinish_command(process);\n}\n\nint subprocess_start(struct hashmap *hashmap, struct subprocess_entry *entry, const char *cmd,\n\tsubprocess_start_fn startfn)\n{\n\tint err;\n\tstruct child_process *process;\n\n\tentry->cmd = cmd;\n\tprocess = &entry->process;\n\n\tchild_process_init(process);\n\targv_array_push(&process->args, cmd);\n\tprocess->use_shell = 1;\n\tprocess->in = -1;\n\tprocess->out = -1;\n\tprocess->clean_on_exit = 1;\n\tprocess->clean_on_exit_handler = subprocess_exit_handler;\n\tprocess->trace2_child_class = \"subprocess\";\n\n\terr = start_command(process);\n\tif (err) {\n\t\terror(\"cannot fork to run subprocess '%s'\", cmd);\n\t\treturn err;\n\t}\n\n\thashmap_entry_init(entry, strhash(cmd));\n\n\terr = startfn(entry);\n\tif (err) {\n\t\terror(\"initialization for subprocess '%s' failed\", cmd);\n\t\tsubprocess_stop(hashmap, entry);\n\t\treturn err;\n\t}\n\n\thashmap_add(hashmap, entry);\n\treturn 0;\n}\n\nstatic int handshake_version(struct child_process *process,\n\t\t\t     const char *welcome_prefix, int *versions,\n\t\t\t     int *chosen_version)\n{\n\tint version_scratch;\n\tint i;\n\tchar *line;\n\tconst char *p;\n\n\tif (!chosen_version)\n\t\tchosen_version = &version_scratch;\n\n\tif (packet_write_fmt_gently(process->in, \"%s-client\\n\",\n\t\t\t\t    welcome_prefix))\n\t\treturn error(\"Could not write client identification\");\n\tfor (i = 0; versions[i]; i++) {\n\t\tif (packet_write_fmt_gently(process->in, \"version=%d\\n\",\n\t\t\t\t\t    versions[i]))\n\t\t\treturn error(\"Could not write requested version\");\n\t}\n\tif (packet_flush_gently(process->in))\n\t\treturn error(\"Could not write flush packet\");\n\n\tif (!(line = packet_read_line(process->out, NULL)) ||\n\t    !skip_prefix(line, welcome_prefix, &p) ||\n\t    strcmp(p, \"-server\"))\n\t\treturn error(\"Unexpected line '%s', expected %s-server\",\n\t\t\t     line ? line : \"<flush packet>\", welcome_prefix);\n\tif (!(line = packet_read_line(process->out, NULL)) ||\n\t    !skip_prefix(line, \"version=\", &p) ||\n\t    strtol_i(p, 10, chosen_version))\n\t\treturn error(\"Unexpected line '%s', expected version\",\n\t\t\t     line ? line : \"<flush packet>\");\n\tif ((line = packet_read_line(process->out, NULL)))\n\t\treturn error(\"Unexpected line '%s', expected flush\", line);\n\n\t/* Check to make sure that the version received is supported */\n\tfor (i = 0; versions[i]; i++) {\n\t\tif (versions[i] == *chosen_version)\n\t\t\tbreak;\n\t}\n\tif (!versions[i])\n\t\treturn error(\"Version %d not supported\", *chosen_version);\n\n\treturn 0;\n}\n",
  "/*\n * Generic implementation of background process infrastructure.\n */\n#include \"sub-process.h\"\n#include \"sigchain.h\"\n#include \"pkt-line.h\"\n\nint cmd2process_cmp(const void *unused_cmp_data,\n\t\t    const struct subprocess_entry *e1,\n\t\t    const struct subprocess_entry *e2,\n\t\t    const void *unused_keydata)\n{\n\treturn strcmp(e1->cmd, e2->cmd);\n}\n\nstruct subprocess_entry *subprocess_find_entry(struct hashmap *hashmap, const char *cmd)\n{\n\tstruct subprocess_entry key;\n\n\thashmap_entry_init(&key, strhash(cmd));\n\tkey.cmd = cmd;\n\treturn hashmap_get(hashmap, &key, NULL);\n}\n\nint subprocess_read_status(int fd, struct strbuf *status)\n{\n\tstruct strbuf **pair;\n\tchar *line;\n\tint len;\n\n\tfor (;;) {\n\t\tlen = packet_read_line_gently(fd, NULL, &line);\n\t\tif ((len < 0) || !line)\n\t\t\tbreak;\n\t\tpair = strbuf_split_str(line, '=', 2);\n\t\tif (pair[0] && pair[0]->len && pair[1]) {\n\t\t\t/* the last \"status=<foo>\" line wins */\n\t\t\tif (!strcmp(pair[0]->buf, \"status=\")) {\n\t\t\t\tstrbuf_reset(status);\n\t\t\t\tstrbuf_addbuf(status, pair[1]);\n\t\t\t}\n\t\t}\n\t\tstrbuf_list_free(pair);\n\t}\n\n\treturn (len < 0) ? len : 0;\n}\n\nvoid subprocess_stop(struct hashmap *hashmap, struct subprocess_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tentry->process.clean_on_exit = 0;\n\tkill(entry->process.pid, SIGTERM);\n\tfinish_command(&entry->process);\n\n\thashmap_remove(hashmap, entry, NULL);\n}\n\nstatic void subprocess_exit_handler(struct child_process *process)\n{\n\tsigchain_push(SIGPIPE, SIG_IGN);\n\t/* Closing the pipe signals the subprocess to initiate a shutdown. */\n\tclose(process->in);\n\tclose(process->out);\n\tsigchain_pop(SIGPIPE);\n\t/* Finish command will wait until the shutdown is complete. */\n\tfinish_command(process);\n}\n\nint subprocess_start(struct hashmap *hashmap, struct subprocess_entry *entry, const char *cmd,\n\tsubprocess_start_fn startfn)\n{\n\tint err;\n\tstruct child_process *process;\n\n\tentry->cmd = cmd;\n\tprocess = &entry->process;\n\n\tchild_process_init(process);\n\targv_array_push(&process->args, cmd);\n\tprocess->use_shell = 1;\n\tprocess->in = -1;\n\tprocess->out = -1;\n\tprocess->clean_on_exit = 1;\n\tprocess->clean_on_exit_handler = subprocess_exit_handler;\n\n\terr = start_command(process);\n\tif (err) {\n\t\terror(\"cannot fork to run subprocess '%s'\", cmd);\n\t\treturn err;\n\t}\n\n\thashmap_entry_init(entry, strhash(cmd));\n\n\terr = startfn(entry);\n\tif (err) {\n\t\terror(\"initialization for subprocess '%s' failed\", cmd);\n\t\tsubprocess_stop(hashmap, entry);\n\t\treturn err;\n\t}\n\n\thashmap_add(hashmap, entry);\n\treturn 0;\n}\n\nstatic int handshake_version(struct child_process *process,\n\t\t\t     const char *welcome_prefix, int *versions,\n\t\t\t     int *chosen_version)\n{\n\tint version_scratch;\n\tint i;\n\tchar *line;\n\tconst char *p;\n\n\tif (!chosen_version)\n\t\tchosen_version = &version_scratch;\n\n\tif (packet_write_fmt_gently(process->in, \"%s-client\\n\",\n\t\t\t\t    welcome_prefix))\n\t\treturn error(\"Could not write client identification\");\n\tfor (i = 0; versions[i]; i++) {\n\t\tif (packet_write_fmt_gently(process->in, \"version=%d\\n\",\n\t\t\t\t\t    versions[i]))\n\t\t\treturn error(\"Could not write requested version\");\n\t}\n\tif (packet_flush_gently(process->in))\n\t\treturn error(\"Could not write flush packet\");\n\n\tif (!(line = packet_read_line(process->out, NULL)) ||\n\t    !skip_prefix(line, welcome_prefix, &p) ||\n\t    strcmp(p, \"-server\"))\n\t\treturn error(\"Unexpected line '%s', expected %s-server\",\n\t\t\t     line ? line : \"<flush packet>\", welcome_prefix);\n\tif (!(line = packet_read_line(process->out, NULL)) ||\n\t    !skip_prefix(line, \"version=\", &p) ||\n\t    strtol_i(p, 10, chosen_version))\n\t\treturn error(\"Unexpected line '%s', expected version\",\n\t\t\t     line ? line : \"<flush packet>\");\n\tif ((line = packet_read_line(process->out, NULL)))\n\t\treturn error(\"Unexpected line '%s', expected flush\", line);\n\n\t/* Check to make sure that the version received is supported */\n\tfor (i = 0; versions[i]; i++) {\n\t\tif (versions[i] == *chosen_version)\n\t\t\tbreak;\n\t}\n\tif (!versions[i])\n\t\treturn error(\"Version %d not supported\", *chosen_version);\n\n\treturn 0;\n}",
  "/*\n * Generic implementation of background process infrastructure.\n */\n#include \"sub-process.h\"\n#include \"sigchain.h\"\n#include \"pkt-line.h\"\n\nint cmd2process_cmp(const void *unused_cmp_data,\n\t\t    const struct subprocess_entry *e1,\n\t\t    const struct subprocess_entry *e2,\n\t\t    const void *unused_keydata)\n{\n\treturn strcmp(e1->cmd, e2->cmd);\n}\n\nstruct subprocess_entry *subprocess_find_entry(struct hashmap *hashmap, const char *cmd)\n{\n\tstruct subprocess_entry key;\n\n\thashmap_entry_init(&key, strhash(cmd));\n\tkey.cmd = cmd;\n\treturn hashmap_get(hashmap, &key, NULL);\n}\n\nint subprocess_read_status(int fd, struct strbuf *status)\n{\n\tstruct strbuf **pair;\n\tchar *line;\n\tint len;\n\n\tfor (;;) {\n\t\tlen = packet_read_line_gently(fd, NULL, &line);\n\t\tif ((len < 0) || !line)\n\t\t\tbreak;\n\t\tpair = strbuf_split_str(line, '=', 2);\n\t\tif (pair[0] && pair[0]->len && pair[1]) {\n\t\t\t/* the last \"status=<foo>\" line wins */\n\t\t\tif (!strcmp(pair[0]->buf, \"status=\")) {\n\t\t\t\tstrbuf_reset(status);\n\t\t\t\tstrbuf_addbuf(status, pair[1]);\n\t\t\t}\n\t\t}\n\t\tstrbuf_list_free(pair);\n\t}\n\n\treturn (len < 0) ? len : 0;\n}\n\nvoid subprocess_stop(struct hashmap *hashmap, struct subprocess_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tentry->process.clean_on_exit = 0;\n\tkill(entry->process.pid, SIGTERM);\n\tfinish_command(&entry->process);\n\n\thashmap_remove(hashmap, entry, NULL);\n}\n\nstatic void subprocess_exit_handler(struct child_process *process)\n{\n\tsigchain_push(SIGPIPE, SIG_IGN);\n\t/* Closing the pipe signals the subprocess to initiate a shutdown. */\n\tclose(process->in);\n\tclose(process->out);\n\tsigchain_pop(SIGPIPE);\n\t/* Finish command will wait until the shutdown is complete. */\n\tfinish_command(process);\n}\n\nint subprocess_start(struct hashmap *hashmap, struct subprocess_entry *entry, const char *cmd,\n\tsubprocess_start_fn startfn)\n{\n\tint err;\n\tstruct child_process *process;\n\tconst char *argv[] = { cmd, NULL };\n\n\tentry->cmd = cmd;\n\tprocess = &entry->process;\n\n\tchild_process_init(process);\n\tprocess->argv = argv;\n\tprocess->use_shell = 1;\n\tprocess->in = -1;\n\tprocess->out = -1;\n\tprocess->clean_on_exit = 1;\n\tprocess->clean_on_exit_handler = subprocess_exit_handler;\n\n\terr = start_command(process);\n\tif (err) {\n\t\terror(\"cannot fork to run subprocess '%s'\", cmd);\n\t\treturn err;\n\t}\n\n\thashmap_entry_init(entry, strhash(cmd));\n\n\terr = startfn(entry);\n\tif (err) {\n\t\terror(\"initialization for subprocess '%s' failed\", cmd);\n\t\tsubprocess_stop(hashmap, entry);\n\t\treturn err;\n\t}\n\n\thashmap_add(hashmap, entry);\n\treturn 0;\n}\n\nstatic int handshake_version(struct child_process *process,\n\t\t\t     const char *welcome_prefix, int *versions,\n\t\t\t     int *chosen_version)\n{\n\tint version_scratch;\n\tint i;\n\tchar *line;\n\tconst char *p;\n\n\tif (!chosen_version)\n\t\tchosen_version = &version_scratch;\n\n\tif (packet_write_fmt_gently(process->in, \"%s-client\\n\",\n\t\t\t\t    welcome_prefix))\n\t\treturn error(\"Could not write client identification\");\n\tfor (i = 0; versions[i]; i++) {\n\t\tif (packet_write_fmt_gently(process->in, \"version=%d\\n\",\n\t\t\t\t\t    versions[i]))\n\t\t\treturn error(\"Could not write requested version\");\n\t}\n\tif (packet_flush_gently(process->in))\n\t\treturn error(\"Could not write flush packet\");\n\n\tif (!(line = packet_read_line(process->out, NULL)) ||\n\t    !skip_prefix(line, welcome_prefix, &p) ||\n\t    strcmp(p, \"-server\"))\n\t\treturn error(\"Unexpected line '%s', expected %s-server\",\n\t\t\t     line ? line : \"<flush packet>\", welcome_prefix);\n\tif (!(line = packet_read_line(process->out, NULL)) ||\n\t    !skip_prefix(line, \"version=\", &p) ||\n\t    strtol_i(p, 10, chosen_version))\n\t\treturn error(\"Unexpected line '%s', expected version\",\n\t\t\t     line ? line : \"<flush packet>\");\n\tif ((line = packet_read_line(process->out, NULL)))\n\t\treturn error(\"Unexpected line '%s', expected flush\", line);\n\n\t/* Check to make sure that the version received is supported */\n\tfor (i = 0; versions[i]; i++) {\n\t\tif (versions[i] == *chosen_version)\n\t\t\tbreak;\n\t}\n\tif (!versions[i])\n\t\treturn error(\"Version %d not supported\", *chosen_version);\n\n\treturn 0;\n}\n",
  "/*\n * Generic implementation of background process infrastructure.\n */\n#include \"sub-process.h\"\n#include \"sigchain.h\"\n#include \"pkt-line.h\"\n\nint cmd2process_cmp(const void *unused_cmp_data,\n\t\t    const void *entry,\n\t\t    const void *entry_or_key,\n\t\t    const void *unused_keydata)\n{\n\tconst struct subprocess_entry *e1 = entry;\n\tconst struct subprocess_entry *e2 = entry_or_key;\n\n\treturn strcmp(e1->cmd, e2->cmd);\n}\n\nstruct subprocess_entry *subprocess_find_entry(struct hashmap *hashmap, const char *cmd)\n{\n\tstruct subprocess_entry key;\n\n\thashmap_entry_init(&key, strhash(cmd));\n\tkey.cmd = cmd;\n\treturn hashmap_get(hashmap, &key, NULL);\n}\n\nint subprocess_read_status(int fd, struct strbuf *status)\n{\n\tstruct strbuf **pair;\n\tchar *line;\n\tint len;\n\n\tfor (;;) {\n\t\tlen = packet_read_line_gently(fd, NULL, &line);\n\t\tif ((len < 0) || !line)\n\t\t\tbreak;\n\t\tpair = strbuf_split_str(line, '=', 2);\n\t\tif (pair[0] && pair[0]->len && pair[1]) {\n\t\t\t/* the last \"status=<foo>\" line wins */\n\t\t\tif (!strcmp(pair[0]->buf, \"status=\")) {\n\t\t\t\tstrbuf_reset(status);\n\t\t\t\tstrbuf_addbuf(status, pair[1]);\n\t\t\t}\n\t\t}\n\t\tstrbuf_list_free(pair);\n\t}\n\n\treturn (len < 0) ? len : 0;\n}\n\nvoid subprocess_stop(struct hashmap *hashmap, struct subprocess_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tentry->process.clean_on_exit = 0;\n\tkill(entry->process.pid, SIGTERM);\n\tfinish_command(&entry->process);\n\n\thashmap_remove(hashmap, entry, NULL);\n}\n\nstatic void subprocess_exit_handler(struct child_process *process)\n{\n\tsigchain_push(SIGPIPE, SIG_IGN);\n\t/* Closing the pipe signals the subprocess to initiate a shutdown. */\n\tclose(process->in);\n\tclose(process->out);\n\tsigchain_pop(SIGPIPE);\n\t/* Finish command will wait until the shutdown is complete. */\n\tfinish_command(process);\n}\n\nint subprocess_start(struct hashmap *hashmap, struct subprocess_entry *entry, const char *cmd,\n\tsubprocess_start_fn startfn)\n{\n\tint err;\n\tstruct child_process *process;\n\tconst char *argv[] = { cmd, NULL };\n\n\tentry->cmd = cmd;\n\tprocess = &entry->process;\n\n\tchild_process_init(process);\n\tprocess->argv = argv;\n\tprocess->use_shell = 1;\n\tprocess->in = -1;\n\tprocess->out = -1;\n\tprocess->clean_on_exit = 1;\n\tprocess->clean_on_exit_handler = subprocess_exit_handler;\n\n\terr = start_command(process);\n\tif (err) {\n\t\terror(\"cannot fork to run subprocess '%s'\", cmd);\n\t\treturn err;\n\t}\n\n\thashmap_entry_init(entry, strhash(cmd));\n\n\terr = startfn(entry);\n\tif (err) {\n\t\terror(\"initialization for subprocess '%s' failed\", cmd);\n\t\tsubprocess_stop(hashmap, entry);\n\t\treturn err;\n\t}\n\n\thashmap_add(hashmap, entry);\n\treturn 0;\n}",
  "/*\n * Generic implementation of background process infrastructure.\n */\n#include \"sub-process.h\"\n#include \"sigchain.h\"\n#include \"pkt-line.h\"\n\nint cmd2process_cmp(const struct subprocess_entry *e1,\n\t\t\t   const struct subprocess_entry *e2,\n\t\t\t   const void *unused)\n{\n\treturn strcmp(e1->cmd, e2->cmd);\n}\n\nstruct subprocess_entry *subprocess_find_entry(struct hashmap *hashmap, const char *cmd)\n{\n\tstruct subprocess_entry key;\n\n\thashmap_entry_init(&key, strhash(cmd));\n\tkey.cmd = cmd;\n\treturn hashmap_get(hashmap, &key, NULL);\n}\n\nvoid subprocess_read_status(int fd, struct strbuf *status)\n{\n\tstruct strbuf **pair;\n\tchar *line;\n\tfor (;;) {\n\t\tline = packet_read_line(fd, NULL);\n\t\tif (!line)\n\t\t\tbreak;\n\t\tpair = strbuf_split_str(line, '=', 2);\n\t\tif (pair[0] && pair[0]->len && pair[1]) {\n\t\t\t/* the last \"status=<foo>\" line wins */\n\t\t\tif (!strcmp(pair[0]->buf, \"status=\")) {\n\t\t\t\tstrbuf_reset(status);\n\t\t\t\tstrbuf_addbuf(status, pair[1]);\n\t\t\t}\n\t\t}\n\t\tstrbuf_list_free(pair);\n\t}\n}\n\nvoid subprocess_stop(struct hashmap *hashmap, struct subprocess_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tentry->process.clean_on_exit = 0;\n\tkill(entry->process.pid, SIGTERM);\n\tfinish_command(&entry->process);\n\n\thashmap_remove(hashmap, entry, NULL);\n}\n\nstatic void subprocess_exit_handler(struct child_process *process)\n{\n\tsigchain_push(SIGPIPE, SIG_IGN);\n\t/* Closing the pipe signals the subprocess to initiate a shutdown. */\n\tclose(process->in);\n\tclose(process->out);\n\tsigchain_pop(SIGPIPE);\n\t/* Finish command will wait until the shutdown is complete. */\n\tfinish_command(process);\n}\n\nint subprocess_start(struct hashmap *hashmap, struct subprocess_entry *entry, const char *cmd,\n\tsubprocess_start_fn startfn)\n{\n\tint err;\n\tstruct child_process *process;\n\tconst char *argv[] = { cmd, NULL };\n\n\tentry->cmd = cmd;\n\tprocess = &entry->process;\n\n\tchild_process_init(process);\n\tprocess->argv = argv;\n\tprocess->use_shell = 1;\n\tprocess->in = -1;\n\tprocess->out = -1;\n\tprocess->clean_on_exit = 1;\n\tprocess->clean_on_exit_handler = subprocess_exit_handler;\n\n\terr = start_command(process);\n\tif (err) {\n\t\terror(\"cannot fork to run subprocess '%s'\", cmd);\n\t\treturn err;\n\t}\n\n\thashmap_entry_init(entry, strhash(cmd));\n\n\terr = startfn(entry);\n\tif (err) {\n\t\terror(\"initialization for subprocess '%s' failed\", cmd);\n\t\tsubprocess_stop(hashmap, entry);\n\t\treturn err;\n\t}\n\n\thashmap_add(hashmap, entry);\n\treturn 0;\n}",
  "#include \"cache.h\"\n#include \"url.h\"\n\nint is_urlschemechar(int first_flag, int ch)\n{\n\t/*\n\t * The set of valid URL schemes, as per STD66 (RFC3986) is\n\t * '[A-Za-z][A-Za-z0-9+.-]*'. But use sightly looser check\n\t * of '[A-Za-z0-9][A-Za-z0-9+.-]*' because earlier version\n\t * of check used '[A-Za-z0-9]+' so not to break any remote\n\t * helpers.\n\t */\n\tint alphanumeric, special;\n\talphanumeric = ch > 0 && isalnum(ch);\n\tspecial = ch == '+' || ch == '-' || ch == '.';\n\treturn alphanumeric || (!first_flag && special);\n}\n\nint is_url(const char *url)\n{\n\t/* Is \"scheme\" part reasonable? */\n\tif (!url || !is_urlschemechar(1, *url++))\n\t\treturn 0;\n\twhile (*url && *url != ':') {\n\t\tif (!is_urlschemechar(0, *url++))\n\t\t\treturn 0;\n\t}\n\t/* We've seen \"scheme\"; we want colon-slash-slash */\n\treturn (url[0] == ':' && url[1] == '/' && url[2] == '/');\n}\n\nstatic char *url_decode_internal(const char **query, int len,\n\t\t\t\t const char *stop_at, struct strbuf *out,\n\t\t\t\t int decode_plus)\n{\n\tconst char *q = *query;\n\n\twhile (len) {\n\t\tunsigned char c = *q;\n\n\t\tif (!c)\n\t\t\tbreak;\n\t\tif (stop_at && strchr(stop_at, c)) {\n\t\t\tq++;\n\t\t\tlen--;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (c == '%' && (len < 0 || len >= 3)) {\n\t\t\tint val = hex2chr(q + 1);\n\t\t\tif (0 < val) {\n\t\t\t\tstrbuf_addch(out, val);\n\t\t\t\tq += 3;\n\t\t\t\tlen -= 3;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (decode_plus && c == '+')\n\t\t\tstrbuf_addch(out, ' ');\n\t\telse\n\t\t\tstrbuf_addch(out, c);\n\t\tq++;\n\t\tlen--;\n\t}\n\t*query = q;\n\treturn strbuf_detach(out, NULL);\n}\n\nchar *url_decode(const char *url)\n{\n\treturn url_decode_mem(url, strlen(url));\n}\n\nchar *url_decode_mem(const char *url, int len)\n{\n\tstruct strbuf out = STRBUF_INIT;\n\tconst char *colon = memchr(url, ':', len);\n\n\t/* Skip protocol part if present */\n\tif (colon && url < colon) {\n\t\tstrbuf_add(&out, url, colon - url);\n\t\tlen -= colon - url;\n\t\turl = colon;\n\t}\n\treturn url_decode_internal(&url, len, NULL, &out, 0);\n}\n\nchar *url_decode_parameter_name(const char **query)\n{\n\tstruct strbuf out = STRBUF_INIT;\n\treturn url_decode_internal(query, -1, \"&=\", &out, 1);\n}\n\nchar *url_decode_parameter_value(const char **query)\n{\n\tstruct strbuf out = STRBUF_INIT;\n\treturn url_decode_internal(query, -1, \"&\", &out, 1);\n}\n\nvoid end_url_with_slash(struct strbuf *buf, const char *url)\n{\n\tstrbuf_addstr(buf, url);\n\tstrbuf_complete(buf, '/');\n}\n\nvoid str_end_url_with_slash(const char *url, char **dest)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tend_url_with_slash(&buf, url);\n\tfree(*dest);\n\t*dest = strbuf_detach(&buf, NULL);\n}",
  "#include \"cache.h\"\n#include \"url.h\"\n\nint is_urlschemechar(int first_flag, int ch)\n{\n\t/*\n\t * The set of valid URL schemes, as per STD66 (RFC3986) is\n\t * '[A-Za-z][A-Za-z0-9+.-]*'. But use sightly looser check\n\t * of '[A-Za-z0-9][A-Za-z0-9+.-]*' because earlier version\n\t * of check used '[A-Za-z0-9]+' so not to break any remote\n\t * helpers.\n\t */\n\tint alphanumeric, special;\n\talphanumeric = ch > 0 && isalnum(ch);\n\tspecial = ch == '+' || ch == '-' || ch == '.';\n\treturn alphanumeric || (!first_flag && special);\n}\n\nint is_url(const char *url)\n{\n\t/* Is \"scheme\" part reasonable? */\n\tif (!url || !is_urlschemechar(1, *url++))\n\t\treturn 0;\n\twhile (*url && *url != ':') {\n\t\tif (!is_urlschemechar(0, *url++))\n\t\t\treturn 0;\n\t}\n\t/* We've seen \"scheme\"; we want colon-slash-slash */\n\treturn (url[0] == ':' && url[1] == '/' && url[2] == '/');\n}\n\nstatic char *url_decode_internal(const char **query, int len,\n\t\t\t\t const char *stop_at, struct strbuf *out,\n\t\t\t\t int decode_plus)\n{\n\tconst char *q = *query;\n\n\twhile (len) {\n\t\tunsigned char c = *q;\n\n\t\tif (!c)\n\t\t\tbreak;\n\t\tif (stop_at && strchr(stop_at, c)) {\n\t\t\tq++;\n\t\t\tlen--;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (c == '%' && (len < 0 || len >= 3)) {\n\t\t\tint val = hex2chr(q + 1);\n\t\t\tif (0 < val) {\n\t\t\t\tstrbuf_addch(out, val);\n\t\t\t\tq += 3;\n\t\t\t\tlen -= 3;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (decode_plus && c == '+')\n\t\t\tstrbuf_addch(out, ' ');\n\t\telse\n\t\t\tstrbuf_addch(out, c);\n\t\tq++;\n\t\tlen--;\n\t}\n\t*query = q;\n\treturn strbuf_detach(out, NULL);\n}\n\nchar *url_decode(const char *url)\n{\n\treturn url_decode_mem(url, strlen(url));\n}\n\nchar *url_decode_mem(const char *url, int len)\n{\n\tstruct strbuf out = STRBUF_INIT;\n\tconst char *colon = memchr(url, ':', len);\n\n\t/* Skip protocol part if present */\n\tif (colon && url < colon) {\n\t\tstrbuf_add(&out, url, colon - url);\n\t\tlen -= colon - url;\n\t\turl = colon;\n\t}\n\treturn url_decode_internal(&url, len, NULL, &out, 0);\n}\n\nchar *url_decode_parameter_name(const char **query)\n{\n\tstruct strbuf out = STRBUF_INIT;\n\treturn url_decode_internal(query, -1, \"&=\", &out, 1);\n}\n\nchar *url_decode_parameter_value(const char **query)\n{\n\tstruct strbuf out = STRBUF_INIT;\n\treturn url_decode_internal(query, -1, \"&\", &out, 1);\n}\n\nvoid end_url_with_slash(struct strbuf *buf, const char *url)\n{\n\tstrbuf_addstr(buf, url);\n\tstrbuf_complete(buf, '/');\n}\n\nvoid str_end_url_with_slash(const char *url, char **dest)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tend_url_with_slash(&buf, url);\n\tfree(*dest);\n\t*dest = strbuf_detach(&buf, NULL);\n}",
  "#include \"cache.h\"\n\nint is_urlschemechar(int first_flag, int ch)\n{\n\t/*\n\t * The set of valid URL schemes, as per STD66 (RFC3986) is\n\t * '[A-Za-z][A-Za-z0-9+.-]*'. But use sightly looser check\n\t * of '[A-Za-z0-9][A-Za-z0-9+.-]*' because earlier version\n\t * of check used '[A-Za-z0-9]+' so not to break any remote\n\t * helpers.\n\t */\n\tint alphanumeric, special;\n\talphanumeric = ch > 0 && isalnum(ch);\n\tspecial = ch == '+' || ch == '-' || ch == '.';\n\treturn alphanumeric || (!first_flag && special);\n}\n\nint is_url(const char *url)\n{\n\t/* Is \"scheme\" part reasonable? */\n\tif (!url || !is_urlschemechar(1, *url++))\n\t\treturn 0;\n\twhile (*url && *url != ':') {\n\t\tif (!is_urlschemechar(0, *url++))\n\t\t\treturn 0;\n\t}\n\t/* We've seen \"scheme\"; we want colon-slash-slash */\n\treturn (url[0] == ':' && url[1] == '/' && url[2] == '/');\n}\n\nstatic int url_decode_char(const char *q)\n{\n\tint i;\n\tunsigned char val = 0;\n\tfor (i = 0; i < 2; i++) {\n\t\tunsigned char c = *q++;\n\t\tval <<= 4;\n\t\tif (c >= '0' && c <= '9')\n\t\t\tval += c - '0';\n\t\telse if (c >= 'a' && c <= 'f')\n\t\t\tval += c - 'a' + 10;\n\t\telse if (c >= 'A' && c <= 'F')\n\t\t\tval += c - 'A' + 10;\n\t\telse\n\t\t\treturn -1;\n\t}\n\treturn val;\n}\n\nstatic char *url_decode_internal(const char **query, const char *stop_at,\n\t\t\t\t struct strbuf *out, int decode_plus)\n{\n\tconst char *q = *query;\n\n\tdo {\n\t\tunsigned char c = *q;\n\n\t\tif (!c)\n\t\t\tbreak;\n\t\tif (stop_at && strchr(stop_at, c)) {\n\t\t\tq++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (c == '%') {\n\t\t\tint val = url_decode_char(q + 1);\n\t\t\tif (0 <= val) {\n\t\t\t\tstrbuf_addch(out, val);\n\t\t\t\tq += 3;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (decode_plus && c == '+')\n\t\t\tstrbuf_addch(out, ' ');\n\t\telse\n\t\t\tstrbuf_addch(out, c);\n\t\tq++;\n\t} while (1);\n\t*query = q;\n\treturn strbuf_detach(out, NULL);\n}\n\nchar *url_decode(const char *url)\n{\n\tstruct strbuf out = STRBUF_INIT;\n\tconst char *colon = strchr(url, ':');\n\n\t/* Skip protocol part if present */\n\tif (colon && url < colon) {\n\t\tstrbuf_add(&out, url, colon - url);\n\t\turl = colon;\n\t}\n\treturn url_decode_internal(&url, NULL, &out, 0);\n}\n\nchar *url_decode_parameter_name(const char **query)\n{\n\tstruct strbuf out = STRBUF_INIT;\n\treturn url_decode_internal(query, \"&=\", &out, 1);\n}\n\nchar *url_decode_parameter_value(const char **query)\n{\n\tstruct strbuf out = STRBUF_INIT;\n\treturn url_decode_internal(query, \"&\", &out, 1);\n}\n\nvoid end_url_with_slash(struct strbuf *buf, const char *url)\n{\n\tstrbuf_addstr(buf, url);\n\tif (buf->len && buf->buf[buf->len - 1] != '/')\n\t\tstrbuf_addstr(buf, \"/\");\n}\n\nvoid str_end_url_with_slash(const char *url, char **dest) {\n\tstruct strbuf buf = STRBUF_INIT;\n\tend_url_with_slash(&buf, url);\n\tfree(*dest);\n\t*dest = strbuf_detach(&buf, NULL);\n}",
  "#include \"cache.h\"\n\nint is_urlschemechar(int first_flag, int ch)\n{\n\t/*\n\t * The set of valid URL schemes, as per STD66 (RFC3986) is\n\t * '[A-Za-z][A-Za-z0-9+.-]*'. But use sightly looser check\n\t * of '[A-Za-z0-9][A-Za-z0-9+.-]*' because earlier version\n\t * of check used '[A-Za-z0-9]+' so not to break any remote\n\t * helpers.\n\t */\n\tint alphanumeric, special;\n\talphanumeric = ch > 0 && isalnum(ch);\n\tspecial = ch == '+' || ch == '-' || ch == '.';\n\treturn alphanumeric || (!first_flag && special);\n}\n\nint is_url(const char *url)\n{\n\tconst char *url2, *first_slash;\n\n\tif (!url)\n\t\treturn 0;\n\turl2 = url;\n\tfirst_slash = strchr(url, '/');\n\n\t/* Input with no slash at all or slash first can't be URL. */\n\tif (!first_slash || first_slash == url)\n\t\treturn 0;\n\t/* Character before must be : and next must be /. */\n\tif (first_slash[-1] != ':' || first_slash[1] != '/')\n\t\treturn 0;\n\t/* There must be something before the :// */\n\tif (first_slash == url + 1)\n\t\treturn 0;\n\t/*\n\t * Check all characters up to first slash - 1. Only alphanum\n\t * is allowed.\n\t */\n\turl2 = url;\n\twhile (url2 < first_slash - 1) {\n\t\tif (!is_urlschemechar(url2 == url, (unsigned char)*url2))\n\t\t\treturn 0;\n\t\turl2++;\n\t}\n\n\t/* Valid enough. */\n\treturn 1;\n}\n\nstatic int url_decode_char(const char *q)\n{\n\tint i;\n\tunsigned char val = 0;\n\tfor (i = 0; i < 2; i++) {\n\t\tunsigned char c = *q++;\n\t\tval <<= 4;\n\t\tif (c >= '0' && c <= '9')\n\t\t\tval += c - '0';\n\t\telse if (c >= 'a' && c <= 'f')\n\t\t\tval += c - 'a' + 10;\n\t\telse if (c >= 'A' && c <= 'F')\n\t\t\tval += c - 'A' + 10;\n\t\telse\n\t\t\treturn -1;\n\t}\n\treturn val;\n}\n\nstatic char *url_decode_internal(const char **query, const char *stop_at,\n\t\t\t\t struct strbuf *out, int decode_plus)\n{\n\tconst char *q = *query;\n\n\tdo {\n\t\tunsigned char c = *q;\n\n\t\tif (!c)\n\t\t\tbreak;\n\t\tif (stop_at && strchr(stop_at, c)) {\n\t\t\tq++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (c == '%') {\n\t\t\tint val = url_decode_char(q + 1);\n\t\t\tif (0 <= val) {\n\t\t\t\tstrbuf_addch(out, val);\n\t\t\t\tq += 3;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (decode_plus && c == '+')\n\t\t\tstrbuf_addch(out, ' ');\n\t\telse\n\t\t\tstrbuf_addch(out, c);\n\t\tq++;\n\t} while (1);\n\t*query = q;\n\treturn strbuf_detach(out, NULL);\n}\n\nchar *url_decode(const char *url)\n{\n\tstruct strbuf out = STRBUF_INIT;\n\tconst char *colon = strchr(url, ':');\n\n\t/* Skip protocol part if present */\n\tif (colon && url < colon) {\n\t\tstrbuf_add(&out, url, colon - url);\n\t\turl = colon;\n\t}\n\treturn url_decode_internal(&url, NULL, &out, 0);\n}\n\nchar *url_decode_parameter_name(const char **query)\n{\n\tstruct strbuf out = STRBUF_INIT;\n\treturn url_decode_internal(query, \"&=\", &out, 1);\n}\n\nchar *url_decode_parameter_value(const char **query)\n{\n\tstruct strbuf out = STRBUF_INIT;\n\treturn url_decode_internal(query, \"&\", &out, 1);\n}\n\nvoid end_url_with_slash(struct strbuf *buf, const char *url)\n{\n\tstrbuf_addstr(buf, url);\n\tif (buf->len && buf->buf[buf->len - 1] != '/')\n\t\tstrbuf_addstr(buf, \"/\");\n}\n\nvoid str_end_url_with_slash(const char *url, char **dest) {\n\tstruct strbuf buf = STRBUF_INIT;\n\tend_url_with_slash(&buf, url);\n\tfree(*dest);\n\t*dest = strbuf_detach(&buf, NULL);\n}",
  "#include \"cache.h\"\n\nint is_urlschemechar(int first_flag, int ch)\n{\n\t/*\n\t * The set of valid URL schemes, as per STD66 (RFC3986) is\n\t * '[A-Za-z][A-Za-z0-9+.-]*'. But use sightly looser check\n\t * of '[A-Za-z0-9][A-Za-z0-9+.-]*' because earlier version\n\t * of check used '[A-Za-z0-9]+' so not to break any remote\n\t * helpers.\n\t */\n\tint alphanumeric, special;\n\talphanumeric = ch > 0 && isalnum(ch);\n\tspecial = ch == '+' || ch == '-' || ch == '.';\n\treturn alphanumeric || (!first_flag && special);\n}\n\nint is_url(const char *url)\n{\n\tconst char *url2, *first_slash;\n\n\tif (!url)\n\t\treturn 0;\n\turl2 = url;\n\tfirst_slash = strchr(url, '/');\n\n\t/* Input with no slash at all or slash first can't be URL. */\n\tif (!first_slash || first_slash == url)\n\t\treturn 0;\n\t/* Character before must be : and next must be /. */\n\tif (first_slash[-1] != ':' || first_slash[1] != '/')\n\t\treturn 0;\n\t/* There must be something before the :// */\n\tif (first_slash == url + 1)\n\t\treturn 0;\n\t/*\n\t * Check all characters up to first slash - 1. Only alphanum\n\t * is allowed.\n\t */\n\turl2 = url;\n\twhile (url2 < first_slash - 1) {\n\t\tif (!is_urlschemechar(url2 == url, (unsigned char)*url2))\n\t\t\treturn 0;\n\t\turl2++;\n\t}\n\n\t/* Valid enough. */\n\treturn 1;\n}\n\nstatic int url_decode_char(const char *q)\n{\n\tint i;\n\tunsigned char val = 0;\n\tfor (i = 0; i < 2; i++) {\n\t\tunsigned char c = *q++;\n\t\tval <<= 4;\n\t\tif (c >= '0' && c <= '9')\n\t\t\tval += c - '0';\n\t\telse if (c >= 'a' && c <= 'f')\n\t\t\tval += c - 'a' + 10;\n\t\telse if (c >= 'A' && c <= 'F')\n\t\t\tval += c - 'A' + 10;\n\t\telse\n\t\t\treturn -1;\n\t}\n\treturn val;\n}\n\nstatic char *url_decode_internal(const char **query, const char *stop_at, struct strbuf *out)\n{\n\tconst char *q = *query;\n\n\tdo {\n\t\tunsigned char c = *q;\n\n\t\tif (!c)\n\t\t\tbreak;\n\t\tif (stop_at && strchr(stop_at, c)) {\n\t\t\tq++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (c == '%') {\n\t\t\tint val = url_decode_char(q + 1);\n\t\t\tif (0 <= val) {\n\t\t\t\tstrbuf_addch(out, val);\n\t\t\t\tq += 3;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (c == '+')\n\t\t\tstrbuf_addch(out, ' ');\n\t\telse\n\t\t\tstrbuf_addch(out, c);\n\t\tq++;\n\t} while (1);\n\t*query = q;\n\treturn strbuf_detach(out, NULL);\n}\n\nchar *url_decode(const char *url)\n{\n\tstruct strbuf out = STRBUF_INIT;\n\tconst char *slash = strchr(url, '/');\n\n\t/* Skip protocol part if present */\n\tif (slash && url < slash) {\n\t\tstrbuf_add(&out, url, slash - url);\n\t\turl = slash;\n\t}\n\treturn url_decode_internal(&url, NULL, &out);\n}\n\nchar *url_decode_parameter_name(const char **query)\n{\n\tstruct strbuf out = STRBUF_INIT;\n\treturn url_decode_internal(query, \"&=\", &out);\n}\n\nchar *url_decode_parameter_value(const char **query)\n{\n\tstruct strbuf out = STRBUF_INIT;\n\treturn url_decode_internal(query, \"&\", &out);\n}",
  "unsigned parse_whitespace_rule(const char *string)\n{\n\tunsigned rule = WS_DEFAULT_RULE;\n\n\twhile (string) {\n\t\tint i;\n\t\tsize_t len;\n\t\tconst char *ep;\n\t\tint negated = 0;\n\n\t\tstring = string + strspn(string, \", \\t\\n\\r\");\n\t\tep = strchrnul(string, ',');\n\t\tlen = ep - string;\n\n\t\tif (*string == '-') {\n\t\t\tnegated = 1;\n\t\t\tstring++;\n\t\t\tlen--;\n\t\t}\n\t\tif (!len)\n\t\t\tbreak;\n\t\tfor (i = 0; i < ARRAY_SIZE(whitespace_rule_names); i++) {\n\t\t\tif (strncmp(whitespace_rule_names[i].rule_name,\n\t\t\t\t    string, len))\n\t\t\t\tcontinue;\n\t\t\tif (negated)\n\t\t\t\trule &= ~whitespace_rule_names[i].rule_bits;\n\t\t\telse\n\t\t\t\trule |= whitespace_rule_names[i].rule_bits;\n\t\t\tbreak;\n\t\t}\n\t\tif (strncmp(string, \"tabwidth=\", 9) == 0) {\n\t\t\tunsigned tabwidth = atoi(string + 9);\n\t\t\tif (0 < tabwidth && tabwidth < 0100) {\n\t\t\t\trule &= ~WS_TAB_WIDTH_MASK;\n\t\t\t\trule |= tabwidth;\n\t\t\t}\n\t\t\telse\n\t\t\t\twarning(\"tabwidth %.*s out of range\",\n\t\t\t\t\t(int)(len - 9), string + 9);\n\t\t}\n\t\tstring = ep;\n\t}\n\n\tif (rule & WS_TAB_IN_INDENT && rule & WS_INDENT_WITH_NON_TAB)\n\t\tdie(\"cannot enforce both tab-in-indent and indent-with-non-tab\");\n\treturn rule;\n}\n\nunsigned whitespace_rule(struct index_state *istate, const char *pathname)\n{\n\tstatic struct attr_check *attr_whitespace_rule;\n\tconst char *value;\n\n\tif (!attr_whitespace_rule)\n\t\tattr_whitespace_rule = attr_check_initl(\"whitespace\", NULL);\n\n\tgit_check_attr(istate, pathname, attr_whitespace_rule);\n\tvalue = attr_whitespace_rule->items[0].value;\n\tif (ATTR_TRUE(value)) {\n\t\t/* true (whitespace) */\n\t\tunsigned all_rule = ws_tab_width(whitespace_rule_cfg);\n\t\tint i;\n\t\tfor (i = 0; i < ARRAY_SIZE(whitespace_rule_names); i++)\n\t\t\tif (!whitespace_rule_names[i].loosens_error &&\n\t\t\t    !whitespace_rule_names[i].exclude_default)\n\t\t\t\tall_rule |= whitespace_rule_names[i].rule_bits;\n\t\treturn all_rule;\n\t} else if (ATTR_FALSE(value)) {\n\t\t/* false (-whitespace) */\n\t\treturn ws_tab_width(whitespace_rule_cfg);\n\t} else if (ATTR_UNSET(value)) {\n\t\t/* reset to default (!whitespace) */\n\t\treturn whitespace_rule_cfg;\n\t} else {\n\t\t/* string */\n\t\treturn parse_whitespace_rule(value);\n\t}\n}\n\n/* The returned string should be freed by the caller. */\nchar *whitespace_error_string(unsigned ws)\n{\n\tstruct strbuf err = STRBUF_INIT;\n\tif ((ws & WS_TRAILING_SPACE) == WS_TRAILING_SPACE)\n\t\tstrbuf_addstr(&err, \"trailing whitespace\");\n\telse {\n\t\tif (ws & WS_BLANK_AT_EOL)\n\t\t\tstrbuf_addstr(&err, \"trailing whitespace\");\n\t\tif (ws & WS_BLANK_AT_EOF) {\n\t\t\tif (err.len)\n\t\t\t\tstrbuf_addstr(&err, \", \");\n\t\t\tstrbuf_addstr(&err, \"new blank line at EOF\");\n\t\t}\n\t}\n\tif (ws & WS_SPACE_BEFORE_TAB) {\n\t\tif (err.len)\n\t\t\tstrbuf_addstr(&err, \", \");\n\t\tstrbuf_addstr(&err, \"space before tab in indent\");\n\t}\n\tif (ws & WS_INDENT_WITH_NON_TAB) {\n\t\tif (err.len)\n\t\t\tstrbuf_addstr(&err, \", \");\n\t\tstrbuf_addstr(&err, \"indent with spaces\");\n\t}\n\tif (ws & WS_TAB_IN_INDENT) {\n\t\tif (err.len)\n\t\t\tstrbuf_addstr(&err, \", \");\n\t\tstrbuf_addstr(&err, \"tab in indent\");\n\t}\n\treturn strbuf_detach(&err, NULL);\n}\n\n/* If stream is non-NULL, emits the line after checking. */\nstatic unsigned ws_check_emit_1(const char *line, int len, unsigned ws_rule,\n\t\t\t\tFILE *stream, const char *set,\n\t\t\t\tconst char *reset, const char *ws)\n{\n\tunsigned result = 0;\n\tint written = 0;\n\tint trailing_whitespace = -1;\n\tint trailing_newline = 0;\n\tint trailing_carriage_return = 0;\n\tint i;\n\n\t/* Logic is simpler if we temporarily ignore the trailing newline. */\n\tif (len > 0 && line[len - 1] == '\\n') {\n\t\ttrailing_newline = 1;\n\t\tlen--;\n\t}\n\tif ((ws_rule & WS_CR_AT_EOL) &&\n\t    len > 0 && line[len - 1] == '\\r') {\n\t\ttrailing_carriage_return = 1;\n\t\tlen--;\n\t}\n\n\t/* Check for trailing whitespace. */\n\tif (ws_rule & WS_BLANK_AT_EOL) {\n\t\tfor (i = len - 1; i >= 0; i--) {\n\t\t\tif (isspace(line[i])) {\n\t\t\t\ttrailing_whitespace = i;\n\t\t\t\tresult |= WS_BLANK_AT_EOL;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (trailing_whitespace == -1)\n\t\ttrailing_whitespace = len;\n\n\t/* Check indentation */\n\tfor (i = 0; i < trailing_whitespace; i++) {\n\t\tif (line[i] == ' ')\n\t\t\tcontinue;\n\t\tif (line[i] != '\\t')\n\t\t\tbreak;\n\t\tif ((ws_rule & WS_SPACE_BEFORE_TAB) && written < i) {\n\t\t\tresult |= WS_SPACE_BEFORE_TAB;\n\t\t\tif (stream) {\n\t\t\t\tfputs(ws, stream);\n\t\t\t\tfwrite(line + written, i - written, 1, stream);\n\t\t\t\tfputs(reset, stream);\n\t\t\t\tfwrite(line + i, 1, 1, stream);\n\t\t\t}\n\t\t} else if (ws_rule & WS_TAB_IN_INDENT) {\n\t\t\tresult |= WS_TAB_IN_INDENT;\n\t\t\tif (stream) {\n\t\t\t\tfwrite(line + written, i - written, 1, stream);\n\t\t\t\tfputs(ws, stream);\n\t\t\t\tfwrite(line + i, 1, 1, stream);\n\t\t\t\tfputs(reset, stream);\n\t\t\t}\n\t\t} else if (stream) {\n\t\t\tfwrite(line + written, i - written + 1, 1, stream);\n\t\t}\n\t\twritten = i + 1;\n\t}\n\n\t/* Check for indent using non-tab. */\n\tif ((ws_rule & WS_INDENT_WITH_NON_TAB) && i - written >= ws_tab_width(ws_rule)) {\n\t\tresult |= WS_INDENT_WITH_NON_TAB;\n\t\tif (stream) {\n\t\t\tfputs(ws, stream);\n\t\t\tfwrite(line + written, i - written, 1, stream);\n\t\t\tfputs(reset, stream);\n\t\t}\n\t\twritten = i;\n\t}\n\n\tif (stream) {\n\t\t/*\n\t\t * Now the rest of the line starts at \"written\".\n\t\t * The non-highlighted part ends at \"trailing_whitespace\".\n\t\t */\n\n\t\t/* Emit non-highlighted (middle) segment. */\n\t\tif (trailing_whitespace - written > 0) {\n\t\t\tfputs(set, stream);\n\t\t\tfwrite(line + written,\n\t\t\t    trailing_whitespace - written, 1, stream);\n\t\t\tfputs(reset, stream);\n\t\t}\n\n\t\t/* Highlight errors in trailing whitespace. */\n\t\tif (trailing_whitespace != len) {\n\t\t\tfputs(ws, stream);\n\t\t\tfwrite(line + trailing_whitespace,\n\t\t\t    len - trailing_whitespace, 1, stream);\n\t\t\tfputs(reset, stream);\n\t\t}\n\t\tif (trailing_carriage_return)\n\t\t\tfputc('\\r', stream);\n\t\tif (trailing_newline)\n\t\t\tfputc('\\n', stream);\n\t}\n\treturn result;\n}",
  "unsigned parse_whitespace_rule(const char *string)\n{\n\tunsigned rule = WS_DEFAULT_RULE;\n\n\twhile (string) {\n\t\tint i;\n\t\tsize_t len;\n\t\tconst char *ep;\n\t\tint negated = 0;\n\n\t\tstring = string + strspn(string, \", \\t\\n\\r\");\n\t\tep = strchrnul(string, ',');\n\t\tlen = ep - string;\n\n\t\tif (*string == '-') {\n\t\t\tnegated = 1;\n\t\t\tstring++;\n\t\t\tlen--;\n\t\t}\n\t\tif (!len)\n\t\t\tbreak;\n\t\tfor (i = 0; i < ARRAY_SIZE(whitespace_rule_names); i++) {\n\t\t\tif (strncmp(whitespace_rule_names[i].rule_name,\n\t\t\t\t    string, len))\n\t\t\t\tcontinue;\n\t\t\tif (negated)\n\t\t\t\trule &= ~whitespace_rule_names[i].rule_bits;\n\t\t\telse\n\t\t\t\trule |= whitespace_rule_names[i].rule_bits;\n\t\t\tbreak;\n\t\t}\n\t\tif (strncmp(string, \"tabwidth=\", 9) == 0) {\n\t\t\tunsigned tabwidth = atoi(string + 9);\n\t\t\tif (0 < tabwidth && tabwidth < 0100) {\n\t\t\t\trule &= ~WS_TAB_WIDTH_MASK;\n\t\t\t\trule |= tabwidth;\n\t\t\t}\n\t\t\telse\n\t\t\t\twarning(\"tabwidth %.*s out of range\",\n\t\t\t\t\t(int)(len - 9), string + 9);\n\t\t}\n\t\tstring = ep;\n\t}\n\n\tif (rule & WS_TAB_IN_INDENT && rule & WS_INDENT_WITH_NON_TAB)\n\t\tdie(\"cannot enforce both tab-in-indent and indent-with-non-tab\");\n\treturn rule;\n}\n\nunsigned whitespace_rule(const char *pathname)\n{\n\tstatic struct attr_check *attr_whitespace_rule;\n\tconst char *value;\n\n\tif (!attr_whitespace_rule)\n\t\tattr_whitespace_rule = attr_check_initl(\"whitespace\", NULL);\n\n\tgit_check_attr(&the_index, pathname, attr_whitespace_rule);\n\tvalue = attr_whitespace_rule->items[0].value;\n\tif (ATTR_TRUE(value)) {\n\t\t/* true (whitespace) */\n\t\tunsigned all_rule = ws_tab_width(whitespace_rule_cfg);\n\t\tint i;\n\t\tfor (i = 0; i < ARRAY_SIZE(whitespace_rule_names); i++)\n\t\t\tif (!whitespace_rule_names[i].loosens_error &&\n\t\t\t    !whitespace_rule_names[i].exclude_default)\n\t\t\t\tall_rule |= whitespace_rule_names[i].rule_bits;\n\t\treturn all_rule;\n\t} else if (ATTR_FALSE(value)) {\n\t\t/* false (-whitespace) */\n\t\treturn ws_tab_width(whitespace_rule_cfg);\n\t} else if (ATTR_UNSET(value)) {\n\t\t/* reset to default (!whitespace) */\n\t\treturn whitespace_rule_cfg;\n\t} else {\n\t\t/* string */\n\t\treturn parse_whitespace_rule(value);\n\t}\n}\n\n/* The returned string should be freed by the caller. */\nchar *whitespace_error_string(unsigned ws)\n{\n\tstruct strbuf err = STRBUF_INIT;\n\tif ((ws & WS_TRAILING_SPACE) == WS_TRAILING_SPACE)\n\t\tstrbuf_addstr(&err, \"trailing whitespace\");\n\telse {\n\t\tif (ws & WS_BLANK_AT_EOL)\n\t\t\tstrbuf_addstr(&err, \"trailing whitespace\");\n\t\tif (ws & WS_BLANK_AT_EOF) {\n\t\t\tif (err.len)\n\t\t\t\tstrbuf_addstr(&err, \", \");\n\t\t\tstrbuf_addstr(&err, \"new blank line at EOF\");\n\t\t}\n\t}\n\tif (ws & WS_SPACE_BEFORE_TAB) {\n\t\tif (err.len)\n\t\t\tstrbuf_addstr(&err, \", \");\n\t\tstrbuf_addstr(&err, \"space before tab in indent\");\n\t}\n\tif (ws & WS_INDENT_WITH_NON_TAB) {\n\t\tif (err.len)\n\t\t\tstrbuf_addstr(&err, \", \");\n\t\tstrbuf_addstr(&err, \"indent with spaces\");\n\t}\n\tif (ws & WS_TAB_IN_INDENT) {\n\t\tif (err.len)\n\t\t\tstrbuf_addstr(&err, \", \");\n\t\tstrbuf_addstr(&err, \"tab in indent\");\n\t}\n\treturn strbuf_detach(&err, NULL);\n}\n\n/* If stream is non-NULL, emits the line after checking. */\nstatic unsigned ws_check_emit_1(const char *line, int len, unsigned ws_rule,\n\t\t\t\tFILE *stream, const char *set,\n\t\t\t\tconst char *reset, const char *ws)\n{\n\tunsigned result = 0;\n\tint written = 0;\n\tint trailing_whitespace = -1;\n\tint trailing_newline = 0;\n\tint trailing_carriage_return = 0;\n\tint i;\n\n\t/* Logic is simpler if we temporarily ignore the trailing newline. */\n\tif (len > 0 && line[len - 1] == '\\n') {\n\t\ttrailing_newline = 1;\n\t\tlen--;\n\t}\n\tif ((ws_rule & WS_CR_AT_EOL) &&\n\t    len > 0 && line[len - 1] == '\\r') {\n\t\ttrailing_carriage_return = 1;\n\t\tlen--;\n\t}\n\n\t/* Check for trailing whitespace. */\n\tif (ws_rule & WS_BLANK_AT_EOL) {\n\t\tfor (i = len - 1; i >= 0; i--) {\n\t\t\tif (isspace(line[i])) {\n\t\t\t\ttrailing_whitespace = i;\n\t\t\t\tresult |= WS_BLANK_AT_EOL;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (trailing_whitespace == -1)\n\t\ttrailing_whitespace = len;\n\n\t/* Check indentation */\n\tfor (i = 0; i < trailing_whitespace; i++) {\n\t\tif (line[i] == ' ')\n\t\t\tcontinue;\n\t\tif (line[i] != '\\t')\n\t\t\tbreak;\n\t\tif ((ws_rule & WS_SPACE_BEFORE_TAB) && written < i) {\n\t\t\tresult |= WS_SPACE_BEFORE_TAB;\n\t\t\tif (stream) {\n\t\t\t\tfputs(ws, stream);\n\t\t\t\tfwrite(line + written, i - written, 1, stream);\n\t\t\t\tfputs(reset, stream);\n\t\t\t\tfwrite(line + i, 1, 1, stream);\n\t\t\t}\n\t\t} else if (ws_rule & WS_TAB_IN_INDENT) {\n\t\t\tresult |= WS_TAB_IN_INDENT;\n\t\t\tif (stream) {\n\t\t\t\tfwrite(line + written, i - written, 1, stream);\n\t\t\t\tfputs(ws, stream);\n\t\t\t\tfwrite(line + i, 1, 1, stream);\n\t\t\t\tfputs(reset, stream);\n\t\t\t}\n\t\t} else if (stream) {\n\t\t\tfwrite(line + written, i - written + 1, 1, stream);\n\t\t}\n\t\twritten = i + 1;\n\t}\n\n\t/* Check for indent using non-tab. */\n\tif ((ws_rule & WS_INDENT_WITH_NON_TAB) && i - written >= ws_tab_width(ws_rule)) {\n\t\tresult |= WS_INDENT_WITH_NON_TAB;\n\t\tif (stream) {\n\t\t\tfputs(ws, stream);\n\t\t\tfwrite(line + written, i - written, 1, stream);\n\t\t\tfputs(reset, stream);\n\t\t}\n\t\twritten = i;\n\t}\n\n\tif (stream) {\n\t\t/*\n\t\t * Now the rest of the line starts at \"written\".\n\t\t * The non-highlighted part ends at \"trailing_whitespace\".\n\t\t */\n\n\t\t/* Emit non-highlighted (middle) segment. */\n\t\tif (trailing_whitespace - written > 0) {\n\t\t\tfputs(set, stream);\n\t\t\tfwrite(line + written,\n\t\t\t    trailing_whitespace - written, 1, stream);\n\t\t\tfputs(reset, stream);\n\t\t}\n\n\t\t/* Highlight errors in trailing whitespace. */\n\t\tif (trailing_whitespace != len) {\n\t\t\tfputs(ws, stream);\n\t\t\tfwrite(line + trailing_whitespace,\n\t\t\t    len - trailing_whitespace, 1, stream);\n\t\t\tfputs(reset, stream);\n\t\t}\n\t\tif (trailing_carriage_return)\n\t\t\tfputc('\\r', stream);\n\t\tif (trailing_newline)\n\t\t\tfputc('\\n', stream);\n\t}\n\treturn result;\n}",
  "unsigned parse_whitespace_rule(const char *string)\n{\n\tunsigned rule = WS_DEFAULT_RULE;\n\n\twhile (string) {\n\t\tint i;\n\t\tsize_t len;\n\t\tconst char *ep;\n\t\tint negated = 0;\n\n\t\tstring = string + strspn(string, \", \\t\\n\\r\");\n\t\tep = strchrnul(string, ',');\n\t\tlen = ep - string;\n\n\t\tif (*string == '-') {\n\t\t\tnegated = 1;\n\t\t\tstring++;\n\t\t\tlen--;\n\t\t}\n\t\tif (!len)\n\t\t\tbreak;\n\t\tfor (i = 0; i < ARRAY_SIZE(whitespace_rule_names); i++) {\n\t\t\tif (strncmp(whitespace_rule_names[i].rule_name,\n\t\t\t\t    string, len))\n\t\t\t\tcontinue;\n\t\t\tif (negated)\n\t\t\t\trule &= ~whitespace_rule_names[i].rule_bits;\n\t\t\telse\n\t\t\t\trule |= whitespace_rule_names[i].rule_bits;\n\t\t\tbreak;\n\t\t}\n\t\tif (strncmp(string, \"tabwidth=\", 9) == 0) {\n\t\t\tunsigned tabwidth = atoi(string + 9);\n\t\t\tif (0 < tabwidth && tabwidth < 0100) {\n\t\t\t\trule &= ~WS_TAB_WIDTH_MASK;\n\t\t\t\trule |= tabwidth;\n\t\t\t}\n\t\t\telse\n\t\t\t\twarning(\"tabwidth %.*s out of range\",\n\t\t\t\t\t(int)(len - 9), string + 9);\n\t\t}\n\t\tstring = ep;\n\t}\n\n\tif (rule & WS_TAB_IN_INDENT && rule & WS_INDENT_WITH_NON_TAB)\n\t\tdie(\"cannot enforce both tab-in-indent and indent-with-non-tab\");\n\treturn rule;\n}\n\nunsigned whitespace_rule(const char *pathname)\n{\n\tstatic struct attr_check *attr_whitespace_rule;\n\n\tif (!attr_whitespace_rule)\n\t\tattr_whitespace_rule = attr_check_initl(\"whitespace\", NULL);\n\n\tif (!git_check_attr(pathname, attr_whitespace_rule)) {\n\t\tconst char *value;\n\n\t\tvalue = attr_whitespace_rule->items[0].value;\n\t\tif (ATTR_TRUE(value)) {\n\t\t\t/* true (whitespace) */\n\t\t\tunsigned all_rule = ws_tab_width(whitespace_rule_cfg);\n\t\t\tint i;\n\t\t\tfor (i = 0; i < ARRAY_SIZE(whitespace_rule_names); i++)\n\t\t\t\tif (!whitespace_rule_names[i].loosens_error &&\n\t\t\t\t    !whitespace_rule_names[i].exclude_default)\n\t\t\t\t\tall_rule |= whitespace_rule_names[i].rule_bits;\n\t\t\treturn all_rule;\n\t\t} else if (ATTR_FALSE(value)) {\n\t\t\t/* false (-whitespace) */\n\t\t\treturn ws_tab_width(whitespace_rule_cfg);\n\t\t} else if (ATTR_UNSET(value)) {\n\t\t\t/* reset to default (!whitespace) */\n\t\t\treturn whitespace_rule_cfg;\n\t\t} else {\n\t\t\t/* string */\n\t\t\treturn parse_whitespace_rule(value);\n\t\t}\n\t} else {\n\t\treturn whitespace_rule_cfg;\n\t}\n}\n\n/* The returned string should be freed by the caller. */\nchar *whitespace_error_string(unsigned ws)\n{\n\tstruct strbuf err = STRBUF_INIT;\n\tif ((ws & WS_TRAILING_SPACE) == WS_TRAILING_SPACE)\n\t\tstrbuf_addstr(&err, \"trailing whitespace\");\n\telse {\n\t\tif (ws & WS_BLANK_AT_EOL)\n\t\t\tstrbuf_addstr(&err, \"trailing whitespace\");\n\t\tif (ws & WS_BLANK_AT_EOF) {\n\t\t\tif (err.len)\n\t\t\t\tstrbuf_addstr(&err, \", \");\n\t\t\tstrbuf_addstr(&err, \"new blank line at EOF\");\n\t\t}\n\t}\n\tif (ws & WS_SPACE_BEFORE_TAB) {\n\t\tif (err.len)\n\t\t\tstrbuf_addstr(&err, \", \");\n\t\tstrbuf_addstr(&err, \"space before tab in indent\");\n\t}\n\tif (ws & WS_INDENT_WITH_NON_TAB) {\n\t\tif (err.len)\n\t\t\tstrbuf_addstr(&err, \", \");\n\t\tstrbuf_addstr(&err, \"indent with spaces\");\n\t}\n\tif (ws & WS_TAB_IN_INDENT) {\n\t\tif (err.len)\n\t\t\tstrbuf_addstr(&err, \", \");\n\t\tstrbuf_addstr(&err, \"tab in indent\");\n\t}\n\treturn strbuf_detach(&err, NULL);\n}\n\n/* If stream is non-NULL, emits the line after checking. */\nstatic unsigned ws_check_emit_1(const char *line, int len, unsigned ws_rule,\n\t\t\t\tFILE *stream, const char *set,\n\t\t\t\tconst char *reset, const char *ws)\n{\n\tunsigned result = 0;\n\tint written = 0;\n\tint trailing_whitespace = -1;\n\tint trailing_newline = 0;\n\tint trailing_carriage_return = 0;\n\tint i;\n\n\t/* Logic is simpler if we temporarily ignore the trailing newline. */\n\tif (len > 0 && line[len - 1] == '\\n') {\n\t\ttrailing_newline = 1;\n\t\tlen--;\n\t}\n\tif ((ws_rule & WS_CR_AT_EOL) &&\n\t    len > 0 && line[len - 1] == '\\r') {\n\t\ttrailing_carriage_return = 1;\n\t\tlen--;\n\t}\n\n\t/* Check for trailing whitespace. */\n\tif (ws_rule & WS_BLANK_AT_EOL) {\n\t\tfor (i = len - 1; i >= 0; i--) {\n\t\t\tif (isspace(line[i])) {\n\t\t\t\ttrailing_whitespace = i;\n\t\t\t\tresult |= WS_BLANK_AT_EOL;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (trailing_whitespace == -1)\n\t\ttrailing_whitespace = len;\n\n\t/* Check indentation */\n\tfor (i = 0; i < trailing_whitespace; i++) {\n\t\tif (line[i] == ' ')\n\t\t\tcontinue;\n\t\tif (line[i] != '\\t')\n\t\t\tbreak;\n\t\tif ((ws_rule & WS_SPACE_BEFORE_TAB) && written < i) {\n\t\t\tresult |= WS_SPACE_BEFORE_TAB;\n\t\t\tif (stream) {\n\t\t\t\tfputs(ws, stream);\n\t\t\t\tfwrite(line + written, i - written, 1, stream);\n\t\t\t\tfputs(reset, stream);\n\t\t\t\tfwrite(line + i, 1, 1, stream);\n\t\t\t}\n\t\t} else if (ws_rule & WS_TAB_IN_INDENT) {\n\t\t\tresult |= WS_TAB_IN_INDENT;\n\t\t\tif (stream) {\n\t\t\t\tfwrite(line + written, i - written, 1, stream);\n\t\t\t\tfputs(ws, stream);\n\t\t\t\tfwrite(line + i, 1, 1, stream);\n\t\t\t\tfputs(reset, stream);\n\t\t\t}\n\t\t} else if (stream) {\n\t\t\tfwrite(line + written, i - written + 1, 1, stream);\n\t\t}\n\t\twritten = i + 1;\n\t}\n\n\t/* Check for indent using non-tab. */\n\tif ((ws_rule & WS_INDENT_WITH_NON_TAB) && i - written >= ws_tab_width(ws_rule)) {\n\t\tresult |= WS_INDENT_WITH_NON_TAB;\n\t\tif (stream) {\n\t\t\tfputs(ws, stream);\n\t\t\tfwrite(line + written, i - written, 1, stream);\n\t\t\tfputs(reset, stream);\n\t\t}\n\t\twritten = i;\n\t}\n\n\tif (stream) {\n\t\t/*\n\t\t * Now the rest of the line starts at \"written\".\n\t\t * The non-highlighted part ends at \"trailing_whitespace\".\n\t\t */\n\n\t\t/* Emit non-highlighted (middle) segment. */\n\t\tif (trailing_whitespace - written > 0) {\n\t\t\tfputs(set, stream);\n\t\t\tfwrite(line + written,\n\t\t\t    trailing_whitespace - written, 1, stream);\n\t\t\tfputs(reset, stream);\n\t\t}\n\n\t\t/* Highlight errors in trailing whitespace. */\n\t\tif (trailing_whitespace != len) {\n\t\t\tfputs(ws, stream);\n\t\t\tfwrite(line + trailing_whitespace,\n\t\t\t    len - trailing_whitespace, 1, stream);\n\t\t\tfputs(reset, stream);\n\t\t}\n\t\tif (trailing_carriage_return)\n\t\t\tfputc('\\r', stream);\n\t\tif (trailing_newline)\n\t\t\tfputc('\\n', stream);\n\t}\n\treturn result;\n}\n",
  "\nunsigned parse_whitespace_rule(const char *string)\n{\n\tunsigned rule = WS_DEFAULT_RULE;\n\n\twhile (string) {\n\t\tint i;\n\t\tsize_t len;\n\t\tconst char *ep;\n\t\tint negated = 0;\n\n\t\tstring = string + strspn(string, \", \\t\\n\\r\");\n\t\tep = strchrnul(string, ',');\n\t\tlen = ep - string;\n\n\t\tif (*string == '-') {\n\t\t\tnegated = 1;\n\t\t\tstring++;\n\t\t\tlen--;\n\t\t}\n\t\tif (!len)\n\t\t\tbreak;\n\t\tfor (i = 0; i < ARRAY_SIZE(whitespace_rule_names); i++) {\n\t\t\tif (strncmp(whitespace_rule_names[i].rule_name,\n\t\t\t\t    string, len))\n\t\t\t\tcontinue;\n\t\t\tif (negated)\n\t\t\t\trule &= ~whitespace_rule_names[i].rule_bits;\n\t\t\telse\n\t\t\t\trule |= whitespace_rule_names[i].rule_bits;\n\t\t\tbreak;\n\t\t}\n\t\tif (strncmp(string, \"tabwidth=\", 9) == 0) {\n\t\t\tunsigned tabwidth = atoi(string + 9);\n\t\t\tif (0 < tabwidth && tabwidth < 0100) {\n\t\t\t\trule &= ~WS_TAB_WIDTH_MASK;\n\t\t\t\trule |= tabwidth;\n\t\t\t}\n\t\t\telse\n\t\t\t\twarning(\"tabwidth %.*s out of range\",\n\t\t\t\t\t(int)(len - 9), string + 9);\n\t\t}\n\t\tstring = ep;\n\t}\n\n\tif (rule & WS_TAB_IN_INDENT && rule & WS_INDENT_WITH_NON_TAB)\n\t\tdie(\"cannot enforce both tab-in-indent and indent-with-non-tab\");\n\treturn rule;\n}\n\nstatic void setup_whitespace_attr_check(struct git_attr_check *check)\n{\n\tstatic struct git_attr *attr_whitespace;\n\n\tif (!attr_whitespace)\n\t\tattr_whitespace = git_attr(\"whitespace\");\n\tcheck[0].attr = attr_whitespace;\n}\n\nunsigned whitespace_rule(const char *pathname)\n{\n\tstruct git_attr_check attr_whitespace_rule;\n\n\tsetup_whitespace_attr_check(&attr_whitespace_rule);\n\tif (!git_check_attr(pathname, 1, &attr_whitespace_rule)) {\n\t\tconst char *value;\n\n\t\tvalue = attr_whitespace_rule.value;\n\t\tif (ATTR_TRUE(value)) {\n\t\t\t/* true (whitespace) */\n\t\t\tunsigned all_rule = ws_tab_width(whitespace_rule_cfg);\n\t\t\tint i;\n\t\t\tfor (i = 0; i < ARRAY_SIZE(whitespace_rule_names); i++)\n\t\t\t\tif (!whitespace_rule_names[i].loosens_error &&\n\t\t\t\t    !whitespace_rule_names[i].exclude_default)\n\t\t\t\t\tall_rule |= whitespace_rule_names[i].rule_bits;\n\t\t\treturn all_rule;\n\t\t} else if (ATTR_FALSE(value)) {\n\t\t\t/* false (-whitespace) */\n\t\t\treturn ws_tab_width(whitespace_rule_cfg);\n\t\t} else if (ATTR_UNSET(value)) {\n\t\t\t/* reset to default (!whitespace) */\n\t\t\treturn whitespace_rule_cfg;\n\t\t} else {\n\t\t\t/* string */\n\t\t\treturn parse_whitespace_rule(value);\n\t\t}\n\t} else {\n\t\treturn whitespace_rule_cfg;\n\t}\n}\n\n/* The returned string should be freed by the caller. */\nchar *whitespace_error_string(unsigned ws)\n{\n\tstruct strbuf err = STRBUF_INIT;\n\tif ((ws & WS_TRAILING_SPACE) == WS_TRAILING_SPACE)\n\t\tstrbuf_addstr(&err, \"trailing whitespace\");\n\telse {\n\t\tif (ws & WS_BLANK_AT_EOL)\n\t\t\tstrbuf_addstr(&err, \"trailing whitespace\");\n\t\tif (ws & WS_BLANK_AT_EOF) {\n\t\t\tif (err.len)\n\t\t\t\tstrbuf_addstr(&err, \", \");\n\t\t\tstrbuf_addstr(&err, \"new blank line at EOF\");\n\t\t}\n\t}\n\tif (ws & WS_SPACE_BEFORE_TAB) {\n\t\tif (err.len)\n\t\t\tstrbuf_addstr(&err, \", \");\n\t\tstrbuf_addstr(&err, \"space before tab in indent\");\n\t}\n\tif (ws & WS_INDENT_WITH_NON_TAB) {\n\t\tif (err.len)\n\t\t\tstrbuf_addstr(&err, \", \");\n\t\tstrbuf_addstr(&err, \"indent with spaces\");\n\t}\n\tif (ws & WS_TAB_IN_INDENT) {\n\t\tif (err.len)\n\t\t\tstrbuf_addstr(&err, \", \");\n\t\tstrbuf_addstr(&err, \"tab in indent\");\n\t}\n\treturn strbuf_detach(&err, NULL);\n}\n\n/* If stream is non-NULL, emits the line after checking. */\nstatic unsigned ws_check_emit_1(const char *line, int len, unsigned ws_rule,\n\t\t\t\tFILE *stream, const char *set,\n\t\t\t\tconst char *reset, const char *ws)\n{\n\tunsigned result = 0;\n\tint written = 0;\n\tint trailing_whitespace = -1;\n\tint trailing_newline = 0;\n\tint trailing_carriage_return = 0;\n\tint i;\n\n\t/* Logic is simpler if we temporarily ignore the trailing newline. */\n\tif (len > 0 && line[len - 1] == '\\n') {\n\t\ttrailing_newline = 1;\n\t\tlen--;\n\t}\n\tif ((ws_rule & WS_CR_AT_EOL) &&\n\t    len > 0 && line[len - 1] == '\\r') {\n\t\ttrailing_carriage_return = 1;\n\t\tlen--;\n\t}\n\n\t/* Check for trailing whitespace. */\n\tif (ws_rule & WS_BLANK_AT_EOL) {\n\t\tfor (i = len - 1; i >= 0; i--) {\n\t\t\tif (isspace(line[i])) {\n\t\t\t\ttrailing_whitespace = i;\n\t\t\t\tresult |= WS_BLANK_AT_EOL;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (trailing_whitespace == -1)\n\t\ttrailing_whitespace = len;\n\n\t/* Check indentation */\n\tfor (i = 0; i < trailing_whitespace; i++) {\n\t\tif (line[i] == ' ')\n\t\t\tcontinue;\n\t\tif (line[i] != '\\t')\n\t\t\tbreak;\n\t\tif ((ws_rule & WS_SPACE_BEFORE_TAB) && written < i) {\n\t\t\tresult |= WS_SPACE_BEFORE_TAB;\n\t\t\tif (stream) {\n\t\t\t\tfputs(ws, stream);\n\t\t\t\tfwrite(line + written, i - written, 1, stream);\n\t\t\t\tfputs(reset, stream);\n\t\t\t\tfwrite(line + i, 1, 1, stream);\n\t\t\t}\n\t\t} else if (ws_rule & WS_TAB_IN_INDENT) {\n\t\t\tresult |= WS_TAB_IN_INDENT;\n\t\t\tif (stream) {\n\t\t\t\tfwrite(line + written, i - written, 1, stream);\n\t\t\t\tfputs(ws, stream);\n\t\t\t\tfwrite(line + i, 1, 1, stream);\n\t\t\t\tfputs(reset, stream);\n\t\t\t}\n\t\t} else if (stream) {\n\t\t\tfwrite(line + written, i - written + 1, 1, stream);\n\t\t}\n\t\twritten = i + 1;\n\t}\n\n\t/* Check for indent using non-tab. */\n\tif ((ws_rule & WS_INDENT_WITH_NON_TAB) && i - written >= ws_tab_width(ws_rule)) {\n\t\tresult |= WS_INDENT_WITH_NON_TAB;\n\t\tif (stream) {\n\t\t\tfputs(ws, stream);\n\t\t\tfwrite(line + written, i - written, 1, stream);\n\t\t\tfputs(reset, stream);\n\t\t}\n\t\twritten = i;\n\t}\n\n\tif (stream) {\n\t\t/*\n\t\t * Now the rest of the line starts at \"written\".\n\t\t * The non-highlighted part ends at \"trailing_whitespace\".\n\t\t */\n\n\t\t/* Emit non-highlighted (middle) segment. */\n\t\tif (trailing_whitespace - written > 0) {\n\t\t\tfputs(set, stream);\n\t\t\tfwrite(line + written,\n\t\t\t    trailing_whitespace - written, 1, stream);\n\t\t\tfputs(reset, stream);\n\t\t}\n\n\t\t/* Highlight errors in trailing whitespace. */\n\t\tif (trailing_whitespace != len) {\n\t\t\tfputs(ws, stream);\n\t\t\tfwrite(line + trailing_whitespace,\n\t\t\t    len - trailing_whitespace, 1, stream);\n\t\t\tfputs(reset, stream);\n\t\t}\n\t\tif (trailing_carriage_return)\n\t\t\tfputc('\\r', stream);\n\t\tif (trailing_newline)\n\t\t\tfputc('\\n', stream);\n\t}\n\treturn result;\n}\n",
  "unsigned parse_whitespace_rule(const char *string)\n{\n\tunsigned rule = WS_DEFAULT_RULE;\n\n\twhile (string) {\n\t\tint i;\n\t\tsize_t len;\n\t\tconst char *ep;\n\t\tint negated = 0;\n\n\t\tstring = string + strspn(string, \", \\t\\n\\r\");\n\t\tep = strchr(string, ',');\n\t\tif (!ep)\n\t\t\tlen = strlen(string);\n\t\telse\n\t\t\tlen = ep - string;\n\n\t\tif (*string == '-') {\n\t\t\tnegated = 1;\n\t\t\tstring++;\n\t\t\tlen--;\n\t\t}\n\t\tif (!len)\n\t\t\tbreak;\n\t\tfor (i = 0; i < ARRAY_SIZE(whitespace_rule_names); i++) {\n\t\t\tif (strncmp(whitespace_rule_names[i].rule_name,\n\t\t\t\t    string, len))\n\t\t\t\tcontinue;\n\t\t\tif (negated)\n\t\t\t\trule &= ~whitespace_rule_names[i].rule_bits;\n\t\t\telse\n\t\t\t\trule |= whitespace_rule_names[i].rule_bits;\n\t\t\tbreak;\n\t\t}\n\t\tstring = ep;\n\t}\n\treturn rule;\n}\n\nstatic void setup_whitespace_attr_check(struct git_attr_check *check)\n{\n\tstatic struct git_attr *attr_whitespace;\n\n\tif (!attr_whitespace)\n\t\tattr_whitespace = git_attr(\"whitespace\");\n\tcheck[0].attr = attr_whitespace;\n}\n\nunsigned whitespace_rule(const char *pathname)\n{\n\tstruct git_attr_check attr_whitespace_rule;\n\n\tsetup_whitespace_attr_check(&attr_whitespace_rule);\n\tif (!git_checkattr(pathname, 1, &attr_whitespace_rule)) {\n\t\tconst char *value;\n\n\t\tvalue = attr_whitespace_rule.value;\n\t\tif (ATTR_TRUE(value)) {\n\t\t\t/* true (whitespace) */\n\t\t\tunsigned all_rule = 0;\n\t\t\tint i;\n\t\t\tfor (i = 0; i < ARRAY_SIZE(whitespace_rule_names); i++)\n\t\t\t\tif (!whitespace_rule_names[i].loosens_error)\n\t\t\t\t\tall_rule |= whitespace_rule_names[i].rule_bits;\n\t\t\treturn all_rule;\n\t\t} else if (ATTR_FALSE(value)) {\n\t\t\t/* false (-whitespace) */\n\t\t\treturn 0;\n\t\t} else if (ATTR_UNSET(value)) {\n\t\t\t/* reset to default (!whitespace) */\n\t\t\treturn whitespace_rule_cfg;\n\t\t} else {\n\t\t\t/* string */\n\t\t\treturn parse_whitespace_rule(value);\n\t\t}\n\t} else {\n\t\treturn whitespace_rule_cfg;\n\t}\n}\n\n/* The returned string should be freed by the caller. */\nchar *whitespace_error_string(unsigned ws)\n{\n\tstruct strbuf err = STRBUF_INIT;\n\tif ((ws & WS_TRAILING_SPACE) == WS_TRAILING_SPACE)\n\t\tstrbuf_addstr(&err, \"trailing whitespace\");\n\telse {\n\t\tif (ws & WS_BLANK_AT_EOL)\n\t\t\tstrbuf_addstr(&err, \"trailing whitespace\");\n\t\tif (ws & WS_BLANK_AT_EOF) {\n\t\t\tif (err.len)\n\t\t\t\tstrbuf_addstr(&err, \", \");\n\t\t\tstrbuf_addstr(&err, \"new blank line at EOF\");\n\t\t}\n\t}\n\tif (ws & WS_SPACE_BEFORE_TAB) {\n\t\tif (err.len)\n\t\t\tstrbuf_addstr(&err, \", \");\n\t\tstrbuf_addstr(&err, \"space before tab in indent\");\n\t}\n\tif (ws & WS_INDENT_WITH_NON_TAB) {\n\t\tif (err.len)\n\t\t\tstrbuf_addstr(&err, \", \");\n\t\tstrbuf_addstr(&err, \"indent with spaces\");\n\t}\n\treturn strbuf_detach(&err, NULL);\n}\n\n/* If stream is non-NULL, emits the line after checking. */\nstatic unsigned ws_check_emit_1(const char *line, int len, unsigned ws_rule,\n\t\t\t\tFILE *stream, const char *set,\n\t\t\t\tconst char *reset, const char *ws)\n{\n\tunsigned result = 0;\n\tint written = 0;\n\tint trailing_whitespace = -1;\n\tint trailing_newline = 0;\n\tint trailing_carriage_return = 0;\n\tint i;\n\n\t/* Logic is simpler if we temporarily ignore the trailing newline. */\n\tif (len > 0 && line[len - 1] == '\\n') {\n\t\ttrailing_newline = 1;\n\t\tlen--;\n\t}\n\tif ((ws_rule & WS_CR_AT_EOL) &&\n\t    len > 0 && line[len - 1] == '\\r') {\n\t\ttrailing_carriage_return = 1;\n\t\tlen--;\n\t}\n\n\t/* Check for trailing whitespace. */\n\tif (ws_rule & WS_BLANK_AT_EOL) {\n\t\tfor (i = len - 1; i >= 0; i--) {\n\t\t\tif (isspace(line[i])) {\n\t\t\t\ttrailing_whitespace = i;\n\t\t\t\tresult |= WS_BLANK_AT_EOL;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Check for space before tab in initial indent. */\n\tfor (i = 0; i < len; i++) {\n\t\tif (line[i] == ' ')\n\t\t\tcontinue;\n\t\tif (line[i] != '\\t')\n\t\t\tbreak;\n\t\tif ((ws_rule & WS_SPACE_BEFORE_TAB) && written < i) {\n\t\t\tresult |= WS_SPACE_BEFORE_TAB;\n\t\t\tif (stream) {\n\t\t\t\tfputs(ws, stream);\n\t\t\t\tfwrite(line + written, i - written, 1, stream);\n\t\t\t\tfputs(reset, stream);\n\t\t\t}\n\t\t} else if (stream)\n\t\t\tfwrite(line + written, i - written, 1, stream);\n\t\tif (stream)\n\t\t\tfwrite(line + i, 1, 1, stream);\n\t\twritten = i + 1;\n\t}\n\n\t/* Check for indent using non-tab. */\n\tif ((ws_rule & WS_INDENT_WITH_NON_TAB) && i - written >= 8) {\n\t\tresult |= WS_INDENT_WITH_NON_TAB;\n\t\tif (stream) {\n\t\t\tfputs(ws, stream);\n\t\t\tfwrite(line + written, i - written, 1, stream);\n\t\t\tfputs(reset, stream);\n\t\t}\n\t\twritten = i;\n\t}\n\n\tif (stream) {\n\t\t/*\n\t\t * Now the rest of the line starts at \"written\".\n\t\t * The non-highlighted part ends at \"trailing_whitespace\".\n\t\t */\n\t\tif (trailing_whitespace == -1)\n\t\t\ttrailing_whitespace = len;\n\n\t\t/* Emit non-highlighted (middle) segment. */\n\t\tif (trailing_whitespace - written > 0) {\n\t\t\tfputs(set, stream);\n\t\t\tfwrite(line + written,\n\t\t\t    trailing_whitespace - written, 1, stream);\n\t\t\tfputs(reset, stream);\n\t\t}\n\n\t\t/* Highlight errors in trailing whitespace. */\n\t\tif (trailing_whitespace != len) {\n\t\t\tfputs(ws, stream);\n\t\t\tfwrite(line + trailing_whitespace,\n\t\t\t    len - trailing_whitespace, 1, stream);\n\t\t\tfputs(reset, stream);\n\t\t}\n\t\tif (trailing_carriage_return)\n\t\t\tfputc('\\r', stream);\n\t\tif (trailing_newline)\n\t\t\tfputc('\\n', stream);\n\t}\n\treturn result;\n}\n",
  "#include \"cache.h\"\n#include \"blob.h\"\n#include \"object-store.h\"\n#include \"dir.h\"\n#include \"streaming.h\"\n#include \"submodule.h\"\n#include \"progress.h\"\n#include \"fsmonitor.h\"\n\nstatic void create_directories(const char *path, int path_len,\n\t\t\t       const struct checkout *state)\n{\n\tchar *buf = xmallocz(path_len);\n\tint len = 0;\n\n\twhile (len < path_len) {\n\t\tdo {\n\t\t\tbuf[len] = path[len];\n\t\t\tlen++;\n\t\t} while (len < path_len && path[len] != '/');\n\t\tif (len >= path_len)\n\t\t\tbreak;\n\t\tbuf[len] = 0;\n\n\t\t/*\n\t\t * For 'checkout-index --prefix=<dir>', <dir> is\n\t\t * allowed to be a symlink to an existing directory,\n\t\t * and we set 'state->base_dir_len' below, such that\n\t\t * we test the path components of the prefix with the\n\t\t * stat() function instead of the lstat() function.\n\t\t */\n\t\tif (has_dirs_only_path(buf, len, state->base_dir_len))\n\t\t\tcontinue; /* ok, it is already a directory. */\n\n\t\t/*\n\t\t * If this mkdir() would fail, it could be that there\n\t\t * is already a symlink or something else exists\n\t\t * there, therefore we then try to unlink it and try\n\t\t * one more time to create the directory.\n\t\t */\n\t\tif (mkdir(buf, 0777)) {\n\t\t\tif (errno == EEXIST && state->force &&\n\t\t\t    !unlink_or_warn(buf) && !mkdir(buf, 0777))\n\t\t\t\tcontinue;\n\t\t\tdie_errno(\"cannot create directory at '%s'\", buf);\n\t\t}\n\t}\n\tfree(buf);\n}\n\nstatic void remove_subtree(struct strbuf *path)\n{\n\tDIR *dir = opendir(path->buf);\n\tstruct dirent *de;\n\tint origlen = path->len;\n\n\tif (!dir)\n\t\tdie_errno(\"cannot opendir '%s'\", path->buf);\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tstruct stat st;\n\n\t\tif (is_dot_or_dotdot(de->d_name))\n\t\t\tcontinue;\n\n\t\tstrbuf_addch(path, '/');\n\t\tstrbuf_addstr(path, de->d_name);\n\t\tif (lstat(path->buf, &st))\n\t\t\tdie_errno(\"cannot lstat '%s'\", path->buf);\n\t\tif (S_ISDIR(st.st_mode))\n\t\t\tremove_subtree(path);\n\t\telse if (unlink(path->buf))\n\t\t\tdie_errno(\"cannot unlink '%s'\", path->buf);\n\t\tstrbuf_setlen(path, origlen);\n\t}\n\tclosedir(dir);\n\tif (rmdir(path->buf))\n\t\tdie_errno(\"cannot rmdir '%s'\", path->buf);\n}\n\nstatic int create_file(const char *path, unsigned int mode)\n{\n\tmode = (mode & 0100) ? 0777 : 0666;\n\treturn open(path, O_WRONLY | O_CREAT | O_EXCL, mode);\n}\n\nstatic void *read_blob_entry(const struct cache_entry *ce, unsigned long *size)\n{\n\tenum object_type type;\n\tvoid *blob_data = read_object_file(&ce->oid, &type, size);\n\n\tif (blob_data) {\n\t\tif (type == OBJ_BLOB)\n\t\t\treturn blob_data;\n\t\tfree(blob_data);\n\t}\n\treturn NULL;\n}\n\nstatic int open_output_fd(char *path, const struct cache_entry *ce, int to_tempfile)\n{\n\tint symlink = (ce->ce_mode & S_IFMT) != S_IFREG;\n\tif (to_tempfile) {\n\t\txsnprintf(path, TEMPORARY_FILENAME_LENGTH, \"%s\",\n\t\t\t  symlink ? \".merge_link_XXXXXX\" : \".merge_file_XXXXXX\");\n\t\treturn mkstemp(path);\n\t} else {\n\t\treturn create_file(path, !symlink ? ce->ce_mode : 0666);\n\t}\n}\n\nstatic int fstat_output(int fd, const struct checkout *state, struct stat *st)\n{\n\t/* use fstat() only when path == ce->name */\n\tif (fstat_is_reliable() &&\n\t    state->refresh_cache && !state->base_dir_len) {\n\t\tfstat(fd, st);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int streaming_write_entry(const struct cache_entry *ce, char *path,\n\t\t\t\t struct stream_filter *filter,\n\t\t\t\t const struct checkout *state, int to_tempfile,\n\t\t\t\t int *fstat_done, struct stat *statbuf)\n{\n\tint result = 0;\n\tint fd;\n\n\tfd = open_output_fd(path, ce, to_tempfile);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tresult |= stream_blob_to_fd(fd, &ce->oid, filter, 1);\n\t*fstat_done = fstat_output(fd, state, statbuf);\n\tresult |= close(fd);\n\n\tif (result)\n\t\tunlink(path);\n\treturn result;\n}\n\nvoid enable_delayed_checkout(struct checkout *state)\n{\n\tif (!state->delayed_checkout) {\n\t\tstate->delayed_checkout = xmalloc(sizeof(*state->delayed_checkout));\n\t\tstate->delayed_checkout->state = CE_CAN_DELAY;\n\t\tstring_list_init(&state->delayed_checkout->filters, 0);\n\t\tstring_list_init(&state->delayed_checkout->paths, 0);\n\t}\n}\n\nstatic int remove_available_paths(struct string_list_item *item, void *cb_data)\n{\n\tstruct string_list *available_paths = cb_data;\n\tstruct string_list_item *available;\n\n\tavailable = string_list_lookup(available_paths, item->string);\n\tif (available)\n\t\tavailable->util = (void *)item->string;\n\treturn !available;\n}\n",
  "#include \"cache.h\"\n#include \"blob.h\"\n#include \"dir.h\"\n#include \"streaming.h\"\n#include \"submodule.h\"\n#include \"progress.h\"\n#include \"fsmonitor.h\"\n\nstatic void create_directories(const char *path, int path_len,\n\t\t\t       const struct checkout *state)\n{\n\tchar *buf = xmallocz(path_len);\n\tint len = 0;\n\n\twhile (len < path_len) {\n\t\tdo {\n\t\t\tbuf[len] = path[len];\n\t\t\tlen++;\n\t\t} while (len < path_len && path[len] != '/');\n\t\tif (len >= path_len)\n\t\t\tbreak;\n\t\tbuf[len] = 0;\n\n\t\t/*\n\t\t * For 'checkout-index --prefix=<dir>', <dir> is\n\t\t * allowed to be a symlink to an existing directory,\n\t\t * and we set 'state->base_dir_len' below, such that\n\t\t * we test the path components of the prefix with the\n\t\t * stat() function instead of the lstat() function.\n\t\t */\n\t\tif (has_dirs_only_path(buf, len, state->base_dir_len))\n\t\t\tcontinue; /* ok, it is already a directory. */\n\n\t\t/*\n\t\t * If this mkdir() would fail, it could be that there\n\t\t * is already a symlink or something else exists\n\t\t * there, therefore we then try to unlink it and try\n\t\t * one more time to create the directory.\n\t\t */\n\t\tif (mkdir(buf, 0777)) {\n\t\t\tif (errno == EEXIST && state->force &&\n\t\t\t    !unlink_or_warn(buf) && !mkdir(buf, 0777))\n\t\t\t\tcontinue;\n\t\t\tdie_errno(\"cannot create directory at '%s'\", buf);\n\t\t}\n\t}\n\tfree(buf);\n}\n\nstatic void remove_subtree(struct strbuf *path)\n{\n\tDIR *dir = opendir(path->buf);\n\tstruct dirent *de;\n\tint origlen = path->len;\n\n\tif (!dir)\n\t\tdie_errno(\"cannot opendir '%s'\", path->buf);\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tstruct stat st;\n\n\t\tif (is_dot_or_dotdot(de->d_name))\n\t\t\tcontinue;\n\n\t\tstrbuf_addch(path, '/');\n\t\tstrbuf_addstr(path, de->d_name);\n\t\tif (lstat(path->buf, &st))\n\t\t\tdie_errno(\"cannot lstat '%s'\", path->buf);\n\t\tif (S_ISDIR(st.st_mode))\n\t\t\tremove_subtree(path);\n\t\telse if (unlink(path->buf))\n\t\t\tdie_errno(\"cannot unlink '%s'\", path->buf);\n\t\tstrbuf_setlen(path, origlen);\n\t}\n\tclosedir(dir);\n\tif (rmdir(path->buf))\n\t\tdie_errno(\"cannot rmdir '%s'\", path->buf);\n}\n\nstatic int create_file(const char *path, unsigned int mode)\n{\n\tmode = (mode & 0100) ? 0777 : 0666;\n\treturn open(path, O_WRONLY | O_CREAT | O_EXCL, mode);\n}\n\nstatic void *read_blob_entry(const struct cache_entry *ce, unsigned long *size)\n{\n\tenum object_type type;\n\tvoid *blob_data = read_object_file(&ce->oid, &type, size);\n\n\tif (blob_data) {\n\t\tif (type == OBJ_BLOB)\n\t\t\treturn blob_data;\n\t\tfree(blob_data);\n\t}\n\treturn NULL;\n}\n\nstatic int open_output_fd(char *path, const struct cache_entry *ce, int to_tempfile)\n{\n\tint symlink = (ce->ce_mode & S_IFMT) != S_IFREG;\n\tif (to_tempfile) {\n\t\txsnprintf(path, TEMPORARY_FILENAME_LENGTH, \"%s\",\n\t\t\t  symlink ? \".merge_link_XXXXXX\" : \".merge_file_XXXXXX\");\n\t\treturn mkstemp(path);\n\t} else {\n\t\treturn create_file(path, !symlink ? ce->ce_mode : 0666);\n\t}\n}\n\nstatic int fstat_output(int fd, const struct checkout *state, struct stat *st)\n{\n\t/* use fstat() only when path == ce->name */\n\tif (fstat_is_reliable() &&\n\t    state->refresh_cache && !state->base_dir_len) {\n\t\tfstat(fd, st);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int streaming_write_entry(const struct cache_entry *ce, char *path,\n\t\t\t\t struct stream_filter *filter,\n\t\t\t\t const struct checkout *state, int to_tempfile,\n\t\t\t\t int *fstat_done, struct stat *statbuf)\n{\n\tint result = 0;\n\tint fd;\n\n\tfd = open_output_fd(path, ce, to_tempfile);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tresult |= stream_blob_to_fd(fd, &ce->oid, filter, 1);\n\t*fstat_done = fstat_output(fd, state, statbuf);\n\tresult |= close(fd);\n\n\tif (result)\n\t\tunlink(path);\n\treturn result;\n}\n\nvoid enable_delayed_checkout(struct checkout *state)\n{\n\tif (!state->delayed_checkout) {\n\t\tstate->delayed_checkout = xmalloc(sizeof(*state->delayed_checkout));\n\t\tstate->delayed_checkout->state = CE_CAN_DELAY;\n\t\tstring_list_init(&state->delayed_checkout->filters, 0);\n\t\tstring_list_init(&state->delayed_checkout->paths, 0);\n\t}\n}\n\nstatic int remove_available_paths(struct string_list_item *item, void *cb_data)\n{\n\tstruct string_list *available_paths = cb_data;\n\tstruct string_list_item *available;\n\n\tavailable = string_list_lookup(available_paths, item->string);\n\tif (available)\n\t\tavailable->util = (void *)item->string;\n\treturn !available;\n}",
  "#include \"cache.h\"\n#include \"blob.h\"\n#include \"dir.h\"\n#include \"streaming.h\"\n\nstatic void create_directories(const char *path, int path_len,\n\t\t\t       const struct checkout *state)\n{\n\tchar *buf = xmalloc(path_len + 1);\n\tint len = 0;\n\n\twhile (len < path_len) {\n\t\tdo {\n\t\t\tbuf[len] = path[len];\n\t\t\tlen++;\n\t\t} while (len < path_len && path[len] != '/');\n\t\tif (len >= path_len)\n\t\t\tbreak;\n\t\tbuf[len] = 0;\n\n\t\t/*\n\t\t * For 'checkout-index --prefix=<dir>', <dir> is\n\t\t * allowed to be a symlink to an existing directory,\n\t\t * and we set 'state->base_dir_len' below, such that\n\t\t * we test the path components of the prefix with the\n\t\t * stat() function instead of the lstat() function.\n\t\t */\n\t\tif (has_dirs_only_path(buf, len, state->base_dir_len))\n\t\t\tcontinue; /* ok, it is already a directory. */\n\n\t\t/*\n\t\t * If this mkdir() would fail, it could be that there\n\t\t * is already a symlink or something else exists\n\t\t * there, therefore we then try to unlink it and try\n\t\t * one more time to create the directory.\n\t\t */\n\t\tif (mkdir(buf, 0777)) {\n\t\t\tif (errno == EEXIST && state->force &&\n\t\t\t    !unlink_or_warn(buf) && !mkdir(buf, 0777))\n\t\t\t\tcontinue;\n\t\t\tdie_errno(\"cannot create directory at '%s'\", buf);\n\t\t}\n\t}\n\tfree(buf);\n}\n\nstatic void remove_subtree(const char *path)\n{\n\tDIR *dir = opendir(path);\n\tstruct dirent *de;\n\tchar pathbuf[PATH_MAX];\n\tchar *name;\n\n\tif (!dir)\n\t\tdie_errno(\"cannot opendir '%s'\", path);\n\tstrcpy(pathbuf, path);\n\tname = pathbuf + strlen(path);\n\t*name++ = '/';\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tstruct stat st;\n\t\tif (is_dot_or_dotdot(de->d_name))\n\t\t\tcontinue;\n\t\tstrcpy(name, de->d_name);\n\t\tif (lstat(pathbuf, &st))\n\t\t\tdie_errno(\"cannot lstat '%s'\", pathbuf);\n\t\tif (S_ISDIR(st.st_mode))\n\t\t\tremove_subtree(pathbuf);\n\t\telse if (unlink(pathbuf))\n\t\t\tdie_errno(\"cannot unlink '%s'\", pathbuf);\n\t}\n\tclosedir(dir);\n\tif (rmdir(path))\n\t\tdie_errno(\"cannot rmdir '%s'\", path);\n}\n\nstatic int create_file(const char *path, unsigned int mode)\n{\n\tmode = (mode & 0100) ? 0777 : 0666;\n\treturn open(path, O_WRONLY | O_CREAT | O_EXCL, mode);\n}\n\nstatic void *read_blob_entry(struct cache_entry *ce, unsigned long *size)\n{\n\tenum object_type type;\n\tvoid *new = read_sha1_file(ce->sha1, &type, size);\n\n\tif (new) {\n\t\tif (type == OBJ_BLOB)\n\t\t\treturn new;\n\t\tfree(new);\n\t}\n\treturn NULL;\n}\n\nstatic int open_output_fd(char *path, struct cache_entry *ce, int to_tempfile)\n{\n\tint symlink = (ce->ce_mode & S_IFMT) != S_IFREG;\n\tif (to_tempfile) {\n\t\tstrcpy(path, symlink\n\t\t       ? \".merge_link_XXXXXX\" : \".merge_file_XXXXXX\");\n\t\treturn mkstemp(path);\n\t} else {\n\t\treturn create_file(path, !symlink ? ce->ce_mode : 0666);\n\t}\n}\n\nstatic int fstat_output(int fd, const struct checkout *state, struct stat *st)\n{\n\t/* use fstat() only when path == ce->name */\n\tif (fstat_is_reliable() &&\n\t    state->refresh_cache && !state->base_dir_len) {\n\t\tfstat(fd, st);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int streaming_write_entry(struct cache_entry *ce, char *path,\n\t\t\t\t struct stream_filter *filter,\n\t\t\t\t const struct checkout *state, int to_tempfile,\n\t\t\t\t int *fstat_done, struct stat *statbuf)\n{\n\tint result = 0;\n\tint fd;\n\n\tfd = open_output_fd(path, ce, to_tempfile);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tresult |= stream_blob_to_fd(fd, ce->sha1, filter, 1);\n\t*fstat_done = fstat_output(fd, state, statbuf);\n\tresult |= close(fd);\n\n\tif (result)\n\t\tunlink(path);\n\treturn result;\n}\n",
  "#include \"cache.h\"\n#include \"blob.h\"\n#include \"dir.h\"\n#include \"streaming.h\"\n\nstatic void create_directories(const char *path, int path_len,\n\t\t\t       const struct checkout *state)\n{\n\tchar *buf = xmalloc(path_len + 1);\n\tint len = 0;\n\n\twhile (len < path_len) {\n\t\tdo {\n\t\t\tbuf[len] = path[len];\n\t\t\tlen++;\n\t\t} while (len < path_len && path[len] != '/');\n\t\tif (len >= path_len)\n\t\t\tbreak;\n\t\tbuf[len] = 0;\n\n\t\t/*\n\t\t * For 'checkout-index --prefix=<dir>', <dir> is\n\t\t * allowed to be a symlink to an existing directory,\n\t\t * and we set 'state->base_dir_len' below, such that\n\t\t * we test the path components of the prefix with the\n\t\t * stat() function instead of the lstat() function.\n\t\t */\n\t\tif (has_dirs_only_path(buf, len, state->base_dir_len))\n\t\t\tcontinue; /* ok, it is already a directory. */\n\n\t\t/*\n\t\t * If this mkdir() would fail, it could be that there\n\t\t * is already a symlink or something else exists\n\t\t * there, therefore we then try to unlink it and try\n\t\t * one more time to create the directory.\n\t\t */\n\t\tif (mkdir(buf, 0777)) {\n\t\t\tif (errno == EEXIST && state->force &&\n\t\t\t    !unlink_or_warn(buf) && !mkdir(buf, 0777))\n\t\t\t\tcontinue;\n\t\t\tdie_errno(\"cannot create directory at '%s'\", buf);\n\t\t}\n\t}\n\tfree(buf);\n}\n\nstatic void remove_subtree(struct strbuf *path)\n{\n\tDIR *dir = opendir(path->buf);\n\tstruct dirent *de;\n\tint origlen = path->len;\n\n\tif (!dir)\n\t\tdie_errno(\"cannot opendir '%s'\", path->buf);\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tstruct stat st;\n\n\t\tif (is_dot_or_dotdot(de->d_name))\n\t\t\tcontinue;\n\n\t\tstrbuf_addch(path, '/');\n\t\tstrbuf_addstr(path, de->d_name);\n\t\tif (lstat(path->buf, &st))\n\t\t\tdie_errno(\"cannot lstat '%s'\", path->buf);\n\t\tif (S_ISDIR(st.st_mode))\n\t\t\tremove_subtree(path);\n\t\telse if (unlink(path->buf))\n\t\t\tdie_errno(\"cannot unlink '%s'\", path->buf);\n\t\tstrbuf_setlen(path, origlen);\n\t}\n\tclosedir(dir);\n\tif (rmdir(path->buf))\n\t\tdie_errno(\"cannot rmdir '%s'\", path->buf);\n}\n\nstatic int create_file(const char *path, unsigned int mode)\n{\n\tmode = (mode & 0100) ? 0777 : 0666;\n\treturn open(path, O_WRONLY | O_CREAT | O_EXCL, mode);\n}\n\nstatic void *read_blob_entry(const struct cache_entry *ce, unsigned long *size)\n{\n\tenum object_type type;\n\tvoid *new = read_sha1_file(ce->sha1, &type, size);\n\n\tif (new) {\n\t\tif (type == OBJ_BLOB)\n\t\t\treturn new;\n\t\tfree(new);\n\t}\n\treturn NULL;\n}\n\nstatic int open_output_fd(char *path, const struct cache_entry *ce, int to_tempfile)\n{\n\tint symlink = (ce->ce_mode & S_IFMT) != S_IFREG;\n\tif (to_tempfile) {\n\t\txsnprintf(path, TEMPORARY_FILENAME_LENGTH, \"%s\",\n\t\t\t  symlink ? \".merge_link_XXXXXX\" : \".merge_file_XXXXXX\");\n\t\treturn mkstemp(path);\n\t} else {\n\t\treturn create_file(path, !symlink ? ce->ce_mode : 0666);\n\t}\n}\n\nstatic int fstat_output(int fd, const struct checkout *state, struct stat *st)\n{\n\t/* use fstat() only when path == ce->name */\n\tif (fstat_is_reliable() &&\n\t    state->refresh_cache && !state->base_dir_len) {\n\t\tfstat(fd, st);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int streaming_write_entry(const struct cache_entry *ce, char *path,\n\t\t\t\t struct stream_filter *filter,\n\t\t\t\t const struct checkout *state, int to_tempfile,\n\t\t\t\t int *fstat_done, struct stat *statbuf)\n{\n\tint result = 0;\n\tint fd;\n\n\tfd = open_output_fd(path, ce, to_tempfile);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tresult |= stream_blob_to_fd(fd, ce->sha1, filter, 1);\n\t*fstat_done = fstat_output(fd, state, statbuf);\n\tresult |= close(fd);\n\n\tif (result)\n\t\tunlink(path);\n\treturn result;\n}\n",
  "#include \"cache.h\"\n#include \"blob.h\"\n#include \"dir.h\"\n#include \"streaming.h\"\n\nstatic void create_directories(const char *path, int path_len,\n\t\t\t       const struct checkout *state)\n{\n\tchar *buf = xmalloc(path_len + 1);\n\tint len = 0;\n\n\twhile (len < path_len) {\n\t\tdo {\n\t\t\tbuf[len] = path[len];\n\t\t\tlen++;\n\t\t} while (len < path_len && path[len] != '/');\n\t\tif (len >= path_len)\n\t\t\tbreak;\n\t\tbuf[len] = 0;\n\n\t\t/*\n\t\t * For 'checkout-index --prefix=<dir>', <dir> is\n\t\t * allowed to be a symlink to an existing directory,\n\t\t * and we set 'state->base_dir_len' below, such that\n\t\t * we test the path components of the prefix with the\n\t\t * stat() function instead of the lstat() function.\n\t\t */\n\t\tif (has_dirs_only_path(buf, len, state->base_dir_len))\n\t\t\tcontinue; /* ok, it is already a directory. */\n\n\t\t/*\n\t\t * If this mkdir() would fail, it could be that there\n\t\t * is already a symlink or something else exists\n\t\t * there, therefore we then try to unlink it and try\n\t\t * one more time to create the directory.\n\t\t */\n\t\tif (mkdir(buf, 0777)) {\n\t\t\tif (errno == EEXIST && state->force &&\n\t\t\t    !unlink_or_warn(buf) && !mkdir(buf, 0777))\n\t\t\t\tcontinue;\n\t\t\tdie_errno(\"cannot create directory at '%s'\", buf);\n\t\t}\n\t}\n\tfree(buf);\n}\n\nstatic void remove_subtree(const char *path)\n{\n\tDIR *dir = opendir(path);\n\tstruct dirent *de;\n\tchar pathbuf[PATH_MAX];\n\tchar *name;\n\n\tif (!dir)\n\t\tdie_errno(\"cannot opendir '%s'\", path);\n\tstrcpy(pathbuf, path);\n\tname = pathbuf + strlen(path);\n\t*name++ = '/';\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tstruct stat st;\n\t\tif (is_dot_or_dotdot(de->d_name))\n\t\t\tcontinue;\n\t\tstrcpy(name, de->d_name);\n\t\tif (lstat(pathbuf, &st))\n\t\t\tdie_errno(\"cannot lstat '%s'\", pathbuf);\n\t\tif (S_ISDIR(st.st_mode))\n\t\t\tremove_subtree(pathbuf);\n\t\telse if (unlink(pathbuf))\n\t\t\tdie_errno(\"cannot unlink '%s'\", pathbuf);\n\t}\n\tclosedir(dir);\n\tif (rmdir(path))\n\t\tdie_errno(\"cannot rmdir '%s'\", path);\n}\n\nstatic int create_file(const char *path, unsigned int mode)\n{\n\tmode = (mode & 0100) ? 0777 : 0666;\n\treturn open(path, O_WRONLY | O_CREAT | O_EXCL, mode);\n}\n\nstatic void *read_blob_entry(struct cache_entry *ce, unsigned long *size)\n{\n\tenum object_type type;\n\tvoid *new = read_sha1_file(ce->sha1, &type, size);\n\n\tif (new) {\n\t\tif (type == OBJ_BLOB)\n\t\t\treturn new;\n\t\tfree(new);\n\t}\n\treturn NULL;\n}\n\nstatic int open_output_fd(char *path, struct cache_entry *ce, int to_tempfile)\n{\n\tint symlink = (ce->ce_mode & S_IFMT) != S_IFREG;\n\tif (to_tempfile) {\n\t\tstrcpy(path, symlink\n\t\t       ? \".merge_link_XXXXXX\" : \".merge_file_XXXXXX\");\n\t\treturn mkstemp(path);\n\t} else {\n\t\treturn create_file(path, !symlink ? ce->ce_mode : 0666);\n\t}\n}\n\nstatic int fstat_output(int fd, const struct checkout *state, struct stat *st)\n{\n\t/* use fstat() only when path == ce->name */\n\tif (fstat_is_reliable() &&\n\t    state->refresh_cache && !state->base_dir_len) {\n\t\tfstat(fd, st);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n",
  "static char *expand_namespace(const char *raw_namespace)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct strbuf **components, **c;\n\n\tif (!raw_namespace || !*raw_namespace)\n\t\treturn xstrdup(\"\");\n\n\tstrbuf_addstr(&buf, raw_namespace);\n\tcomponents = strbuf_split(&buf, '/');\n\tstrbuf_reset(&buf);\n\tfor (c = components; *c; c++)\n\t\tif (strcmp((*c)->buf, \"/\") != 0)\n\t\t\tstrbuf_addf(&buf, \"refs/namespaces/%s\", (*c)->buf);\n\tstrbuf_list_free(components);\n\tif (check_refname_format(buf.buf, 0))\n\t\tdie(_(\"bad git namespace path \\\"%s\\\"\"), raw_namespace);\n\tstrbuf_addch(&buf, '/');\n\treturn strbuf_detach(&buf, NULL);\n}\n\n/*\n * Wrapper of getenv() that returns a strdup value. This value is kept\n * in argv to be freed later.\n */\nstatic const char *getenv_safe(struct argv_array *argv, const char *name)\n{\n\tconst char *value = getenv(name);\n\n\tif (!value)\n\t\treturn NULL;\n\n\targv_array_push(argv, value);\n\treturn argv->argv[argv->argc - 1];\n}\n\nvoid setup_git_env(const char *git_dir)\n{\n\tconst char *shallow_file;\n\tconst char *replace_ref_base;\n\tstruct set_gitdir_args args = { NULL };\n\tstruct argv_array to_free = ARGV_ARRAY_INIT;\n\n\targs.commondir = getenv_safe(&to_free, GIT_COMMON_DIR_ENVIRONMENT);\n\targs.object_dir = getenv_safe(&to_free, DB_ENVIRONMENT);\n\targs.graft_file = getenv_safe(&to_free, GRAFT_ENVIRONMENT);\n\targs.index_file = getenv_safe(&to_free, INDEX_ENVIRONMENT);\n\targs.alternate_db = getenv_safe(&to_free, ALTERNATE_DB_ENVIRONMENT);\n\trepo_set_gitdir(the_repository, git_dir, &args);\n\targv_array_clear(&to_free);\n\n\tif (getenv(NO_REPLACE_OBJECTS_ENVIRONMENT))\n\t\tread_replace_refs = 0;\n\treplace_ref_base = getenv(GIT_REPLACE_REF_BASE_ENVIRONMENT);\n\tfree(git_replace_ref_base);\n\tgit_replace_ref_base = xstrdup(replace_ref_base ? replace_ref_base\n\t\t\t\t\t\t\t  : \"refs/replace/\");\n\tfree(git_namespace);\n\tgit_namespace = expand_namespace(getenv(GIT_NAMESPACE_ENVIRONMENT));\n\tshallow_file = getenv(GIT_SHALLOW_FILE_ENVIRONMENT);\n\tif (shallow_file)\n\t\tset_alternate_shallow_file(the_repository, shallow_file, 0);\n}\n\nint is_bare_repository(void)\n{\n\t/* if core.bare is not 'false', let's see if there is a work tree */\n\treturn is_bare_repository_cfg && !get_git_work_tree();\n}\n\nint have_git_dir(void)\n{\n\treturn startup_info->have_repository\n\t\t|| the_repository->gitdir;\n}\n\nconst char *get_git_dir(void)\n{\n\tif (!the_repository->gitdir)\n\t\tBUG(\"git environment hasn't been setup\");\n\treturn the_repository->gitdir;\n}\n\nconst char *get_git_common_dir(void)\n{\n\tif (!the_repository->commondir)\n\t\tBUG(\"git environment hasn't been setup\");\n\treturn the_repository->commondir;\n}\n\nconst char *get_git_namespace(void)\n{\n\tif (!git_namespace)\n\t\tBUG(\"git environment hasn't been setup\");\n\treturn git_namespace;\n}\n\nconst char *strip_namespace(const char *namespaced_ref)\n{\n\tconst char *out;\n\tif (skip_prefix(namespaced_ref, get_git_namespace(), &out))\n\t\treturn out;\n\treturn NULL;\n}\n\nconst char *get_super_prefix(void)\n{\n\tstatic int initialized;\n\tif (!initialized) {\n\t\tsuper_prefix = xstrdup_or_null(getenv(GIT_SUPER_PREFIX_ENVIRONMENT));\n\t\tinitialized = 1;\n\t}\n\treturn super_prefix;\n}\n\nstatic int git_work_tree_initialized;\n\n/*\n * Note.  This works only before you used a work tree.  This was added\n * primarily to support git-clone to work in a new repository it just\n * created, and is not meant to flip between different work trees.\n */\nvoid set_git_work_tree(const char *new_work_tree)\n{\n\tif (git_work_tree_initialized) {\n\t\tnew_work_tree = real_path(new_work_tree);\n\t\tif (strcmp(new_work_tree, the_repository->worktree))\n\t\t\tdie(\"internal error: work tree has already been set\\n\"\n\t\t\t    \"Current worktree: %s\\nNew worktree: %s\",\n\t\t\t    the_repository->worktree, new_work_tree);\n\t\treturn;\n\t}\n\tgit_work_tree_initialized = 1;\n\trepo_set_worktree(the_repository, new_work_tree);\n}\n\nconst char *get_git_work_tree(void)\n{\n\treturn the_repository->worktree;\n}\n\nchar *get_object_directory(void)\n{\n\tif (!the_repository->objects->odb)\n\t\tBUG(\"git environment hasn't been setup\");\n\treturn the_repository->objects->odb->path;\n}\n\nint odb_mkstemp(struct strbuf *temp_filename, const char *pattern)\n{\n\tint fd;\n\t/*\n\t * we let the umask do its job, don't try to be more\n\t * restrictive except to remove write permission.\n\t */\n\tint mode = 0444;\n\tgit_path_buf(temp_filename, \"objects/%s\", pattern);\n\tfd = git_mkstemp_mode(temp_filename->buf, mode);\n\tif (0 <= fd)\n\t\treturn fd;\n\n\t/* slow path */\n\t/* some mkstemp implementations erase temp_filename on failure */\n\tgit_path_buf(temp_filename, \"objects/%s\", pattern);\n\tsafe_create_leading_directories(temp_filename->buf);\n\treturn xmkstemp_mode(temp_filename->buf, mode);\n}\n",
  "static char *expand_namespace(const char *raw_namespace)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct strbuf **components, **c;\n\n\tif (!raw_namespace || !*raw_namespace)\n\t\treturn xstrdup(\"\");\n\n\tstrbuf_addstr(&buf, raw_namespace);\n\tcomponents = strbuf_split(&buf, '/');\n\tstrbuf_reset(&buf);\n\tfor (c = components; *c; c++)\n\t\tif (strcmp((*c)->buf, \"/\") != 0)\n\t\t\tstrbuf_addf(&buf, \"refs/namespaces/%s\", (*c)->buf);\n\tstrbuf_list_free(components);\n\tif (check_refname_format(buf.buf, 0))\n\t\tdie(_(\"bad git namespace path \\\"%s\\\"\"), raw_namespace);\n\tstrbuf_addch(&buf, '/');\n\treturn strbuf_detach(&buf, NULL);\n}\n\n/*\n * Wrapper of getenv() that returns a strdup value. This value is kept\n * in argv to be freed later.\n */\nstatic const char *getenv_safe(struct argv_array *argv, const char *name)\n{\n\tconst char *value = getenv(name);\n\n\tif (!value)\n\t\treturn NULL;\n\n\targv_array_push(argv, value);\n\treturn argv->argv[argv->argc - 1];\n}\n\nvoid setup_git_env(const char *git_dir)\n{\n\tconst char *shallow_file;\n\tconst char *replace_ref_base;\n\tstruct set_gitdir_args args = { NULL };\n\tstruct argv_array to_free = ARGV_ARRAY_INIT;\n\n\targs.commondir = getenv_safe(&to_free, GIT_COMMON_DIR_ENVIRONMENT);\n\targs.object_dir = getenv_safe(&to_free, DB_ENVIRONMENT);\n\targs.graft_file = getenv_safe(&to_free, GRAFT_ENVIRONMENT);\n\targs.index_file = getenv_safe(&to_free, INDEX_ENVIRONMENT);\n\targs.alternate_db = getenv_safe(&to_free, ALTERNATE_DB_ENVIRONMENT);\n\trepo_set_gitdir(the_repository, git_dir, &args);\n\targv_array_clear(&to_free);\n\n\tif (getenv(NO_REPLACE_OBJECTS_ENVIRONMENT))\n\t\tread_replace_refs = 0;\n\treplace_ref_base = getenv(GIT_REPLACE_REF_BASE_ENVIRONMENT);\n\tfree(git_replace_ref_base);\n\tgit_replace_ref_base = xstrdup(replace_ref_base ? replace_ref_base\n\t\t\t\t\t\t\t  : \"refs/replace/\");\n\tfree(git_namespace);\n\tgit_namespace = expand_namespace(getenv(GIT_NAMESPACE_ENVIRONMENT));\n\tshallow_file = getenv(GIT_SHALLOW_FILE_ENVIRONMENT);\n\tif (shallow_file)\n\t\tset_alternate_shallow_file(the_repository, shallow_file, 0);\n}\n\nint is_bare_repository(void)\n{\n\t/* if core.bare is not 'false', let's see if there is a work tree */\n\treturn is_bare_repository_cfg && !get_git_work_tree();\n}\n\nint have_git_dir(void)\n{\n\treturn startup_info->have_repository\n\t\t|| the_repository->gitdir;\n}\n\nconst char *get_git_dir(void)\n{\n\tif (!the_repository->gitdir)\n\t\tBUG(\"git environment hasn't been setup\");\n\treturn the_repository->gitdir;\n}\n\nconst char *get_git_common_dir(void)\n{\n\tif (!the_repository->commondir)\n\t\tBUG(\"git environment hasn't been setup\");\n\treturn the_repository->commondir;\n}\n\nconst char *get_git_namespace(void)\n{\n\tif (!git_namespace)\n\t\tBUG(\"git environment hasn't been setup\");\n\treturn git_namespace;\n}\n\nconst char *strip_namespace(const char *namespaced_ref)\n{\n\tconst char *out;\n\tif (skip_prefix(namespaced_ref, get_git_namespace(), &out))\n\t\treturn out;\n\treturn NULL;\n}\n\nconst char *get_super_prefix(void)\n{\n\tstatic int initialized;\n\tif (!initialized) {\n\t\tsuper_prefix = xstrdup_or_null(getenv(GIT_SUPER_PREFIX_ENVIRONMENT));\n\t\tinitialized = 1;\n\t}\n\treturn super_prefix;\n}\n\nstatic int git_work_tree_initialized;\n\n/*\n * Note.  This works only before you used a work tree.  This was added\n * primarily to support git-clone to work in a new repository it just\n * created, and is not meant to flip between different work trees.\n */\nvoid set_git_work_tree(const char *new_work_tree)\n{\n\tif (git_work_tree_initialized) {\n\t\tnew_work_tree = real_path(new_work_tree);\n\t\tif (strcmp(new_work_tree, the_repository->worktree))\n\t\t\tdie(\"internal error: work tree has already been set\\n\"\n\t\t\t    \"Current worktree: %s\\nNew worktree: %s\",\n\t\t\t    the_repository->worktree, new_work_tree);\n\t\treturn;\n\t}\n\tgit_work_tree_initialized = 1;\n\trepo_set_worktree(the_repository, new_work_tree);\n}\n\nconst char *get_git_work_tree(void)\n{\n\treturn the_repository->worktree;\n}\n\nchar *get_object_directory(void)\n{\n\tif (!the_repository->objects->objectdir)\n\t\tBUG(\"git environment hasn't been setup\");\n\treturn the_repository->objects->objectdir;\n}\n\nint odb_mkstemp(struct strbuf *temp_filename, const char *pattern)\n{\n\tint fd;\n\t/*\n\t * we let the umask do its job, don't try to be more\n\t * restrictive except to remove write permission.\n\t */\n\tint mode = 0444;\n\tgit_path_buf(temp_filename, \"objects/%s\", pattern);\n\tfd = git_mkstemp_mode(temp_filename->buf, mode);\n\tif (0 <= fd)\n\t\treturn fd;\n\n\t/* slow path */\n\t/* some mkstemp implementations erase temp_filename on failure */\n\tgit_path_buf(temp_filename, \"objects/%s\", pattern);\n\tsafe_create_leading_directories(temp_filename->buf);\n\treturn xmkstemp_mode(temp_filename->buf, mode);\n}\n",
  "static char *expand_namespace(const char *raw_namespace)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct strbuf **components, **c;\n\n\tif (!raw_namespace || !*raw_namespace)\n\t\treturn xstrdup(\"\");\n\n\tstrbuf_addstr(&buf, raw_namespace);\n\tcomponents = strbuf_split(&buf, '/');\n\tstrbuf_reset(&buf);\n\tfor (c = components; *c; c++)\n\t\tif (strcmp((*c)->buf, \"/\") != 0)\n\t\t\tstrbuf_addf(&buf, \"refs/namespaces/%s\", (*c)->buf);\n\tstrbuf_list_free(components);\n\tif (check_refname_format(buf.buf, 0))\n\t\tdie(_(\"bad git namespace path \\\"%s\\\"\"), raw_namespace);\n\tstrbuf_addch(&buf, '/');\n\treturn strbuf_detach(&buf, NULL);\n}\n\n/*\n * Wrapper of getenv() that returns a strdup value. This value is kept\n * in argv to be freed later.\n */\nstatic const char *getenv_safe(struct argv_array *argv, const char *name)\n{\n\tconst char *value = getenv(name);\n\n\tif (!value)\n\t\treturn NULL;\n\n\targv_array_push(argv, value);\n\treturn argv->argv[argv->argc - 1];\n}\n\nvoid setup_git_env(const char *git_dir)\n{\n\tconst char *shallow_file;\n\tconst char *replace_ref_base;\n\tstruct set_gitdir_args args = { NULL };\n\tstruct argv_array to_free = ARGV_ARRAY_INIT;\n\n\targs.commondir = getenv_safe(&to_free, GIT_COMMON_DIR_ENVIRONMENT);\n\targs.object_dir = getenv_safe(&to_free, DB_ENVIRONMENT);\n\targs.graft_file = getenv_safe(&to_free, GRAFT_ENVIRONMENT);\n\targs.index_file = getenv_safe(&to_free, INDEX_ENVIRONMENT);\n\targs.alternate_db = getenv_safe(&to_free, ALTERNATE_DB_ENVIRONMENT);\n\trepo_set_gitdir(the_repository, git_dir, &args);\n\targv_array_clear(&to_free);\n\n\tif (getenv(NO_REPLACE_OBJECTS_ENVIRONMENT))\n\t\tread_replace_refs = 0;\n\treplace_ref_base = getenv(GIT_REPLACE_REF_BASE_ENVIRONMENT);\n\tfree(git_replace_ref_base);\n\tgit_replace_ref_base = xstrdup(replace_ref_base ? replace_ref_base\n\t\t\t\t\t\t\t  : \"refs/replace/\");\n\tfree(git_namespace);\n\tgit_namespace = expand_namespace(getenv(GIT_NAMESPACE_ENVIRONMENT));\n\tshallow_file = getenv(GIT_SHALLOW_FILE_ENVIRONMENT);\n\tif (shallow_file)\n\t\tset_alternate_shallow_file(the_repository, shallow_file, 0);\n}\n\nint is_bare_repository(void)\n{\n\t/* if core.bare is not 'false', let's see if there is a work tree */\n\treturn is_bare_repository_cfg && !get_git_work_tree();\n}\n\nint have_git_dir(void)\n{\n\treturn startup_info->have_repository\n\t\t|| the_repository->gitdir;\n}\n\nconst char *get_git_dir(void)\n{\n\tif (!the_repository->gitdir)\n\t\tBUG(\"git environment hasn't been setup\");\n\treturn the_repository->gitdir;\n}\n\nconst char *get_git_common_dir(void)\n{\n\tif (!the_repository->commondir)\n\t\tBUG(\"git environment hasn't been setup\");\n\treturn the_repository->commondir;\n}\n\nconst char *get_git_namespace(void)\n{\n\tif (!git_namespace)\n\t\tBUG(\"git environment hasn't been setup\");\n\treturn git_namespace;\n}\n\nconst char *strip_namespace(const char *namespaced_ref)\n{\n\tconst char *out;\n\tif (skip_prefix(namespaced_ref, get_git_namespace(), &out))\n\t\treturn out;\n\treturn NULL;\n}\n\nconst char *get_super_prefix(void)\n{\n\tstatic int initialized;\n\tif (!initialized) {\n\t\tsuper_prefix = getenv(GIT_SUPER_PREFIX_ENVIRONMENT);\n\t\tinitialized = 1;\n\t}\n\treturn super_prefix;\n}\n\nstatic int git_work_tree_initialized;\n\n/*\n * Note.  This works only before you used a work tree.  This was added\n * primarily to support git-clone to work in a new repository it just\n * created, and is not meant to flip between different work trees.\n */\nvoid set_git_work_tree(const char *new_work_tree)\n{\n\tif (git_work_tree_initialized) {\n\t\tnew_work_tree = real_path(new_work_tree);\n\t\tif (strcmp(new_work_tree, the_repository->worktree))\n\t\t\tdie(\"internal error: work tree has already been set\\n\"\n\t\t\t    \"Current worktree: %s\\nNew worktree: %s\",\n\t\t\t    the_repository->worktree, new_work_tree);\n\t\treturn;\n\t}\n\tgit_work_tree_initialized = 1;\n\trepo_set_worktree(the_repository, new_work_tree);\n}\n\nconst char *get_git_work_tree(void)\n{\n\treturn the_repository->worktree;\n}\n\nchar *get_object_directory(void)\n{\n\tif (!the_repository->objects->odb)\n\t\tBUG(\"git environment hasn't been setup\");\n\treturn the_repository->objects->odb->path;\n}\n\nint odb_mkstemp(struct strbuf *temp_filename, const char *pattern)\n{\n\tint fd;\n\t/*\n\t * we let the umask do its job, don't try to be more\n\t * restrictive except to remove write permission.\n\t */\n\tint mode = 0444;\n\tgit_path_buf(temp_filename, \"objects/%s\", pattern);\n\tfd = git_mkstemp_mode(temp_filename->buf, mode);\n\tif (0 <= fd)\n\t\treturn fd;\n\n\t/* slow path */\n\t/* some mkstemp implementations erase temp_filename on failure */\n\tgit_path_buf(temp_filename, \"objects/%s\", pattern);\n\tsafe_create_leading_directories(temp_filename->buf);\n\treturn xmkstemp_mode(temp_filename->buf, mode);\n}",
  "static char *expand_namespace(const char *raw_namespace)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct strbuf **components, **c;\n\n\tif (!raw_namespace || !*raw_namespace)\n\t\treturn xstrdup(\"\");\n\n\tstrbuf_addstr(&buf, raw_namespace);\n\tcomponents = strbuf_split(&buf, '/');\n\tstrbuf_reset(&buf);\n\tfor (c = components; *c; c++)\n\t\tif (strcmp((*c)->buf, \"/\") != 0)\n\t\t\tstrbuf_addf(&buf, \"refs/namespaces/%s\", (*c)->buf);\n\tstrbuf_list_free(components);\n\tif (check_refname_format(buf.buf, 0))\n\t\tdie(\"bad git namespace path \\\"%s\\\"\", raw_namespace);\n\tstrbuf_addch(&buf, '/');\n\treturn strbuf_detach(&buf, NULL);\n}\n\n/*\n * Wrapper of getenv() that returns a strdup value. This value is kept\n * in argv to be freed later.\n */\nstatic const char *getenv_safe(struct argv_array *argv, const char *name)\n{\n\tconst char *value = getenv(name);\n\n\tif (!value)\n\t\treturn NULL;\n\n\targv_array_push(argv, value);\n\treturn argv->argv[argv->argc - 1];\n}\n\nvoid setup_git_env(const char *git_dir)\n{\n\tconst char *shallow_file;\n\tconst char *replace_ref_base;\n\tstruct set_gitdir_args args = { NULL };\n\tstruct argv_array to_free = ARGV_ARRAY_INIT;\n\n\targs.commondir = getenv_safe(&to_free, GIT_COMMON_DIR_ENVIRONMENT);\n\targs.object_dir = getenv_safe(&to_free, DB_ENVIRONMENT);\n\targs.graft_file = getenv_safe(&to_free, GRAFT_ENVIRONMENT);\n\targs.index_file = getenv_safe(&to_free, INDEX_ENVIRONMENT);\n\targs.alternate_db = getenv_safe(&to_free, ALTERNATE_DB_ENVIRONMENT);\n\trepo_set_gitdir(the_repository, git_dir, &args);\n\targv_array_clear(&to_free);\n\n\tif (getenv(NO_REPLACE_OBJECTS_ENVIRONMENT))\n\t\tcheck_replace_refs = 0;\n\treplace_ref_base = getenv(GIT_REPLACE_REF_BASE_ENVIRONMENT);\n\tfree(git_replace_ref_base);\n\tgit_replace_ref_base = xstrdup(replace_ref_base ? replace_ref_base\n\t\t\t\t\t\t\t  : \"refs/replace/\");\n\tfree(git_namespace);\n\tgit_namespace = expand_namespace(getenv(GIT_NAMESPACE_ENVIRONMENT));\n\tshallow_file = getenv(GIT_SHALLOW_FILE_ENVIRONMENT);\n\tif (shallow_file)\n\t\tset_alternate_shallow_file(shallow_file, 0);\n}\n\nint is_bare_repository(void)\n{\n\t/* if core.bare is not 'false', let's see if there is a work tree */\n\treturn is_bare_repository_cfg && !get_git_work_tree();\n}\n\nint have_git_dir(void)\n{\n\treturn startup_info->have_repository\n\t\t|| the_repository->gitdir;\n}\n\nconst char *get_git_dir(void)\n{\n\tif (!the_repository->gitdir)\n\t\tBUG(\"git environment hasn't been setup\");\n\treturn the_repository->gitdir;\n}\n\nconst char *get_git_common_dir(void)\n{\n\tif (!the_repository->commondir)\n\t\tBUG(\"git environment hasn't been setup\");\n\treturn the_repository->commondir;\n}\n\nconst char *get_git_namespace(void)\n{\n\tif (!git_namespace)\n\t\tBUG(\"git environment hasn't been setup\");\n\treturn git_namespace;\n}\n\nconst char *strip_namespace(const char *namespaced_ref)\n{\n\tconst char *out;\n\tif (skip_prefix(namespaced_ref, get_git_namespace(), &out))\n\t\treturn out;\n\treturn NULL;\n}\n\nconst char *get_super_prefix(void)\n{\n\tstatic int initialized;\n\tif (!initialized) {\n\t\tsuper_prefix = getenv(GIT_SUPER_PREFIX_ENVIRONMENT);\n\t\tinitialized = 1;\n\t}\n\treturn super_prefix;\n}\n\nstatic int git_work_tree_initialized;\n\n/*\n * Note.  This works only before you used a work tree.  This was added\n * primarily to support git-clone to work in a new repository it just\n * created, and is not meant to flip between different work trees.\n */\nvoid set_git_work_tree(const char *new_work_tree)\n{\n\tif (git_work_tree_initialized) {\n\t\tnew_work_tree = real_path(new_work_tree);\n\t\tif (strcmp(new_work_tree, the_repository->worktree))\n\t\t\tdie(\"internal error: work tree has already been set\\n\"\n\t\t\t    \"Current worktree: %s\\nNew worktree: %s\",\n\t\t\t    the_repository->worktree, new_work_tree);\n\t\treturn;\n\t}\n\tgit_work_tree_initialized = 1;\n\trepo_set_worktree(the_repository, new_work_tree);\n}\n\nconst char *get_git_work_tree(void)\n{\n\treturn the_repository->worktree;\n}\n\nchar *get_object_directory(void)\n{\n\tif (!the_repository->objects->objectdir)\n\t\tBUG(\"git environment hasn't been setup\");\n\treturn the_repository->objects->objectdir;\n}\n\nint odb_mkstemp(struct strbuf *temp_filename, const char *pattern)\n{\n\tint fd;\n\t/*\n\t * we let the umask do its job, don't try to be more\n\t * restrictive except to remove write permission.\n\t */\n\tint mode = 0444;\n\tgit_path_buf(temp_filename, \"objects/%s\", pattern);\n\tfd = git_mkstemp_mode(temp_filename->buf, mode);\n\tif (0 <= fd)\n\t\treturn fd;\n\n\t/* slow path */\n\t/* some mkstemp implementations erase temp_filename on failure */\n\tgit_path_buf(temp_filename, \"objects/%s\", pattern);\n\tsafe_create_leading_directories(temp_filename->buf);\n\treturn xmkstemp_mode(temp_filename->buf, mode);\n}",
  "static char *expand_namespace(const char *raw_namespace)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct strbuf **components, **c;\n\n\tif (!raw_namespace || !*raw_namespace)\n\t\treturn xstrdup(\"\");\n\n\tstrbuf_addstr(&buf, raw_namespace);\n\tcomponents = strbuf_split(&buf, '/');\n\tstrbuf_reset(&buf);\n\tfor (c = components; *c; c++)\n\t\tif (strcmp((*c)->buf, \"/\") != 0)\n\t\t\tstrbuf_addf(&buf, \"refs/namespaces/%s\", (*c)->buf);\n\tstrbuf_list_free(components);\n\tif (check_refname_format(buf.buf, 0))\n\t\tdie(\"bad git namespace path \\\"%s\\\"\", raw_namespace);\n\tstrbuf_addch(&buf, '/');\n\treturn strbuf_detach(&buf, NULL);\n}\n\nvoid setup_git_env(void)\n{\n\tconst char *shallow_file;\n\tconst char *replace_ref_base;\n\n\tif (getenv(NO_REPLACE_OBJECTS_ENVIRONMENT))\n\t\tcheck_replace_refs = 0;\n\treplace_ref_base = getenv(GIT_REPLACE_REF_BASE_ENVIRONMENT);\n\tfree(git_replace_ref_base);\n\tgit_replace_ref_base = xstrdup(replace_ref_base ? replace_ref_base\n\t\t\t\t\t\t\t  : \"refs/replace/\");\n\tfree(namespace);\n\tnamespace = expand_namespace(getenv(GIT_NAMESPACE_ENVIRONMENT));\n\tshallow_file = getenv(GIT_SHALLOW_FILE_ENVIRONMENT);\n\tif (shallow_file)\n\t\tset_alternate_shallow_file(shallow_file, 0);\n}\n\nint is_bare_repository(void)\n{\n\t/* if core.bare is not 'false', let's see if there is a work tree */\n\treturn is_bare_repository_cfg && !get_git_work_tree();\n}\n\nint have_git_dir(void)\n{\n\treturn startup_info->have_repository\n\t\t|| the_repository->gitdir;\n}\n\nconst char *get_git_dir(void)\n{\n\tif (!the_repository->gitdir)\n\t\tBUG(\"git environment hasn't been setup\");\n\treturn the_repository->gitdir;\n}\n\nconst char *get_git_common_dir(void)\n{\n\tif (!the_repository->commondir)\n\t\tBUG(\"git environment hasn't been setup\");\n\treturn the_repository->commondir;\n}\n\nconst char *get_git_namespace(void)\n{\n\tif (!namespace)\n\t\tBUG(\"git environment hasn't been setup\");\n\treturn namespace;\n}\n\nconst char *strip_namespace(const char *namespaced_ref)\n{\n\tconst char *out;\n\tif (skip_prefix(namespaced_ref, get_git_namespace(), &out))\n\t\treturn out;\n\treturn NULL;\n}\n\nconst char *get_super_prefix(void)\n{\n\tstatic int initialized;\n\tif (!initialized) {\n\t\tsuper_prefix = getenv(GIT_SUPER_PREFIX_ENVIRONMENT);\n\t\tinitialized = 1;\n\t}\n\treturn super_prefix;\n}\n\nstatic int git_work_tree_initialized;\n\n/*\n * Note.  This works only before you used a work tree.  This was added\n * primarily to support git-clone to work in a new repository it just\n * created, and is not meant to flip between different work trees.\n */\nvoid set_git_work_tree(const char *new_work_tree)\n{\n\tif (git_work_tree_initialized) {\n\t\tnew_work_tree = real_path(new_work_tree);\n\t\tif (strcmp(new_work_tree, the_repository->worktree))\n\t\t\tdie(\"internal error: work tree has already been set\\n\"\n\t\t\t    \"Current worktree: %s\\nNew worktree: %s\",\n\t\t\t    the_repository->worktree, new_work_tree);\n\t\treturn;\n\t}\n\tgit_work_tree_initialized = 1;\n\trepo_set_worktree(the_repository, new_work_tree);\n}\n\nconst char *get_git_work_tree(void)\n{\n\treturn the_repository->worktree;\n}\n\nchar *get_object_directory(void)\n{\n\tif (!the_repository->objectdir)\n\t\tBUG(\"git environment hasn't been setup\");\n\treturn the_repository->objectdir;\n}\n\nint odb_mkstemp(struct strbuf *template, const char *pattern)\n{\n\tint fd;\n\t/*\n\t * we let the umask do its job, don't try to be more\n\t * restrictive except to remove write permission.\n\t */\n\tint mode = 0444;\n\tgit_path_buf(template, \"objects/%s\", pattern);\n\tfd = git_mkstemp_mode(template->buf, mode);\n\tif (0 <= fd)\n\t\treturn fd;\n\n\t/* slow path */\n\t/* some mkstemp implementations erase template on failure */\n\tgit_path_buf(template, \"objects/%s\", pattern);\n\tsafe_create_leading_directories(template->buf);\n\treturn xmkstemp_mode(template->buf, mode);\n}",
  "static char *expand_namespace(const char *raw_namespace)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct strbuf **components, **c;\n\n\tif (!raw_namespace || !*raw_namespace)\n\t\treturn xstrdup(\"\");\n\n\tstrbuf_addstr(&buf, raw_namespace);\n\tcomponents = strbuf_split(&buf, '/');\n\tstrbuf_reset(&buf);\n\tfor (c = components; *c; c++)\n\t\tif (strcmp((*c)->buf, \"/\") != 0)\n\t\t\tstrbuf_addf(&buf, \"refs/namespaces/%s\", (*c)->buf);\n\tstrbuf_list_free(components);\n\tif (check_refname_format(buf.buf, 0))\n\t\tdie(\"bad git namespace path \\\"%s\\\"\", raw_namespace);\n\tstrbuf_addch(&buf, '/');\n\treturn strbuf_detach(&buf, NULL);\n}\n\nstatic char *git_path_from_env(const char *envvar, const char *git_dir,\n\t\t\t       const char *path, int *fromenv)\n{\n\tconst char *value = getenv(envvar);\n\tif (!value)\n\t\treturn xstrfmt(\"%s/%s\", git_dir, path);\n\tif (fromenv)\n\t\t*fromenv = 1;\n\treturn xstrdup(value);\n}\n\nvoid setup_git_env(void)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\tconst char *gitfile;\n\tconst char *shallow_file;\n\tconst char *replace_ref_base;\n\n\tgit_dir = getenv(GIT_DIR_ENVIRONMENT);\n\tif (!git_dir) {\n\t\tif (!startup_info->have_repository)\n\t\t\tBUG(\"setup_git_env called without repository\");\n\t\tgit_dir = DEFAULT_GIT_DIR_ENVIRONMENT;\n\t}\n\tgitfile = read_gitfile(git_dir);\n\tgit_dir = xstrdup(gitfile ? gitfile : git_dir);\n\tif (get_common_dir(&sb, git_dir))\n\t\tgit_common_dir_env = 1;\n\tgit_common_dir = strbuf_detach(&sb, NULL);\n\tgit_object_dir = git_path_from_env(DB_ENVIRONMENT, git_common_dir,\n\t\t\t\t\t   \"objects\", &git_db_env);\n\tgit_index_file = git_path_from_env(INDEX_ENVIRONMENT, git_dir,\n\t\t\t\t\t   \"index\", &git_index_env);\n\tgit_graft_file = git_path_from_env(GRAFT_ENVIRONMENT, git_common_dir,\n\t\t\t\t\t   \"info/grafts\", &git_graft_env);\n\tif (getenv(NO_REPLACE_OBJECTS_ENVIRONMENT))\n\t\tcheck_replace_refs = 0;\n\treplace_ref_base = getenv(GIT_REPLACE_REF_BASE_ENVIRONMENT);\n\tgit_replace_ref_base = xstrdup(replace_ref_base ? replace_ref_base\n\t\t\t\t\t\t\t  : \"refs/replace/\");\n\tnamespace = expand_namespace(getenv(GIT_NAMESPACE_ENVIRONMENT));\n\tnamespace_len = strlen(namespace);\n\tshallow_file = getenv(GIT_SHALLOW_FILE_ENVIRONMENT);\n\tif (shallow_file)\n\t\tset_alternate_shallow_file(shallow_file, 0);\n}\n\nint is_bare_repository(void)\n{\n\t/* if core.bare is not 'false', let's see if there is a work tree */\n\treturn is_bare_repository_cfg && !get_git_work_tree();\n}\n\nint have_git_dir(void)\n{\n\treturn startup_info->have_repository\n\t\t|| git_dir;\n}\n\nconst char *get_git_dir(void)\n{\n\tif (!git_dir)\n\t\tBUG(\"git environment hasn't been setup\");\n\treturn git_dir;\n}\n\nconst char *get_git_common_dir(void)\n{\n\tif (!git_dir)\n\t\tBUG(\"git environment hasn't been setup\");\n\treturn git_common_dir;\n}\n\nconst char *get_git_namespace(void)\n{\n\tif (!namespace)\n\t\tBUG(\"git environment hasn't been setup\");\n\treturn namespace;\n}\n\nconst char *strip_namespace(const char *namespaced_ref)\n{\n\tif (!starts_with(namespaced_ref, get_git_namespace()))\n\t\treturn NULL;\n\treturn namespaced_ref + namespace_len;\n}\n\nconst char *get_super_prefix(void)\n{\n\tstatic int initialized;\n\tif (!initialized) {\n\t\tsuper_prefix = getenv(GIT_SUPER_PREFIX_ENVIRONMENT);\n\t\tinitialized = 1;\n\t}\n\treturn super_prefix;\n}\n\nstatic int git_work_tree_initialized;\n\n/*\n * Note.  This works only before you used a work tree.  This was added\n * primarily to support git-clone to work in a new repository it just\n * created, and is not meant to flip between different work trees.\n */\nvoid set_git_work_tree(const char *new_work_tree)\n{\n\tif (git_work_tree_initialized) {\n\t\tnew_work_tree = real_path(new_work_tree);\n\t\tif (strcmp(new_work_tree, work_tree))\n\t\t\tdie(\"internal error: work tree has already been set\\n\"\n\t\t\t    \"Current worktree: %s\\nNew worktree: %s\",\n\t\t\t    work_tree, new_work_tree);\n\t\treturn;\n\t}\n\tgit_work_tree_initialized = 1;\n\twork_tree = real_pathdup(new_work_tree, 1);\n}\n\nconst char *get_git_work_tree(void)\n{\n\treturn work_tree;\n}\n\nchar *get_object_directory(void)\n{\n\tif (!git_object_dir)\n\t\tBUG(\"git environment hasn't been setup\");\n\treturn git_object_dir;\n}\n\nint odb_mkstemp(struct strbuf *template, const char *pattern)\n{\n\tint fd;\n\t/*\n\t * we let the umask do its job, don't try to be more\n\t * restrictive except to remove write permission.\n\t */\n\tint mode = 0444;\n\tgit_path_buf(template, \"objects/%s\", pattern);\n\tfd = git_mkstemp_mode(template->buf, mode);\n\tif (0 <= fd)\n\t\treturn fd;\n\n\t/* slow path */\n\t/* some mkstemp implementations erase template on failure */\n\tgit_path_buf(template, \"objects/%s\", pattern);\n\tsafe_create_leading_directories(template->buf);\n\treturn xmkstemp_mode(template->buf, mode);\n}\n",
  "static char *expand_namespace(const char *raw_namespace)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct strbuf **components, **c;\n\n\tif (!raw_namespace || !*raw_namespace)\n\t\treturn xstrdup(\"\");\n\n\tstrbuf_addstr(&buf, raw_namespace);\n\tcomponents = strbuf_split(&buf, '/');\n\tstrbuf_reset(&buf);\n\tfor (c = components; *c; c++)\n\t\tif (strcmp((*c)->buf, \"/\") != 0)\n\t\t\tstrbuf_addf(&buf, \"refs/namespaces/%s\", (*c)->buf);\n\tstrbuf_list_free(components);\n\tif (check_refname_format(buf.buf, 0))\n\t\tdie(\"bad git namespace path \\\"%s\\\"\", raw_namespace);\n\tstrbuf_addch(&buf, '/');\n\treturn strbuf_detach(&buf, NULL);\n}\n\nstatic char *git_path_from_env(const char *envvar, const char *git_dir,\n\t\t\t       const char *path, int *fromenv)\n{\n\tconst char *value = getenv(envvar);\n\tif (!value)\n\t\treturn xstrfmt(\"%s/%s\", git_dir, path);\n\tif (fromenv)\n\t\t*fromenv = 1;\n\treturn xstrdup(value);\n}\n\nstatic void setup_git_env(void)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\tconst char *gitfile;\n\tconst char *shallow_file;\n\tconst char *replace_ref_base;\n\n\tgit_dir = getenv(GIT_DIR_ENVIRONMENT);\n\tif (!git_dir) {\n\t\tif (!startup_info->have_repository)\n\t\t\tdie(\"BUG: setup_git_env called without repository\");\n\t\tgit_dir = DEFAULT_GIT_DIR_ENVIRONMENT;\n\t}\n\tgitfile = read_gitfile(git_dir);\n\tgit_dir = xstrdup(gitfile ? gitfile : git_dir);\n\tif (get_common_dir(&sb, git_dir))\n\t\tgit_common_dir_env = 1;\n\tgit_common_dir = strbuf_detach(&sb, NULL);\n\tgit_object_dir = git_path_from_env(DB_ENVIRONMENT, git_common_dir,\n\t\t\t\t\t   \"objects\", &git_db_env);\n\tgit_index_file = git_path_from_env(INDEX_ENVIRONMENT, git_dir,\n\t\t\t\t\t   \"index\", &git_index_env);\n\tgit_graft_file = git_path_from_env(GRAFT_ENVIRONMENT, git_common_dir,\n\t\t\t\t\t   \"info/grafts\", &git_graft_env);\n\tif (getenv(NO_REPLACE_OBJECTS_ENVIRONMENT))\n\t\tcheck_replace_refs = 0;\n\treplace_ref_base = getenv(GIT_REPLACE_REF_BASE_ENVIRONMENT);\n\tgit_replace_ref_base = xstrdup(replace_ref_base ? replace_ref_base\n\t\t\t\t\t\t\t  : \"refs/replace/\");\n\tnamespace = expand_namespace(getenv(GIT_NAMESPACE_ENVIRONMENT));\n\tnamespace_len = strlen(namespace);\n\tshallow_file = getenv(GIT_SHALLOW_FILE_ENVIRONMENT);\n\tif (shallow_file)\n\t\tset_alternate_shallow_file(shallow_file, 0);\n}\n\nint is_bare_repository(void)\n{\n\t/* if core.bare is not 'false', let's see if there is a work tree */\n\treturn is_bare_repository_cfg && !get_git_work_tree();\n}\n\nint have_git_dir(void)\n{\n\treturn startup_info->have_repository\n\t\t|| git_dir\n\t\t|| getenv(GIT_DIR_ENVIRONMENT);\n}\n\nconst char *get_git_dir(void)\n{\n\tif (!git_dir)\n\t\tsetup_git_env();\n\treturn git_dir;\n}\n\nconst char *get_git_common_dir(void)\n{\n\treturn git_common_dir;\n}\n\nconst char *get_git_namespace(void)\n{\n\tif (!namespace)\n\t\tsetup_git_env();\n\treturn namespace;\n}\n\nconst char *strip_namespace(const char *namespaced_ref)\n{\n\tif (!starts_with(namespaced_ref, get_git_namespace()))\n\t\treturn NULL;\n\treturn namespaced_ref + namespace_len;\n}\n\nconst char *get_super_prefix(void)\n{\n\tstatic int initialized;\n\tif (!initialized) {\n\t\tsuper_prefix = getenv(GIT_SUPER_PREFIX_ENVIRONMENT);\n\t\tinitialized = 1;\n\t}\n\treturn super_prefix;\n}\n\nstatic int git_work_tree_initialized;\n\n/*\n * Note.  This works only before you used a work tree.  This was added\n * primarily to support git-clone to work in a new repository it just\n * created, and is not meant to flip between different work trees.\n */\nvoid set_git_work_tree(const char *new_work_tree)\n{\n\tif (git_work_tree_initialized) {\n\t\tnew_work_tree = real_path(new_work_tree);\n\t\tif (strcmp(new_work_tree, work_tree))\n\t\t\tdie(\"internal error: work tree has already been set\\n\"\n\t\t\t    \"Current worktree: %s\\nNew worktree: %s\",\n\t\t\t    work_tree, new_work_tree);\n\t\treturn;\n\t}\n\tgit_work_tree_initialized = 1;\n\twork_tree = real_pathdup(new_work_tree, 1);\n}\n\nconst char *get_git_work_tree(void)\n{\n\treturn work_tree;\n}\n\nchar *get_object_directory(void)\n{\n\tif (!git_object_dir)\n\t\tsetup_git_env();\n\treturn git_object_dir;\n}\n\nint odb_mkstemp(struct strbuf *template, const char *pattern)\n{\n\tint fd;\n\t/*\n\t * we let the umask do its job, don't try to be more\n\t * restrictive except to remove write permission.\n\t */\n\tint mode = 0444;\n\tgit_path_buf(template, \"objects/%s\", pattern);\n\tfd = git_mkstemp_mode(template->buf, mode);\n\tif (0 <= fd)\n\t\treturn fd;\n\n\t/* slow path */\n\t/* some mkstemp implementations erase template on failure */\n\tgit_path_buf(template, \"objects/%s\", pattern);\n\tsafe_create_leading_directories(template->buf);\n\treturn xmkstemp_mode(template->buf, mode);\n}",
  "static char *expand_namespace(const char *raw_namespace)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct strbuf **components, **c;\n\n\tif (!raw_namespace || !*raw_namespace)\n\t\treturn xstrdup(\"\");\n\n\tstrbuf_addstr(&buf, raw_namespace);\n\tcomponents = strbuf_split(&buf, '/');\n\tstrbuf_reset(&buf);\n\tfor (c = components; *c; c++)\n\t\tif (strcmp((*c)->buf, \"/\") != 0)\n\t\t\tstrbuf_addf(&buf, \"refs/namespaces/%s\", (*c)->buf);\n\tstrbuf_list_free(components);\n\tif (check_refname_format(buf.buf, 0))\n\t\tdie(\"bad git namespace path \\\"%s\\\"\", raw_namespace);\n\tstrbuf_addch(&buf, '/');\n\treturn strbuf_detach(&buf, NULL);\n}\n\nstatic char *git_path_from_env(const char *envvar, const char *git_dir,\n\t\t\t       const char *path, int *fromenv)\n{\n\tconst char *value = getenv(envvar);\n\tif (!value)\n\t\treturn xstrfmt(\"%s/%s\", git_dir, path);\n\tif (fromenv)\n\t\t*fromenv = 1;\n\treturn xstrdup(value);\n}\n\nstatic void setup_git_env(void)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\tconst char *gitfile;\n\tconst char *shallow_file;\n\tconst char *replace_ref_base;\n\n\tgit_dir = getenv(GIT_DIR_ENVIRONMENT);\n\tif (!git_dir)\n\t\tgit_dir = DEFAULT_GIT_DIR_ENVIRONMENT;\n\tgitfile = read_gitfile(git_dir);\n\tgit_dir = xstrdup(gitfile ? gitfile : git_dir);\n\tif (get_common_dir(&sb, git_dir))\n\t\tgit_common_dir_env = 1;\n\tgit_common_dir = strbuf_detach(&sb, NULL);\n\tgit_object_dir = git_path_from_env(DB_ENVIRONMENT, git_common_dir,\n\t\t\t\t\t   \"objects\", &git_db_env);\n\tgit_index_file = git_path_from_env(INDEX_ENVIRONMENT, git_dir,\n\t\t\t\t\t   \"index\", &git_index_env);\n\tgit_graft_file = git_path_from_env(GRAFT_ENVIRONMENT, git_common_dir,\n\t\t\t\t\t   \"info/grafts\", &git_graft_env);\n\tif (getenv(NO_REPLACE_OBJECTS_ENVIRONMENT))\n\t\tcheck_replace_refs = 0;\n\treplace_ref_base = getenv(GIT_REPLACE_REF_BASE_ENVIRONMENT);\n\tgit_replace_ref_base = xstrdup(replace_ref_base ? replace_ref_base\n\t\t\t\t\t\t\t  : \"refs/replace/\");\n\tnamespace = expand_namespace(getenv(GIT_NAMESPACE_ENVIRONMENT));\n\tnamespace_len = strlen(namespace);\n\tshallow_file = getenv(GIT_SHALLOW_FILE_ENVIRONMENT);\n\tif (shallow_file)\n\t\tset_alternate_shallow_file(shallow_file, 0);\n}\n\nint is_bare_repository(void)\n{\n\t/* if core.bare is not 'false', let's see if there is a work tree */\n\treturn is_bare_repository_cfg && !get_git_work_tree();\n}\n\nint have_git_dir(void)\n{\n\treturn startup_info->have_repository\n\t\t|| git_dir\n\t\t|| getenv(GIT_DIR_ENVIRONMENT);\n}\n\nconst char *get_git_dir(void)\n{\n\tif (!git_dir)\n\t\tsetup_git_env();\n\treturn git_dir;\n}\n\nconst char *get_git_common_dir(void)\n{\n\treturn git_common_dir;\n}\n\nconst char *get_git_namespace(void)\n{\n\tif (!namespace)\n\t\tsetup_git_env();\n\treturn namespace;\n}\n\nconst char *strip_namespace(const char *namespaced_ref)\n{\n\tif (!starts_with(namespaced_ref, get_git_namespace()))\n\t\treturn NULL;\n\treturn namespaced_ref + namespace_len;\n}\n\nconst char *get_super_prefix(void)\n{\n\tstatic int initialized;\n\tif (!initialized) {\n\t\tsuper_prefix = getenv(GIT_SUPER_PREFIX_ENVIRONMENT);\n\t\tinitialized = 1;\n\t}\n\treturn super_prefix;\n}\n\nstatic int git_work_tree_initialized;\n\n/*\n * Note.  This works only before you used a work tree.  This was added\n * primarily to support git-clone to work in a new repository it just\n * created, and is not meant to flip between different work trees.\n */\nvoid set_git_work_tree(const char *new_work_tree)\n{\n\tif (git_work_tree_initialized) {\n\t\tnew_work_tree = real_path(new_work_tree);\n\t\tif (strcmp(new_work_tree, work_tree))\n\t\t\tdie(\"internal error: work tree has already been set\\n\"\n\t\t\t    \"Current worktree: %s\\nNew worktree: %s\",\n\t\t\t    work_tree, new_work_tree);\n\t\treturn;\n\t}\n\tgit_work_tree_initialized = 1;\n\twork_tree = real_pathdup(new_work_tree);\n}\n\nconst char *get_git_work_tree(void)\n{\n\treturn work_tree;\n}\n\nchar *get_object_directory(void)\n{\n\tif (!git_object_dir)\n\t\tsetup_git_env();\n\treturn git_object_dir;\n}\n\nint odb_mkstemp(char *template, size_t limit, const char *pattern)\n{\n\tint fd;\n\t/*\n\t * we let the umask do its job, don't try to be more\n\t * restrictive except to remove write permission.\n\t */\n\tint mode = 0444;\n\tsnprintf(template, limit, \"%s/%s\",\n\t\t get_object_directory(), pattern);\n\tfd = git_mkstemp_mode(template, mode);\n\tif (0 <= fd)\n\t\treturn fd;\n\n\t/* slow path */\n\t/* some mkstemp implementations erase template on failure */\n\tsnprintf(template, limit, \"%s/%s\",\n\t\t get_object_directory(), pattern);\n\tsafe_create_leading_directories(template);\n\treturn xmkstemp_mode(template, mode);\n}",
  "static char *expand_namespace(const char *raw_namespace)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct strbuf **components, **c;\n\n\tif (!raw_namespace || !*raw_namespace)\n\t\treturn xstrdup(\"\");\n\n\tstrbuf_addstr(&buf, raw_namespace);\n\tcomponents = strbuf_split(&buf, '/');\n\tstrbuf_reset(&buf);\n\tfor (c = components; *c; c++)\n\t\tif (strcmp((*c)->buf, \"/\") != 0)\n\t\t\tstrbuf_addf(&buf, \"refs/namespaces/%s\", (*c)->buf);\n\tstrbuf_list_free(components);\n\tif (check_refname_format(buf.buf, 0))\n\t\tdie(\"bad git namespace path \\\"%s\\\"\", raw_namespace);\n\tstrbuf_addch(&buf, '/');\n\treturn strbuf_detach(&buf, NULL);\n}\n\nstatic char *git_path_from_env(const char *envvar, const char *git_dir,\n\t\t\t       const char *path, int *fromenv)\n{\n\tconst char *value = getenv(envvar);\n\tif (!value)\n\t\treturn xstrfmt(\"%s/%s\", git_dir, path);\n\tif (fromenv)\n\t\t*fromenv = 1;\n\treturn xstrdup(value);\n}\n\nstatic void setup_git_env(void)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\tconst char *gitfile;\n\tconst char *shallow_file;\n\tconst char *replace_ref_base;\n\n\tgit_dir = getenv(GIT_DIR_ENVIRONMENT);\n\tif (!git_dir)\n\t\tgit_dir = DEFAULT_GIT_DIR_ENVIRONMENT;\n\tgitfile = read_gitfile(git_dir);\n\tgit_dir = xstrdup(gitfile ? gitfile : git_dir);\n\tif (get_common_dir(&sb, git_dir))\n\t\tgit_common_dir_env = 1;\n\tgit_common_dir = strbuf_detach(&sb, NULL);\n\tgit_object_dir = git_path_from_env(DB_ENVIRONMENT, git_common_dir,\n\t\t\t\t\t   \"objects\", &git_db_env);\n\tgit_index_file = git_path_from_env(INDEX_ENVIRONMENT, git_dir,\n\t\t\t\t\t   \"index\", &git_index_env);\n\tgit_graft_file = git_path_from_env(GRAFT_ENVIRONMENT, git_common_dir,\n\t\t\t\t\t   \"info/grafts\", &git_graft_env);\n\tif (getenv(NO_REPLACE_OBJECTS_ENVIRONMENT))\n\t\tcheck_replace_refs = 0;\n\treplace_ref_base = getenv(GIT_REPLACE_REF_BASE_ENVIRONMENT);\n\tgit_replace_ref_base = xstrdup(replace_ref_base ? replace_ref_base\n\t\t\t\t\t\t\t  : \"refs/replace/\");\n\tnamespace = expand_namespace(getenv(GIT_NAMESPACE_ENVIRONMENT));\n\tnamespace_len = strlen(namespace);\n\tshallow_file = getenv(GIT_SHALLOW_FILE_ENVIRONMENT);\n\tif (shallow_file)\n\t\tset_alternate_shallow_file(shallow_file, 0);\n}\n\nint is_bare_repository(void)\n{\n\t/* if core.bare is not 'false', let's see if there is a work tree */\n\treturn is_bare_repository_cfg && !get_git_work_tree();\n}\n\nint have_git_dir(void)\n{\n\treturn startup_info->have_repository\n\t\t|| git_dir\n\t\t|| getenv(GIT_DIR_ENVIRONMENT);\n}\n\nconst char *get_git_dir(void)\n{\n\tif (!git_dir)\n\t\tsetup_git_env();\n\treturn git_dir;\n}\n\nconst char *get_git_common_dir(void)\n{\n\treturn git_common_dir;\n}\n\nconst char *get_git_namespace(void)\n{\n\tif (!namespace)\n\t\tsetup_git_env();\n\treturn namespace;\n}\n\nconst char *strip_namespace(const char *namespaced_ref)\n{\n\tif (!starts_with(namespaced_ref, get_git_namespace()))\n\t\treturn NULL;\n\treturn namespaced_ref + namespace_len;\n}\n\nstatic int git_work_tree_initialized;\n\n/*\n * Note.  This works only before you used a work tree.  This was added\n * primarily to support git-clone to work in a new repository it just\n * created, and is not meant to flip between different work trees.\n */\nvoid set_git_work_tree(const char *new_work_tree)\n{\n\tif (git_work_tree_initialized) {\n\t\tnew_work_tree = real_path(new_work_tree);\n\t\tif (strcmp(new_work_tree, work_tree))\n\t\t\tdie(\"internal error: work tree has already been set\\n\"\n\t\t\t    \"Current worktree: %s\\nNew worktree: %s\",\n\t\t\t    work_tree, new_work_tree);\n\t\treturn;\n\t}\n\tgit_work_tree_initialized = 1;\n\twork_tree = xstrdup(real_path(new_work_tree));\n}\n\nconst char *get_git_work_tree(void)\n{\n\treturn work_tree;\n}\n\nchar *get_object_directory(void)\n{\n\tif (!git_object_dir)\n\t\tsetup_git_env();\n\treturn git_object_dir;\n}\n\nint odb_mkstemp(char *template, size_t limit, const char *pattern)\n{\n\tint fd;\n\t/*\n\t * we let the umask do its job, don't try to be more\n\t * restrictive except to remove write permission.\n\t */\n\tint mode = 0444;\n\tsnprintf(template, limit, \"%s/%s\",\n\t\t get_object_directory(), pattern);\n\tfd = git_mkstemp_mode(template, mode);\n\tif (0 <= fd)\n\t\treturn fd;\n\n\t/* slow path */\n\t/* some mkstemp implementations erase template on failure */\n\tsnprintf(template, limit, \"%s/%s\",\n\t\t get_object_directory(), pattern);\n\tsafe_create_leading_directories(template);\n\treturn xmkstemp_mode(template, mode);\n}\n",
  "static char *expand_namespace(const char *raw_namespace)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct strbuf **components, **c;\n\n\tif (!raw_namespace || !*raw_namespace)\n\t\treturn xstrdup(\"\");\n\n\tstrbuf_addstr(&buf, raw_namespace);\n\tcomponents = strbuf_split(&buf, '/');\n\tstrbuf_reset(&buf);\n\tfor (c = components; *c; c++)\n\t\tif (strcmp((*c)->buf, \"/\") != 0)\n\t\t\tstrbuf_addf(&buf, \"refs/namespaces/%s\", (*c)->buf);\n\tstrbuf_list_free(components);\n\tif (check_refname_format(buf.buf, 0))\n\t\tdie(\"bad git namespace path \\\"%s\\\"\", raw_namespace);\n\tstrbuf_addch(&buf, '/');\n\treturn strbuf_detach(&buf, NULL);\n}\n\nstatic char *git_path_from_env(const char *envvar, const char *git_dir,\n\t\t\t       const char *path, int *fromenv)\n{\n\tconst char *value = getenv(envvar);\n\tif (!value)\n\t\treturn xstrfmt(\"%s/%s\", git_dir, path);\n\tif (fromenv)\n\t\t*fromenv = 1;\n\treturn xstrdup(value);\n}\n\nstatic void setup_git_env(void)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\tconst char *gitfile;\n\tconst char *shallow_file;\n\tconst char *replace_ref_base;\n\n\tgit_dir = getenv(GIT_DIR_ENVIRONMENT);\n\tif (!git_dir)\n\t\tgit_dir = DEFAULT_GIT_DIR_ENVIRONMENT;\n\tgitfile = read_gitfile(git_dir);\n\tgit_dir = xstrdup(gitfile ? gitfile : git_dir);\n\tif (get_common_dir(&sb, git_dir))\n\t\tgit_common_dir_env = 1;\n\tgit_common_dir = strbuf_detach(&sb, NULL);\n\tgit_object_dir = git_path_from_env(DB_ENVIRONMENT, git_common_dir,\n\t\t\t\t\t   \"objects\", &git_db_env);\n\tgit_index_file = git_path_from_env(INDEX_ENVIRONMENT, git_dir,\n\t\t\t\t\t   \"index\", &git_index_env);\n\tgit_graft_file = git_path_from_env(GRAFT_ENVIRONMENT, git_common_dir,\n\t\t\t\t\t   \"info/grafts\", &git_graft_env);\n\tif (getenv(NO_REPLACE_OBJECTS_ENVIRONMENT))\n\t\tcheck_replace_refs = 0;\n\treplace_ref_base = getenv(GIT_REPLACE_REF_BASE_ENVIRONMENT);\n\tgit_replace_ref_base = xstrdup(replace_ref_base ? replace_ref_base\n\t\t\t\t\t\t\t  : \"refs/replace/\");\n\tnamespace = expand_namespace(getenv(GIT_NAMESPACE_ENVIRONMENT));\n\tnamespace_len = strlen(namespace);\n\tshallow_file = getenv(GIT_SHALLOW_FILE_ENVIRONMENT);\n\tif (shallow_file)\n\t\tset_alternate_shallow_file(shallow_file, 0);\n}\n\nint is_bare_repository(void)\n{\n\t/* if core.bare is not 'false', let's see if there is a work tree */\n\treturn is_bare_repository_cfg && !get_git_work_tree();\n}\n\nconst char *get_git_dir(void)\n{\n\tif (!git_dir)\n\t\tsetup_git_env();\n\treturn git_dir;\n}\n\nconst char *get_git_common_dir(void)\n{\n\treturn git_common_dir;\n}\n\nconst char *get_git_namespace(void)\n{\n\tif (!namespace)\n\t\tsetup_git_env();\n\treturn namespace;\n}\n\nconst char *strip_namespace(const char *namespaced_ref)\n{\n\tif (!starts_with(namespaced_ref, get_git_namespace()))\n\t\treturn NULL;\n\treturn namespaced_ref + namespace_len;\n}\n\nstatic int git_work_tree_initialized;\n\n/*\n * Note.  This works only before you used a work tree.  This was added\n * primarily to support git-clone to work in a new repository it just\n * created, and is not meant to flip between different work trees.\n */\nvoid set_git_work_tree(const char *new_work_tree)\n{\n\tif (git_work_tree_initialized) {\n\t\tnew_work_tree = real_path(new_work_tree);\n\t\tif (strcmp(new_work_tree, work_tree))\n\t\t\tdie(\"internal error: work tree has already been set\\n\"\n\t\t\t    \"Current worktree: %s\\nNew worktree: %s\",\n\t\t\t    work_tree, new_work_tree);\n\t\treturn;\n\t}\n\tgit_work_tree_initialized = 1;\n\twork_tree = xstrdup(real_path(new_work_tree));\n}\n\nconst char *get_git_work_tree(void)\n{\n\treturn work_tree;\n}\n\nchar *get_object_directory(void)\n{\n\tif (!git_object_dir)\n\t\tsetup_git_env();\n\treturn git_object_dir;\n}\n\nint odb_mkstemp(char *template, size_t limit, const char *pattern)\n{\n\tint fd;\n\t/*\n\t * we let the umask do its job, don't try to be more\n\t * restrictive except to remove write permission.\n\t */\n\tint mode = 0444;\n\tsnprintf(template, limit, \"%s/%s\",\n\t\t get_object_directory(), pattern);\n\tfd = git_mkstemp_mode(template, mode);\n\tif (0 <= fd)\n\t\treturn fd;\n\n\t/* slow path */\n\t/* some mkstemp implementations erase template on failure */\n\tsnprintf(template, limit, \"%s/%s\",\n\t\t get_object_directory(), pattern);\n\tsafe_create_leading_directories(template);\n\treturn xmkstemp_mode(template, mode);\n}\n",
  "static void add_domainname(struct strbuf *out, int *is_bogus)\n{\n\tchar buf[HOST_NAME_MAX + 1];\n\n\tif (xgethostname(buf, sizeof(buf))) {\n\t\twarning_errno(\"cannot get host name\");\n\t\tstrbuf_addstr(out, \"(none)\");\n\t\t*is_bogus = 1;\n\t\treturn;\n\t}\n\tif (strchr(buf, '.'))\n\t\tstrbuf_addstr(out, buf);\n\telse if (canonical_name(buf, out) < 0) {\n\t\tstrbuf_addf(out, \"%s.(none)\", buf);\n\t\t*is_bogus = 1;\n\t}\n}\n\nstatic void copy_email(const struct passwd *pw, struct strbuf *email,\n\t\t       int *is_bogus)\n{\n\t/*\n\t * Make up a fake email address\n\t * (name + '@' + hostname [+ '.' + domainname])\n\t */\n\tstrbuf_addstr(email, pw->pw_name);\n\tstrbuf_addch(email, '@');\n\n\tif (!add_mailname_host(email))\n\t\treturn;\t/* read from \"/etc/mailname\" (Debian) */\n\tadd_domainname(email, is_bogus);\n}\n\nconst char *ident_default_name(void)\n{\n\tif (!(ident_config_given & IDENT_NAME_GIVEN) && !git_default_name.len) {\n\t\tcopy_gecos(xgetpwuid_self(&default_name_is_bogus), &git_default_name);\n\t\tstrbuf_trim(&git_default_name);\n\t}\n\treturn git_default_name.buf;\n}\n\nconst char *ident_default_email(void)\n{\n\tif (!(ident_config_given & IDENT_MAIL_GIVEN) && !git_default_email.len) {\n\t\tconst char *email = getenv(\"EMAIL\");\n\n\t\tif (email && email[0]) {\n\t\t\tstrbuf_addstr(&git_default_email, email);\n\t\t\tcommitter_ident_explicitly_given |= IDENT_MAIL_GIVEN;\n\t\t\tauthor_ident_explicitly_given |= IDENT_MAIL_GIVEN;\n\t\t} else if ((email = query_user_email()) && email[0]) {\n\t\t\tstrbuf_addstr(&git_default_email, email);\n\t\t\tfree((char *)email);\n\t\t} else\n\t\t\tcopy_email(xgetpwuid_self(&default_email_is_bogus),\n\t\t\t\t   &git_default_email, &default_email_is_bogus);\n\t\tstrbuf_trim(&git_default_email);\n\t}\n\treturn git_default_email.buf;\n}\n\nstatic const char *ident_default_date(void)\n{\n\tif (!git_default_date.len)\n\t\tdatestamp(&git_default_date);\n\treturn git_default_date.buf;\n}\n\nvoid reset_ident_date(void)\n{\n\tstrbuf_reset(&git_default_date);\n}\n\nstatic int crud(unsigned char c)\n{\n\treturn  c <= 32  ||\n\t\tc == '.' ||\n\t\tc == ',' ||\n\t\tc == ':' ||\n\t\tc == ';' ||\n\t\tc == '<' ||\n\t\tc == '>' ||\n\t\tc == '\"' ||\n\t\tc == '\\\\' ||\n\t\tc == '\\'';\n}\n\nstatic int has_non_crud(const char *str)\n{\n\tfor (; *str; str++) {\n\t\tif (!crud(*str))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * Copy over a string to the destination, but avoid special\n * characters ('\\n', '<' and '>') and remove crud at the end\n */\nstatic void strbuf_addstr_without_crud(struct strbuf *sb, const char *src)\n{\n\tsize_t i, len;\n\tunsigned char c;\n\n\t/* Remove crud from the beginning.. */\n\twhile ((c = *src) != 0) {\n\t\tif (!crud(c))\n\t\t\tbreak;\n\t\tsrc++;\n\t}\n\n\t/* Remove crud from the end.. */\n\tlen = strlen(src);\n\twhile (len > 0) {\n\t\tc = src[len-1];\n\t\tif (!crud(c))\n\t\t\tbreak;\n\t\t--len;\n\t}\n\n\t/*\n\t * Copy the rest to the buffer, but avoid the special\n\t * characters '\\n' '<' and '>' that act as delimiters on\n\t * an identification line. We can only remove crud, never add it,\n\t * so 'len' is our maximum.\n\t */\n\tstrbuf_grow(sb, len);\n\tfor (i = 0; i < len; i++) {\n\t\tc = *src++;\n\t\tswitch (c) {\n\t\tcase '\\n': case '<': case '>':\n\t\t\tcontinue;\n\t\t}\n\t\tsb->buf[sb->len++] = c;\n\t}\n\tsb->buf[sb->len] = '\\0';\n}\n",
  "static void add_domainname(struct strbuf *out, int *is_bogus)\n{\n\tchar buf[HOST_NAME_MAX + 1];\n\n\tif (xgethostname(buf, sizeof(buf))) {\n\t\twarning_errno(\"cannot get host name\");\n\t\tstrbuf_addstr(out, \"(none)\");\n\t\t*is_bogus = 1;\n\t\treturn;\n\t}\n\tif (strchr(buf, '.'))\n\t\tstrbuf_addstr(out, buf);\n\telse if (canonical_name(buf, out) < 0) {\n\t\tstrbuf_addf(out, \"%s.(none)\", buf);\n\t\t*is_bogus = 1;\n\t}\n}\n\nstatic void copy_email(const struct passwd *pw, struct strbuf *email,\n\t\t       int *is_bogus)\n{\n\t/*\n\t * Make up a fake email address\n\t * (name + '@' + hostname [+ '.' + domainname])\n\t */\n\tstrbuf_addstr(email, pw->pw_name);\n\tstrbuf_addch(email, '@');\n\n\tif (!add_mailname_host(email))\n\t\treturn;\t/* read from \"/etc/mailname\" (Debian) */\n\tadd_domainname(email, is_bogus);\n}\n\nconst char *ident_default_name(void)\n{\n\tif (!(ident_config_given & IDENT_NAME_GIVEN) && !git_default_name.len) {\n\t\tcopy_gecos(xgetpwuid_self(&default_name_is_bogus), &git_default_name);\n\t\tstrbuf_trim(&git_default_name);\n\t}\n\treturn git_default_name.buf;\n}\n\nconst char *ident_default_email(void)\n{\n\tif (!(ident_config_given & IDENT_MAIL_GIVEN) && !git_default_email.len) {\n\t\tconst char *email = getenv(\"EMAIL\");\n\n\t\tif (email && email[0]) {\n\t\t\tstrbuf_addstr(&git_default_email, email);\n\t\t\tcommitter_ident_explicitly_given |= IDENT_MAIL_GIVEN;\n\t\t\tauthor_ident_explicitly_given |= IDENT_MAIL_GIVEN;\n\t\t} else\n\t\t\tcopy_email(xgetpwuid_self(&default_email_is_bogus),\n\t\t\t\t   &git_default_email, &default_email_is_bogus);\n\t\tstrbuf_trim(&git_default_email);\n\t}\n\treturn git_default_email.buf;\n}\n\nstatic const char *ident_default_date(void)\n{\n\tif (!git_default_date.len)\n\t\tdatestamp(&git_default_date);\n\treturn git_default_date.buf;\n}\n\nvoid reset_ident_date(void)\n{\n\tstrbuf_reset(&git_default_date);\n}\n\nstatic int crud(unsigned char c)\n{\n\treturn  c <= 32  ||\n\t\tc == '.' ||\n\t\tc == ',' ||\n\t\tc == ':' ||\n\t\tc == ';' ||\n\t\tc == '<' ||\n\t\tc == '>' ||\n\t\tc == '\"' ||\n\t\tc == '\\\\' ||\n\t\tc == '\\'';\n}\n\nstatic int has_non_crud(const char *str)\n{\n\tfor (; *str; str++) {\n\t\tif (!crud(*str))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * Copy over a string to the destination, but avoid special\n * characters ('\\n', '<' and '>') and remove crud at the end\n */\nstatic void strbuf_addstr_without_crud(struct strbuf *sb, const char *src)\n{\n\tsize_t i, len;\n\tunsigned char c;\n\n\t/* Remove crud from the beginning.. */\n\twhile ((c = *src) != 0) {\n\t\tif (!crud(c))\n\t\t\tbreak;\n\t\tsrc++;\n\t}\n\n\t/* Remove crud from the end.. */\n\tlen = strlen(src);\n\twhile (len > 0) {\n\t\tc = src[len-1];\n\t\tif (!crud(c))\n\t\t\tbreak;\n\t\t--len;\n\t}\n\n\t/*\n\t * Copy the rest to the buffer, but avoid the special\n\t * characters '\\n' '<' and '>' that act as delimiters on\n\t * an identification line. We can only remove crud, never add it,\n\t * so 'len' is our maximum.\n\t */\n\tstrbuf_grow(sb, len);\n\tfor (i = 0; i < len; i++) {\n\t\tc = *src++;\n\t\tswitch (c) {\n\t\tcase '\\n': case '<': case '>':\n\t\t\tcontinue;\n\t\t}\n\t\tsb->buf[sb->len++] = c;\n\t}\n\tsb->buf[sb->len] = '\\0';\n}",
  "static void add_domainname(struct strbuf *out, int *is_bogus)\n{\n\tchar buf[HOST_NAME_MAX + 1];\n\n\tif (gethostname(buf, sizeof(buf))) {\n\t\twarning_errno(\"cannot get host name\");\n\t\tstrbuf_addstr(out, \"(none)\");\n\t\t*is_bogus = 1;\n\t\treturn;\n\t}\n\tif (strchr(buf, '.'))\n\t\tstrbuf_addstr(out, buf);\n\telse if (canonical_name(buf, out) < 0) {\n\t\tstrbuf_addf(out, \"%s.(none)\", buf);\n\t\t*is_bogus = 1;\n\t}\n}\n\nstatic void copy_email(const struct passwd *pw, struct strbuf *email,\n\t\t       int *is_bogus)\n{\n\t/*\n\t * Make up a fake email address\n\t * (name + '@' + hostname [+ '.' + domainname])\n\t */\n\tstrbuf_addstr(email, pw->pw_name);\n\tstrbuf_addch(email, '@');\n\n\tif (!add_mailname_host(email))\n\t\treturn;\t/* read from \"/etc/mailname\" (Debian) */\n\tadd_domainname(email, is_bogus);\n}\n\nconst char *ident_default_name(void)\n{\n\tif (!git_default_name.len) {\n\t\tcopy_gecos(xgetpwuid_self(&default_name_is_bogus), &git_default_name);\n\t\tstrbuf_trim(&git_default_name);\n\t}\n\treturn git_default_name.buf;\n}\n\nconst char *ident_default_email(void)\n{\n\tif (!git_default_email.len) {\n\t\tconst char *email = getenv(\"EMAIL\");\n\n\t\tif (email && email[0]) {\n\t\t\tstrbuf_addstr(&git_default_email, email);\n\t\t\tcommitter_ident_explicitly_given |= IDENT_MAIL_GIVEN;\n\t\t\tauthor_ident_explicitly_given |= IDENT_MAIL_GIVEN;\n\t\t} else\n\t\t\tcopy_email(xgetpwuid_self(&default_email_is_bogus),\n\t\t\t\t   &git_default_email, &default_email_is_bogus);\n\t\tstrbuf_trim(&git_default_email);\n\t}\n\treturn git_default_email.buf;\n}\n\nstatic const char *ident_default_date(void)\n{\n\tif (!git_default_date.len)\n\t\tdatestamp(&git_default_date);\n\treturn git_default_date.buf;\n}\n\nvoid reset_ident_date(void)\n{\n\tstrbuf_reset(&git_default_date);\n}\n\nstatic int crud(unsigned char c)\n{\n\treturn  c <= 32  ||\n\t\tc == '.' ||\n\t\tc == ',' ||\n\t\tc == ':' ||\n\t\tc == ';' ||\n\t\tc == '<' ||\n\t\tc == '>' ||\n\t\tc == '\"' ||\n\t\tc == '\\\\' ||\n\t\tc == '\\'';\n}\n\n/*\n * Copy over a string to the destination, but avoid special\n * characters ('\\n', '<' and '>') and remove crud at the end\n */\nstatic void strbuf_addstr_without_crud(struct strbuf *sb, const char *src)\n{\n\tsize_t i, len;\n\tunsigned char c;\n\n\t/* Remove crud from the beginning.. */\n\twhile ((c = *src) != 0) {\n\t\tif (!crud(c))\n\t\t\tbreak;\n\t\tsrc++;\n\t}\n\n\t/* Remove crud from the end.. */\n\tlen = strlen(src);\n\twhile (len > 0) {\n\t\tc = src[len-1];\n\t\tif (!crud(c))\n\t\t\tbreak;\n\t\t--len;\n\t}\n\n\t/*\n\t * Copy the rest to the buffer, but avoid the special\n\t * characters '\\n' '<' and '>' that act as delimiters on\n\t * an identification line. We can only remove crud, never add it,\n\t * so 'len' is our maximum.\n\t */\n\tstrbuf_grow(sb, len);\n\tfor (i = 0; i < len; i++) {\n\t\tc = *src++;\n\t\tswitch (c) {\n\t\tcase '\\n': case '<': case '>':\n\t\t\tcontinue;\n\t\t}\n\t\tsb->buf[sb->len++] = c;\n\t}\n\tsb->buf[sb->len] = '\\0';\n}\n",
  "static void add_domainname(struct strbuf *out, int *is_bogus)\n{\n\tchar buf[1024];\n\n\tif (gethostname(buf, sizeof(buf))) {\n\t\twarning(\"cannot get host name: %s\", strerror(errno));\n\t\tstrbuf_addstr(out, \"(none)\");\n\t\t*is_bogus = 1;\n\t\treturn;\n\t}\n\tif (strchr(buf, '.'))\n\t\tstrbuf_addstr(out, buf);\n\telse if (canonical_name(buf, out) < 0) {\n\t\tstrbuf_addf(out, \"%s.(none)\", buf);\n\t\t*is_bogus = 1;\n\t}\n}\n\nstatic void copy_email(const struct passwd *pw, struct strbuf *email,\n\t\t       int *is_bogus)\n{\n\t/*\n\t * Make up a fake email address\n\t * (name + '@' + hostname [+ '.' + domainname])\n\t */\n\tstrbuf_addstr(email, pw->pw_name);\n\tstrbuf_addch(email, '@');\n\n\tif (!add_mailname_host(email))\n\t\treturn;\t/* read from \"/etc/mailname\" (Debian) */\n\tadd_domainname(email, is_bogus);\n}\n\nconst char *ident_default_name(void)\n{\n\tif (!git_default_name.len) {\n\t\tcopy_gecos(xgetpwuid_self(&default_name_is_bogus), &git_default_name);\n\t\tstrbuf_trim(&git_default_name);\n\t}\n\treturn git_default_name.buf;\n}\n\nconst char *ident_default_email(void)\n{\n\tif (!git_default_email.len) {\n\t\tconst char *email = getenv(\"EMAIL\");\n\n\t\tif (email && email[0]) {\n\t\t\tstrbuf_addstr(&git_default_email, email);\n\t\t\tcommitter_ident_explicitly_given |= IDENT_MAIL_GIVEN;\n\t\t\tauthor_ident_explicitly_given |= IDENT_MAIL_GIVEN;\n\t\t} else\n\t\t\tcopy_email(xgetpwuid_self(&default_email_is_bogus),\n\t\t\t\t   &git_default_email, &default_email_is_bogus);\n\t\tstrbuf_trim(&git_default_email);\n\t}\n\treturn git_default_email.buf;\n}\n\nstatic const char *ident_default_date(void)\n{\n\tif (!git_default_date.len)\n\t\tdatestamp(&git_default_date);\n\treturn git_default_date.buf;\n}\n\nstatic int crud(unsigned char c)\n{\n\treturn  c <= 32  ||\n\t\tc == '.' ||\n\t\tc == ',' ||\n\t\tc == ':' ||\n\t\tc == ';' ||\n\t\tc == '<' ||\n\t\tc == '>' ||\n\t\tc == '\"' ||\n\t\tc == '\\\\' ||\n\t\tc == '\\'';\n}\n\n/*\n * Copy over a string to the destination, but avoid special\n * characters ('\\n', '<' and '>') and remove crud at the end\n */\nstatic void strbuf_addstr_without_crud(struct strbuf *sb, const char *src)\n{\n\tsize_t i, len;\n\tunsigned char c;\n\n\t/* Remove crud from the beginning.. */\n\twhile ((c = *src) != 0) {\n\t\tif (!crud(c))\n\t\t\tbreak;\n\t\tsrc++;\n\t}\n\n\t/* Remove crud from the end.. */\n\tlen = strlen(src);\n\twhile (len > 0) {\n\t\tc = src[len-1];\n\t\tif (!crud(c))\n\t\t\tbreak;\n\t\t--len;\n\t}\n\n\t/*\n\t * Copy the rest to the buffer, but avoid the special\n\t * characters '\\n' '<' and '>' that act as delimiters on\n\t * an identification line. We can only remove crud, never add it,\n\t * so 'len' is our maximum.\n\t */\n\tstrbuf_grow(sb, len);\n\tfor (i = 0; i < len; i++) {\n\t\tc = *src++;\n\t\tswitch (c) {\n\t\tcase '\\n': case '<': case '>':\n\t\t\tcontinue;\n\t\t}\n\t\tsb->buf[sb->len++] = c;\n\t}\n\tsb->buf[sb->len] = '\\0';\n}\n",
  "static void add_domainname(struct strbuf *out)\n{\n\tchar buf[1024];\n\tstruct hostent *he;\n\n\tif (gethostname(buf, sizeof(buf))) {\n\t\twarning(\"cannot get host name: %s\", strerror(errno));\n\t\tstrbuf_addstr(out, \"(none)\");\n\t\treturn;\n\t}\n\tif (strchr(buf, '.'))\n\t\tstrbuf_addstr(out, buf);\n\telse if ((he = gethostbyname(buf)) && strchr(he->h_name, '.'))\n\t\tstrbuf_addstr(out, he->h_name);\n\telse\n\t\tstrbuf_addf(out, \"%s.(none)\", buf);\n}\n\nstatic void copy_email(const struct passwd *pw, struct strbuf *email)\n{\n\t/*\n\t * Make up a fake email address\n\t * (name + '@' + hostname [+ '.' + domainname])\n\t */\n\tstrbuf_addstr(email, pw->pw_name);\n\tstrbuf_addch(email, '@');\n\n\tif (!add_mailname_host(email))\n\t\treturn;\t/* read from \"/etc/mailname\" (Debian) */\n\tadd_domainname(email);\n}\n\nstatic const char *ident_default_name(void)\n{\n\tif (!git_default_name.len) {\n\t\tcopy_gecos(xgetpwuid_self(), &git_default_name);\n\t\tstrbuf_trim(&git_default_name);\n\t}\n\treturn git_default_name.buf;\n}\n\nconst char *ident_default_email(void)\n{\n\tif (!git_default_email.len) {\n\t\tconst char *email = getenv(\"EMAIL\");\n\n\t\tif (email && email[0]) {\n\t\t\tstrbuf_addstr(&git_default_email, email);\n\t\t\tcommitter_ident_explicitly_given |= IDENT_MAIL_GIVEN;\n\t\t\tauthor_ident_explicitly_given |= IDENT_MAIL_GIVEN;\n\t\t} else\n\t\t\tcopy_email(xgetpwuid_self(), &git_default_email);\n\t\tstrbuf_trim(&git_default_email);\n\t}\n\treturn git_default_email.buf;\n}\n\nstatic const char *ident_default_date(void)\n{\n\tif (!git_default_date.len)\n\t\tdatestamp(&git_default_date);\n\treturn git_default_date.buf;\n}\n\nstatic int crud(unsigned char c)\n{\n\treturn  c <= 32  ||\n\t\tc == '.' ||\n\t\tc == ',' ||\n\t\tc == ':' ||\n\t\tc == ';' ||\n\t\tc == '<' ||\n\t\tc == '>' ||\n\t\tc == '\"' ||\n\t\tc == '\\\\' ||\n\t\tc == '\\'';\n}\n\n/*\n * Copy over a string to the destination, but avoid special\n * characters ('\\n', '<' and '>') and remove crud at the end\n */\nstatic void strbuf_addstr_without_crud(struct strbuf *sb, const char *src)\n{\n\tsize_t i, len;\n\tunsigned char c;\n\n\t/* Remove crud from the beginning.. */\n\twhile ((c = *src) != 0) {\n\t\tif (!crud(c))\n\t\t\tbreak;\n\t\tsrc++;\n\t}\n\n\t/* Remove crud from the end.. */\n\tlen = strlen(src);\n\twhile (len > 0) {\n\t\tc = src[len-1];\n\t\tif (!crud(c))\n\t\t\tbreak;\n\t\t--len;\n\t}\n\n\t/*\n\t * Copy the rest to the buffer, but avoid the special\n\t * characters '\\n' '<' and '>' that act as delimiters on\n\t * an identification line. We can only remove crud, never add it,\n\t * so 'len' is our maximum.\n\t */\n\tstrbuf_grow(sb, len);\n\tfor (i = 0; i < len; i++) {\n\t\tc = *src++;\n\t\tswitch (c) {\n\t\tcase '\\n': case '<': case '>':\n\t\t\tcontinue;\n\t\t}\n\t\tsb->buf[sb->len++] = c;\n\t}\n\tsb->buf[sb->len] = '\\0';\n}"
]
