[
  "static const char en85[] = {\n\t'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n\t'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\n\t'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',\n\t'U', 'V', 'W', 'X', 'Y', 'Z',\n\t'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n\t'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n\t'u', 'v', 'w', 'x', 'y', 'z',\n\t'!', '#', '$', '%', '&', '(', ')', '*', '+', '-',\n\t';', '<', '=', '>', '?', '@', '^', '_',\t'`', '{',\n\t'|', '}', '~'\n};\n\nstatic char de85[256];\nstatic void prep_base85(void)\n{\n\tint i;\n\tif (de85['Z'])\n\t\treturn;\n\tfor (i = 0; i < ARRAY_SIZE(en85); i++) {\n\t\tint ch = en85[i];\n\t\tde85[ch] = i + 1;\n\t}\n}\n\nint decode_85(char *dst, const char *buffer, int len)\n{\n\tprep_base85();\n\n\tsay2(\"decode 85 <%.*s>\", len / 4 * 5, buffer);\n\twhile (len) {\n\t\tunsigned acc = 0;\n\t\tint de, cnt = 4;\n\t\tunsigned char ch;\n\t\tdo {\n\t\t\tch = *buffer++;\n\t\t\tde = de85[ch];\n\t\t\tif (--de < 0)\n\t\t\t\treturn error(\"invalid base85 alphabet %c\", ch);\n\t\t\tacc = acc * 85 + de;\n\t\t} while (--cnt);\n\t\tch = *buffer++;\n\t\tde = de85[ch];\n\t\tif (--de < 0)\n\t\t\treturn error(\"invalid base85 alphabet %c\", ch);\n\t\t/* Detect overflow. */\n\t\tif (0xffffffff / 85 < acc ||\n\t\t    0xffffffff - de < (acc *= 85))\n\t\t\treturn error(\"invalid base85 sequence %.5s\", buffer-5);\n\t\tacc += de;\n\t\tsay1(\" %08x\", acc);\n\n\t\tcnt = (len < 4) ? len : 4;\n\t\tlen -= cnt;\n\t\tdo {\n\t\t\tacc = (acc << 8) | (acc >> 24);\n\t\t\t*dst++ = acc;\n\t\t} while (--cnt);\n\t}\n\tsay(\"\\n\");\n\n\treturn 0;\n}\n\nvoid encode_85(char *buf, const unsigned char *data, int bytes)\n{\n\tsay(\"encode 85\");\n\twhile (bytes) {\n\t\tunsigned acc = 0;\n\t\tint cnt;\n\t\tfor (cnt = 24; cnt >= 0; cnt -= 8) {\n\t\t\tunsigned ch = *data++;\n\t\t\tacc |= ch << cnt;\n\t\t\tif (--bytes == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tsay1(\" %08x\", acc);\n\t\tfor (cnt = 4; cnt >= 0; cnt--) {\n\t\t\tint val = acc % 85;\n\t\t\tacc /= 85;\n\t\t\tbuf[cnt] = en85[val];\n\t\t}\n\t\tbuf += 5;\n\t}\n\tsay(\"\\n\");\n\n\t*buf = 0;\n}\n\nint main(int ac, char **av)\n{\n\tchar buf[1024];\n\n\tif (!strcmp(av[1], \"-e\")) {\n\t\tint len = strlen(av[2]);\n\t\tencode_85(buf, av[2], len);\n\t\tif (len <= 26) len = len + 'A' - 1;\n\t\telse len = len + 'a' - 26 - 1;\n\t\tprintf(\"encoded: %c%s\\n\", len, buf);\n\t\treturn 0;\n\t}\n\tif (!strcmp(av[1], \"-d\")) {\n\t\tint len = *av[2];\n\t\tif ('A' <= len && len <= 'Z') len = len - 'A' + 1;\n\t\telse len = len - 'a' + 26 + 1;\n\t\tdecode_85(buf, av[2]+1, len);\n\t\tprintf(\"decoded: %.*s\\n\", len, buf);\n\t\treturn 0;\n\t}\n\tif (!strcmp(av[1], \"-t\")) {\n\t\tchar t[4] = { -1,-1,-1,-1 };\n\t\tencode_85(buf, t, 4);\n\t\tprintf(\"encoded: D%s\\n\", buf);\n\t\treturn 0;\n\t}\n}",
  "static const char en85[] = {\n\t'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n\t'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\n\t'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',\n\t'U', 'V', 'W', 'X', 'Y', 'Z',\n\t'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n\t'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n\t'u', 'v', 'w', 'x', 'y', 'z',\n\t'!', '#', '$', '%', '&', '(', ')', '*', '+', '-',\n\t';', '<', '=', '>', '?', '@', '^', '_',\t'`', '{',\n\t'|', '}', '~'\n};\n\nstatic char de85[256];\nstatic void prep_base85(void)\n{\n\tint i;\n\tif (de85['Z'])\n\t\treturn;\n\tfor (i = 0; i < ARRAY_SIZE(en85); i++) {\n\t\tint ch = en85[i];\n\t\tde85[ch] = i + 1;\n\t}\n}\n\nint decode_85(char *dst, const char *buffer, int len)\n{\n\tprep_base85();\n\n\tsay2(\"decode 85 <%.*s>\", len/4*5, buffer);\n\twhile (len) {\n\t\tunsigned acc = 0;\n\t\tint de, cnt = 4;\n\t\tunsigned char ch;\n\t\tdo {\n\t\t\tch = *buffer++;\n\t\t\tde = de85[ch];\n\t\t\tif (--de < 0)\n\t\t\t\treturn error(\"invalid base85 alphabet %c\", ch);\n\t\t\tacc = acc * 85 + de;\n\t\t} while (--cnt);\n\t\tch = *buffer++;\n\t\tde = de85[ch];\n\t\tif (--de < 0)\n\t\t\treturn error(\"invalid base85 alphabet %c\", ch);\n\t\t/* Detect overflow. */\n\t\tif (0xffffffff / 85 < acc ||\n\t\t    0xffffffff - de < (acc *= 85))\n\t\t\treturn error(\"invalid base85 sequence %.5s\", buffer-5);\n\t\tacc += de;\n\t\tsay1(\" %08x\", acc);\n\n\t\tcnt = (len < 4) ? len : 4;\n\t\tlen -= cnt;\n\t\tdo {\n\t\t\tacc = (acc << 8) | (acc >> 24);\n\t\t\t*dst++ = acc;\n\t\t} while (--cnt);\n\t}\n\tsay(\"\\n\");\n\n\treturn 0;\n}\n\nvoid encode_85(char *buf, const unsigned char *data, int bytes)\n{\n\tsay(\"encode 85\");\n\twhile (bytes) {\n\t\tunsigned acc = 0;\n\t\tint cnt;\n\t\tfor (cnt = 24; cnt >= 0; cnt -= 8) {\n\t\t\tint ch = *data++;\n\t\t\tacc |= ch << cnt;\n\t\t\tif (--bytes == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tsay1(\" %08x\", acc);\n\t\tfor (cnt = 4; cnt >= 0; cnt--) {\n\t\t\tint val = acc % 85;\n\t\t\tacc /= 85;\n\t\t\tbuf[cnt] = en85[val];\n\t\t}\n\t\tbuf += 5;\n\t}\n\tsay(\"\\n\");\n\n\t*buf = 0;\n}\n\nint main(int ac, char **av)\n{\n\tchar buf[1024];\n\n\tif (!strcmp(av[1], \"-e\")) {\n\t\tint len = strlen(av[2]);\n\t\tencode_85(buf, av[2], len);\n\t\tif (len <= 26) len = len + 'A' - 1;\n\t\telse len = len + 'a' - 26 - 1;\n\t\tprintf(\"encoded: %c%s\\n\", len, buf);\n\t\treturn 0;\n\t}\n\tif (!strcmp(av[1], \"-d\")) {\n\t\tint len = *av[2];\n\t\tif ('A' <= len && len <= 'Z') len = len - 'A' + 1;\n\t\telse len = len - 'a' + 26 + 1;\n\t\tdecode_85(buf, av[2]+1, len);\n\t\tprintf(\"decoded: %.*s\\n\", len, buf);\n\t\treturn 0;\n\t}\n\tif (!strcmp(av[1], \"-t\")) {\n\t\tchar t[4] = { -1,-1,-1,-1 };\n\t\tencode_85(buf, t, 4);\n\t\tprintf(\"encoded: D%s\\n\", buf);\n\t\treturn 0;\n\t}\n}",
  "static const char en85[] = {\n\t'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n\t'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\n\t'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',\n\t'U', 'V', 'W', 'X', 'Y', 'Z',\n\t'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n\t'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n\t'u', 'v', 'w', 'x', 'y', 'z',\n\t'!', '#', '$', '%', '&', '(', ')', '*', '+', '-',\n\t';', '<', '=', '>', '?', '@', '^', '_',\t'`', '{',\n\t'|', '}', '~'\n};\n\nstatic char de85[256];\nstatic void prep_base85(void)\n{\n\tint i;\n\tif (de85['Z'])\n\t\treturn;\n\tfor (i = 0; i < ARRAY_SIZE(en85); i++) {\n\t\tint ch = en85[i];\n\t\tde85[ch] = i + 1;\n\t}\n}\n\nint decode_85(char *dst, const char *buffer, int len)\n{\n\tprep_base85();\n\n\tsay2(\"decode 85 <%.*s>\", len/4*5, buffer);\n\twhile (len) {\n\t\tunsigned acc = 0;\n\t\tint de, cnt = 4;\n\t\tunsigned char ch;\n\t\tdo {\n\t\t\tch = *buffer++;\n\t\t\tde = de85[ch];\n\t\t\tif (--de < 0)\n\t\t\t\treturn error(\"invalid base85 alphabet %c\", ch);\n\t\t\tacc = acc * 85 + de;\n\t\t} while (--cnt);\n\t\tch = *buffer++;\n\t\tde = de85[ch];\n\t\tif (--de < 0)\n\t\t\treturn error(\"invalid base85 alphabet %c\", ch);\n\t\t/*\n\t\t * Detect overflow.  The largest\n\t\t * 5-letter possible is \"|NsC0\" to\n\t\t * encode 0xffffffff, and \"|NsC\" gives\n\t\t * 0x03030303 at this point (i.e.\n\t\t * 0xffffffff = 0x03030303 * 85).\n\t\t */\n\t\tif (0x03030303 < acc ||\n\t\t    0xffffffff - de < (acc *= 85))\n\t\t\treturn error(\"invalid base85 sequence %.5s\", buffer-5);\n\t\tacc += de;\n\t\tsay1(\" %08x\", acc);\n\n\t\tcnt = (len < 4) ? len : 4;\n\t\tlen -= cnt;\n\t\tdo {\n\t\t\tacc = (acc << 8) | (acc >> 24);\n\t\t\t*dst++ = acc;\n\t\t} while (--cnt);\n\t}\n\tsay(\"\\n\");\n\n\treturn 0;\n}\n\nvoid encode_85(char *buf, const unsigned char *data, int bytes)\n{\n\tsay(\"encode 85\");\n\twhile (bytes) {\n\t\tunsigned acc = 0;\n\t\tint cnt;\n\t\tfor (cnt = 24; cnt >= 0; cnt -= 8) {\n\t\t\tint ch = *data++;\n\t\t\tacc |= ch << cnt;\n\t\t\tif (--bytes == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tsay1(\" %08x\", acc);\n\t\tfor (cnt = 4; cnt >= 0; cnt--) {\n\t\t\tint val = acc % 85;\n\t\t\tacc /= 85;\n\t\t\tbuf[cnt] = en85[val];\n\t\t}\n\t\tbuf += 5;\n\t}\n\tsay(\"\\n\");\n\n\t*buf = 0;\n}\n\nint main(int ac, char **av)\n{\n\tchar buf[1024];\n\n\tif (!strcmp(av[1], \"-e\")) {\n\t\tint len = strlen(av[2]);\n\t\tencode_85(buf, av[2], len);\n\t\tif (len <= 26) len = len + 'A' - 1;\n\t\telse len = len + 'a' - 26 - 1;\n\t\tprintf(\"encoded: %c%s\\n\", len, buf);\n\t\treturn 0;\n\t}\n\tif (!strcmp(av[1], \"-d\")) {\n\t\tint len = *av[2];\n\t\tif ('A' <= len && len <= 'Z') len = len - 'A' + 1;\n\t\telse len = len - 'a' + 26 + 1;\n\t\tdecode_85(buf, av[2]+1, len);\n\t\tprintf(\"decoded: %.*s\\n\", len, buf);\n\t\treturn 0;\n\t}\n\tif (!strcmp(av[1], \"-t\")) {\n\t\tchar t[4] = { -1,-1,-1,-1 };\n\t\tencode_85(buf, t, 4);\n\t\tprintf(\"encoded: D%s\\n\", buf);\n\t\treturn 0;\n\t}\n}",
  "static const char en85[] = {\n\t'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n\t'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\n\t'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',\n\t'U', 'V', 'W', 'X', 'Y', 'Z',\n\t'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n\t'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n\t'u', 'v', 'w', 'x', 'y', 'z',\n\t'!', '#', '$', '%', '&', '(', ')', '*', '+', '-',\n\t';', '<', '=', '>', '?', '@', '^', '_',\t'`', '{',\n\t'|', '}', '~'\n};\n\nstatic char de85[256];\nstatic void prep_base85(void)\n{\n\tint i;\n\tif (de85['Z'])\n\t\treturn;\n\tfor (i = 0; i < ARRAY_SIZE(en85); i++) {\n\t\tint ch = en85[i];\n\t\tde85[ch] = i + 1;\n\t}\n}\n\nint decode_85(char *dst, const char *buffer, int len)\n{\n\tprep_base85();\n\n\tsay2(\"decode 85 <%.*s>\", len/4*5, buffer);\n\twhile (len) {\n\t\tunsigned acc = 0;\n\t\tint de, cnt = 4;\n\t\tunsigned char ch;\n\t\tdo {\n\t\t\tch = *buffer++;\n\t\t\tde = de85[ch];\n\t\t\tif (--de < 0)\n\t\t\t\treturn error(\"invalid base85 alphabet %c\", ch);\n\t\t\tacc = acc * 85 + de;\n\t\t} while (--cnt);\n\t\tch = *buffer++;\n\t\tde = de85[ch];\n\t\tif (--de < 0)\n\t\t\treturn error(\"invalid base85 alphabet %c\", ch);\n\t\t/*\n\t\t * Detect overflow.  The largest\n\t\t * 5-letter possible is \"|NsC0\" to\n\t\t * encode 0xffffffff, and \"|NsC\" gives\n\t\t * 0x03030303 at this point (i.e.\n\t\t * 0xffffffff = 0x03030303 * 85).\n\t\t */\n\t\tif (0x03030303 < acc ||\n\t\t    0xffffffff - de < (acc *= 85))\n\t\t\terror(\"invalid base85 sequence %.5s\", buffer-5);\n\t\tacc += de;\n\t\tsay1(\" %08x\", acc);\n\n\t\tcnt = (len < 4) ? len : 4;\n\t\tlen -= cnt;\n\t\tdo {\n\t\t\tacc = (acc << 8) | (acc >> 24);\n\t\t\t*dst++ = acc;\n\t\t} while (--cnt);\n\t}\n\tsay(\"\\n\");\n\n\treturn 0;\n}\n\nvoid encode_85(char *buf, const unsigned char *data, int bytes)\n{\n\tprep_base85();\n\n\tsay(\"encode 85\");\n\twhile (bytes) {\n\t\tunsigned acc = 0;\n\t\tint cnt;\n\t\tfor (cnt = 24; cnt >= 0; cnt -= 8) {\n\t\t\tint ch = *data++;\n\t\t\tacc |= ch << cnt;\n\t\t\tif (--bytes == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tsay1(\" %08x\", acc);\n\t\tfor (cnt = 4; cnt >= 0; cnt--) {\n\t\t\tint val = acc % 85;\n\t\t\tacc /= 85;\n\t\t\tbuf[cnt] = en85[val];\n\t\t}\n\t\tbuf += 5;\n\t}\n\tsay(\"\\n\");\n\n\t*buf = 0;\n}\n\nint main(int ac, char **av)\n{\n\tchar buf[1024];\n\n\tif (!strcmp(av[1], \"-e\")) {\n\t\tint len = strlen(av[2]);\n\t\tencode_85(buf, av[2], len);\n\t\tif (len <= 26) len = len + 'A' - 1;\n\t\telse len = len + 'a' - 26 + 1;\n\t\tprintf(\"encoded: %c%s\\n\", len, buf);\n\t\treturn 0;\n\t}\n\tif (!strcmp(av[1], \"-d\")) {\n\t\tint len = *av[2];\n\t\tif ('A' <= len && len <= 'Z') len = len - 'A' + 1;\n\t\telse len = len - 'a' + 26 + 1;\n\t\tdecode_85(buf, av[2]+1, len);\n\t\tprintf(\"decoded: %.*s\\n\", len, buf);\n\t\treturn 0;\n\t}\n\tif (!strcmp(av[1], \"-t\")) {\n\t\tchar t[4] = { -1,-1,-1,-1 };\n\t\tencode_85(buf, t, 4);\n\t\tprintf(\"encoded: D%s\\n\", buf);\n\t\treturn 0;\n\t}\n}",
  "\nstatic const char en85[] = {\n\t'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n\t'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\n\t'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',\n\t'U', 'V', 'W', 'X', 'Y', 'Z',\n\t'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n\t'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n\t'u', 'v', 'w', 'x', 'y', 'z',\n\t'!', '#', '$', '%', '&', '(', ')', '*', '+', '-',\n\t';', '<', '=', '>', '?', '@', '^', '_',\t'`', '{',\n\t'|', '}', '~'\n};\n\nstatic char de85[256];\nstatic void prep_base85(void)\n{\n\tint i;\n\tif (de85['Z'])\n\t\treturn;\n\tfor (i = 0; i < ARRAY_SIZE(en85); i++) {\n\t\tint ch = en85[i];\n\t\tde85[ch] = i + 1;\n\t}\n}\n\nint decode_85(char *dst, char *buffer, int len)\n{\n\tprep_base85();\n\n\tsay2(\"decode 85 <%.*s>\", len/4*5, buffer);\n\twhile (len) {\n\t\tunsigned acc = 0;\n\t\tint de, cnt = 4;\n\t\tunsigned char ch;\n\t\tdo {\n\t\t\tch = *buffer++;\n\t\t\tde = de85[ch];\n\t\t\tif (--de < 0)\n\t\t\t\treturn error(\"invalid base85 alphabet %c\", ch);\n\t\t\tacc = acc * 85 + de;\n\t\t} while (--cnt);\n\t\tch = *buffer++;\n\t\tde = de85[ch];\n\t\tif (--de < 0)\n\t\t\treturn error(\"invalid base85 alphabet %c\", ch);\n\t\t/*\n\t\t * Detect overflow.  The largest\n\t\t * 5-letter possible is \"|NsC0\" to\n\t\t * encode 0xffffffff, and \"|NsC\" gives\n\t\t * 0x03030303 at this point (i.e.\n\t\t * 0xffffffff = 0x03030303 * 85).\n\t\t */\n\t\tif (0x03030303 < acc ||\n\t\t    0xffffffff - de < (acc *= 85))\n\t\t\terror(\"invalid base85 sequence %.5s\", buffer-5);\n\t\tacc += de;\n\t\tsay1(\" %08x\", acc);\n\n\t\tcnt = (len < 4) ? len : 4;\n\t\tlen -= cnt;\n\t\tdo {\n\t\t\tacc = (acc << 8) | (acc >> 24);\n\t\t\t*dst++ = acc;\n\t\t} while (--cnt);\n\t}\n\tsay(\"\\n\");\n\n\treturn 0;\n}\n\nvoid encode_85(char *buf, unsigned char *data, int bytes)\n{\n\tprep_base85();\n\n\tsay(\"encode 85\");\n\twhile (bytes) {\n\t\tunsigned acc = 0;\n\t\tint cnt;\n\t\tfor (cnt = 24; cnt >= 0; cnt -= 8) {\n\t\t\tint ch = *data++;\n\t\t\tacc |= ch << cnt;\n\t\t\tif (--bytes == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tsay1(\" %08x\", acc);\n\t\tfor (cnt = 4; cnt >= 0; cnt--) {\n\t\t\tint val = acc % 85;\n\t\t\tacc /= 85;\n\t\t\tbuf[cnt] = en85[val];\n\t\t}\n\t\tbuf += 5;\n\t}\n\tsay(\"\\n\");\n\n\t*buf = 0;\n}\n\nint main(int ac, char **av)\n{\n\tchar buf[1024];\n\n\tif (!strcmp(av[1], \"-e\")) {\n\t\tint len = strlen(av[2]);\n\t\tencode_85(buf, av[2], len);\n\t\tif (len <= 26) len = len + 'A' - 1;\n\t\telse len = len + 'a' - 26 + 1;\n\t\tprintf(\"encoded: %c%s\\n\", len, buf);\n\t\treturn 0;\n\t}\n\tif (!strcmp(av[1], \"-d\")) {\n\t\tint len = *av[2];\n\t\tif ('A' <= len && len <= 'Z') len = len - 'A' + 1;\n\t\telse len = len - 'a' + 26 + 1;\n\t\tdecode_85(buf, av[2]+1, len);\n\t\tprintf(\"decoded: %.*s\\n\", len, buf);\n\t\treturn 0;\n\t}\n\tif (!strcmp(av[1], \"-t\")) {\n\t\tchar t[4] = { -1,-1,-1,-1 };\n\t\tencode_85(buf, t, 4);\n\t\tprintf(\"encoded: D%s\\n\", buf);\n\t\treturn 0;\n\t}\n}",
  "/* return length of 's' in letters, ANSI escapes stripped */\nstatic int item_length(const char *s)\n{\n\tint len, i = 0;\n\tstruct strbuf str = STRBUF_INIT;\n\n\tstrbuf_addstr(&str, s);\n\twhile ((s = strstr(str.buf + i, \"\\033[\")) != NULL) {\n\t\tint len = strspn(s + 2, \"0123456789;\");\n\t\ti = s - str.buf;\n\t\tstrbuf_remove(&str, i, len + 3); /* \\033[<len><func char> */\n\t}\n\tlen = utf8_strwidth(str.buf);\n\tstrbuf_release(&str);\n\treturn len;\n}\n\n/*\n * Calculate cell width, rows and cols for a table of equal cells, given\n * table width and how many spaces between cells.\n */\nstatic void layout(struct column_data *data, int *width)\n{\n\tint i;\n\n\t*width = 0;\n\tfor (i = 0; i < data->list->nr; i++)\n\t\tif (*width < data->len[i])\n\t\t\t*width = data->len[i];\n\n\t*width += data->opts.padding;\n\n\tdata->cols = (data->opts.width - strlen(data->opts.indent)) / *width;\n\tif (data->cols == 0)\n\t\tdata->cols = 1;\n\n\tdata->rows = DIV_ROUND_UP(data->list->nr, data->cols);\n}\n\nstatic void compute_column_width(struct column_data *data)\n{\n\tint i, x, y;\n\tfor (x = 0; x < data->cols; x++) {\n\t\tdata->width[x] = XY2LINEAR(data, x, 0);\n\t\tfor (y = 0; y < data->rows; y++) {\n\t\t\ti = XY2LINEAR(data, x, y);\n\t\t\tif (i < data->list->nr &&\n\t\t\t    data->len[data->width[x]] < data->len[i])\n\t\t\t\tdata->width[x] = i;\n\t\t}\n\t}\n}\n\n/*\n * Shrink all columns by shortening them one row each time (and adding\n * more columns along the way). Hopefully the longest cell will be\n * moved to the next column, column is shrunk so we have more space\n * for new columns. The process ends when the whole thing no longer\n * fits in data->total_width.\n */\nstatic void shrink_columns(struct column_data *data)\n{\n\tREALLOC_ARRAY(data->width, data->cols);\n\twhile (data->rows > 1) {\n\t\tint x, total_width, cols, rows;\n\t\trows = data->rows;\n\t\tcols = data->cols;\n\n\t\tdata->rows--;\n\t\tdata->cols = DIV_ROUND_UP(data->list->nr, data->rows);\n\t\tif (data->cols != cols)\n\t\t\tREALLOC_ARRAY(data->width, data->cols);\n\t\tcompute_column_width(data);\n\n\t\ttotal_width = strlen(data->opts.indent);\n\t\tfor (x = 0; x < data->cols; x++) {\n\t\t\ttotal_width += data->len[data->width[x]];\n\t\t\ttotal_width += data->opts.padding;\n\t\t}\n\t\tif (total_width > data->opts.width) {\n\t\t\tdata->rows = rows;\n\t\t\tdata->cols = cols;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcompute_column_width(data);\n}\n\n/* Display without layout when not enabled */\nstatic void display_plain(const struct string_list *list,\n\t\t\t  const char *indent, const char *nl)\n{\n\tint i;\n\n\tfor (i = 0; i < list->nr; i++)\n\t\tprintf(\"%s%s%s\", indent, list->items[i].string, nl);\n}\n\n/* Print a cell to stdout with all necessary leading/traling space */\nstatic int display_cell(struct column_data *data, int initial_width,\n\t\t\tconst char *empty_cell, int x, int y)\n{\n\tint i, len, newline;\n\n\ti = XY2LINEAR(data, x, y);\n\tif (i >= data->list->nr)\n\t\treturn -1;\n\n\tlen = data->len[i];\n\tif (data->width && data->len[data->width[x]] < initial_width) {\n\t\t/*\n\t\t * empty_cell has initial_width chars, if real column\n\t\t * is narrower, increase len a bit so we fill less\n\t\t * space.\n\t\t */\n\t\tlen += initial_width - data->len[data->width[x]];\n\t\tlen -= data->opts.padding;\n\t}\n\n\tif (COL_LAYOUT(data->colopts) == COL_COLUMN)\n\t\tnewline = i + data->rows >= data->list->nr;\n\telse\n\t\tnewline = x == data->cols - 1 || i == data->list->nr - 1;\n\n\tprintf(\"%s%s%s\",\n\t       x == 0 ? data->opts.indent : \"\",\n\t       data->list->items[i].string,\n\t       newline ? data->opts.nl : empty_cell + len);\n\treturn 0;\n}\n\n/* Display COL_COLUMN or COL_ROW */\nstatic void display_table(const struct string_list *list,\n\t\t\t  unsigned int colopts,\n\t\t\t  const struct column_options *opts)\n{\n\tstruct column_data data;\n\tint x, y, i, initial_width;\n\tchar *empty_cell;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.list = list;\n\tdata.colopts = colopts;\n\tdata.opts = *opts;\n\n\tALLOC_ARRAY(data.len, list->nr);\n\tfor (i = 0; i < list->nr; i++)\n\t\tdata.len[i] = item_length(list->items[i].string);\n\n\tlayout(&data, &initial_width);\n\n\tif (colopts & COL_DENSE)\n\t\tshrink_columns(&data);\n\n\tempty_cell = xmallocz(initial_width);\n\tmemset(empty_cell, ' ', initial_width);\n\tfor (y = 0; y < data.rows; y++) {\n\t\tfor (x = 0; x < data.cols; x++)\n\t\t\tif (display_cell(&data, initial_width, empty_cell, x, y))\n\t\t\t\tbreak;\n\t}\n\n\tfree(data.len);\n\tfree(data.width);\n\tfree(empty_cell);\n}\n",
  "/* return length of 's' in letters, ANSI escapes stripped */\nstatic int item_length(unsigned int colopts, const char *s)\n{\n\tint len, i = 0;\n\tstruct strbuf str = STRBUF_INIT;\n\n\tstrbuf_addstr(&str, s);\n\twhile ((s = strstr(str.buf + i, \"\\033[\")) != NULL) {\n\t\tint len = strspn(s + 2, \"0123456789;\");\n\t\ti = s - str.buf;\n\t\tstrbuf_remove(&str, i, len + 3); /* \\033[<len><func char> */\n\t}\n\tlen = utf8_strwidth(str.buf);\n\tstrbuf_release(&str);\n\treturn len;\n}\n\n/*\n * Calculate cell width, rows and cols for a table of equal cells, given\n * table width and how many spaces between cells.\n */\nstatic void layout(struct column_data *data, int *width)\n{\n\tint i;\n\n\t*width = 0;\n\tfor (i = 0; i < data->list->nr; i++)\n\t\tif (*width < data->len[i])\n\t\t\t*width = data->len[i];\n\n\t*width += data->opts.padding;\n\n\tdata->cols = (data->opts.width - strlen(data->opts.indent)) / *width;\n\tif (data->cols == 0)\n\t\tdata->cols = 1;\n\n\tdata->rows = DIV_ROUND_UP(data->list->nr, data->cols);\n}\n\nstatic void compute_column_width(struct column_data *data)\n{\n\tint i, x, y;\n\tfor (x = 0; x < data->cols; x++) {\n\t\tdata->width[x] = XY2LINEAR(data, x, 0);\n\t\tfor (y = 0; y < data->rows; y++) {\n\t\t\ti = XY2LINEAR(data, x, y);\n\t\t\tif (i < data->list->nr &&\n\t\t\t    data->len[data->width[x]] < data->len[i])\n\t\t\t\tdata->width[x] = i;\n\t\t}\n\t}\n}\n\n/*\n * Shrink all columns by shortening them one row each time (and adding\n * more columns along the way). Hopefully the longest cell will be\n * moved to the next column, column is shrunk so we have more space\n * for new columns. The process ends when the whole thing no longer\n * fits in data->total_width.\n */\nstatic void shrink_columns(struct column_data *data)\n{\n\tREALLOC_ARRAY(data->width, data->cols);\n\twhile (data->rows > 1) {\n\t\tint x, total_width, cols, rows;\n\t\trows = data->rows;\n\t\tcols = data->cols;\n\n\t\tdata->rows--;\n\t\tdata->cols = DIV_ROUND_UP(data->list->nr, data->rows);\n\t\tif (data->cols != cols)\n\t\t\tREALLOC_ARRAY(data->width, data->cols);\n\t\tcompute_column_width(data);\n\n\t\ttotal_width = strlen(data->opts.indent);\n\t\tfor (x = 0; x < data->cols; x++) {\n\t\t\ttotal_width += data->len[data->width[x]];\n\t\t\ttotal_width += data->opts.padding;\n\t\t}\n\t\tif (total_width > data->opts.width) {\n\t\t\tdata->rows = rows;\n\t\t\tdata->cols = cols;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcompute_column_width(data);\n}\n\n/* Display without layout when not enabled */\nstatic void display_plain(const struct string_list *list,\n\t\t\t  const char *indent, const char *nl)\n{\n\tint i;\n\n\tfor (i = 0; i < list->nr; i++)\n\t\tprintf(\"%s%s%s\", indent, list->items[i].string, nl);\n}\n\n/* Print a cell to stdout with all necessary leading/traling space */\nstatic int display_cell(struct column_data *data, int initial_width,\n\t\t\tconst char *empty_cell, int x, int y)\n{\n\tint i, len, newline;\n\n\ti = XY2LINEAR(data, x, y);\n\tif (i >= data->list->nr)\n\t\treturn -1;\n\n\tlen = data->len[i];\n\tif (data->width && data->len[data->width[x]] < initial_width) {\n\t\t/*\n\t\t * empty_cell has initial_width chars, if real column\n\t\t * is narrower, increase len a bit so we fill less\n\t\t * space.\n\t\t */\n\t\tlen += initial_width - data->len[data->width[x]];\n\t\tlen -= data->opts.padding;\n\t}\n\n\tif (COL_LAYOUT(data->colopts) == COL_COLUMN)\n\t\tnewline = i + data->rows >= data->list->nr;\n\telse\n\t\tnewline = x == data->cols - 1 || i == data->list->nr - 1;\n\n\tprintf(\"%s%s%s\",\n\t       x == 0 ? data->opts.indent : \"\",\n\t       data->list->items[i].string,\n\t       newline ? data->opts.nl : empty_cell + len);\n\treturn 0;\n}\n\n/* Display COL_COLUMN or COL_ROW */\nstatic void display_table(const struct string_list *list,\n\t\t\t  unsigned int colopts,\n\t\t\t  const struct column_options *opts)\n{\n\tstruct column_data data;\n\tint x, y, i, initial_width;\n\tchar *empty_cell;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.list = list;\n\tdata.colopts = colopts;\n\tdata.opts = *opts;\n\n\tALLOC_ARRAY(data.len, list->nr);\n\tfor (i = 0; i < list->nr; i++)\n\t\tdata.len[i] = item_length(colopts, list->items[i].string);\n\n\tlayout(&data, &initial_width);\n\n\tif (colopts & COL_DENSE)\n\t\tshrink_columns(&data);\n\n\tempty_cell = xmallocz(initial_width);\n\tmemset(empty_cell, ' ', initial_width);\n\tfor (y = 0; y < data.rows; y++) {\n\t\tfor (x = 0; x < data.cols; x++)\n\t\t\tif (display_cell(&data, initial_width, empty_cell, x, y))\n\t\t\t\tbreak;\n\t}\n\n\tfree(data.len);\n\tfree(data.width);\n\tfree(empty_cell);\n}\n",
  "/* return length of 's' in letters, ANSI escapes stripped */\nstatic int item_length(unsigned int colopts, const char *s)\n{\n\tint len, i = 0;\n\tstruct strbuf str = STRBUF_INIT;\n\n\tstrbuf_addstr(&str, s);\n\twhile ((s = strstr(str.buf + i, \"\\033[\")) != NULL) {\n\t\tint len = strspn(s + 2, \"0123456789;\");\n\t\ti = s - str.buf;\n\t\tstrbuf_remove(&str, i, len + 3); /* \\033[<len><func char> */\n\t}\n\tlen = utf8_strwidth(str.buf);\n\tstrbuf_release(&str);\n\treturn len;\n}\n\n/*\n * Calculate cell width, rows and cols for a table of equal cells, given\n * table width and how many spaces between cells.\n */\nstatic void layout(struct column_data *data, int *width)\n{\n\tint i;\n\n\t*width = 0;\n\tfor (i = 0; i < data->list->nr; i++)\n\t\tif (*width < data->len[i])\n\t\t\t*width = data->len[i];\n\n\t*width += data->opts.padding;\n\n\tdata->cols = (data->opts.width - strlen(data->opts.indent)) / *width;\n\tif (data->cols == 0)\n\t\tdata->cols = 1;\n\n\tdata->rows = DIV_ROUND_UP(data->list->nr, data->cols);\n}\n\nstatic void compute_column_width(struct column_data *data)\n{\n\tint i, x, y;\n\tfor (x = 0; x < data->cols; x++) {\n\t\tdata->width[x] = XY2LINEAR(data, x, 0);\n\t\tfor (y = 0; y < data->rows; y++) {\n\t\t\ti = XY2LINEAR(data, x, y);\n\t\t\tif (i < data->list->nr &&\n\t\t\t    data->len[data->width[x]] < data->len[i])\n\t\t\t\tdata->width[x] = i;\n\t\t}\n\t}\n}\n\n/*\n * Shrink all columns by shortening them one row each time (and adding\n * more columns along the way). Hopefully the longest cell will be\n * moved to the next column, column is shrunk so we have more space\n * for new columns. The process ends when the whole thing no longer\n * fits in data->total_width.\n */\nstatic void shrink_columns(struct column_data *data)\n{\n\tdata->width = xrealloc(data->width,\n\t\t\t       sizeof(*data->width) * data->cols);\n\twhile (data->rows > 1) {\n\t\tint x, total_width, cols, rows;\n\t\trows = data->rows;\n\t\tcols = data->cols;\n\n\t\tdata->rows--;\n\t\tdata->cols = DIV_ROUND_UP(data->list->nr, data->rows);\n\t\tif (data->cols != cols)\n\t\t\tdata->width = xrealloc(data->width,\n\t\t\t\t\t       sizeof(*data->width) * data->cols);\n\t\tcompute_column_width(data);\n\n\t\ttotal_width = strlen(data->opts.indent);\n\t\tfor (x = 0; x < data->cols; x++) {\n\t\t\ttotal_width += data->len[data->width[x]];\n\t\t\ttotal_width += data->opts.padding;\n\t\t}\n\t\tif (total_width > data->opts.width) {\n\t\t\tdata->rows = rows;\n\t\t\tdata->cols = cols;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcompute_column_width(data);\n}\n\n/* Display without layout when not enabled */\nstatic void display_plain(const struct string_list *list,\n\t\t\t  const char *indent, const char *nl)\n{\n\tint i;\n\n\tfor (i = 0; i < list->nr; i++)\n\t\tprintf(\"%s%s%s\", indent, list->items[i].string, nl);\n}\n\n/* Print a cell to stdout with all necessary leading/traling space */\nstatic int display_cell(struct column_data *data, int initial_width,\n\t\t\tconst char *empty_cell, int x, int y)\n{\n\tint i, len, newline;\n\n\ti = XY2LINEAR(data, x, y);\n\tif (i >= data->list->nr)\n\t\treturn -1;\n\n\tlen = data->len[i];\n\tif (data->width && data->len[data->width[x]] < initial_width) {\n\t\t/*\n\t\t * empty_cell has initial_width chars, if real column\n\t\t * is narrower, increase len a bit so we fill less\n\t\t * space.\n\t\t */\n\t\tlen += initial_width - data->len[data->width[x]];\n\t\tlen -= data->opts.padding;\n\t}\n\n\tif (COL_LAYOUT(data->colopts) == COL_COLUMN)\n\t\tnewline = i + data->rows >= data->list->nr;\n\telse\n\t\tnewline = x == data->cols - 1 || i == data->list->nr - 1;\n\n\tprintf(\"%s%s%s\",\n\t       x == 0 ? data->opts.indent : \"\",\n\t       data->list->items[i].string,\n\t       newline ? data->opts.nl : empty_cell + len);\n\treturn 0;\n}\n\n/* Display COL_COLUMN or COL_ROW */\nstatic void display_table(const struct string_list *list,\n\t\t\t  unsigned int colopts,\n\t\t\t  const struct column_options *opts)\n{\n\tstruct column_data data;\n\tint x, y, i, initial_width;\n\tchar *empty_cell;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.list = list;\n\tdata.colopts = colopts;\n\tdata.opts = *opts;\n\n\tdata.len = xmalloc(sizeof(*data.len) * list->nr);\n\tfor (i = 0; i < list->nr; i++)\n\t\tdata.len[i] = item_length(colopts, list->items[i].string);\n\n\tlayout(&data, &initial_width);\n\n\tif (colopts & COL_DENSE)\n\t\tshrink_columns(&data);\n\n\tempty_cell = xmalloc(initial_width + 1);\n\tmemset(empty_cell, ' ', initial_width);\n\tempty_cell[initial_width] = '\\0';\n\tfor (y = 0; y < data.rows; y++) {\n\t\tfor (x = 0; x < data.cols; x++)\n\t\t\tif (display_cell(&data, initial_width, empty_cell, x, y))\n\t\t\t\tbreak;\n\t}\n\n\tfree(data.len);\n\tfree(data.width);\n\tfree(empty_cell);\n}\n",
  "/* return length of 's' in letters, ANSI escapes stripped */\nstatic int item_length(unsigned int colopts, const char *s)\n{\n\tint len, i = 0;\n\tstruct strbuf str = STRBUF_INIT;\n\n\tstrbuf_addstr(&str, s);\n\twhile ((s = strstr(str.buf + i, \"\\033[\")) != NULL) {\n\t\tint len = strspn(s + 2, \"0123456789;\");\n\t\ti = s - str.buf;\n\t\tstrbuf_remove(&str, i, len + 3); /* \\033[<len><func char> */\n\t}\n\tlen = utf8_strwidth(str.buf);\n\tstrbuf_release(&str);\n\treturn len;\n}\n\n/*\n * Calculate cell width, rows and cols for a table of equal cells, given\n * table width and how many spaces between cells.\n */\nstatic void layout(struct column_data *data, int *width)\n{\n\tint i;\n\n\t*width = 0;\n\tfor (i = 0; i < data->list->nr; i++)\n\t\tif (*width < data->len[i])\n\t\t\t*width = data->len[i];\n\n\t*width += data->opts.padding;\n\n\tdata->cols = (data->opts.width - strlen(data->opts.indent)) / *width;\n\tif (data->cols == 0)\n\t\tdata->cols = 1;\n\n\tdata->rows = DIV_ROUND_UP(data->list->nr, data->cols);\n}\n\n/* Display without layout when not enabled */\nstatic void display_plain(const struct string_list *list,\n\t\t\t  const char *indent, const char *nl)\n{\n\tint i;\n\n\tfor (i = 0; i < list->nr; i++)\n\t\tprintf(\"%s%s%s\", indent, list->items[i].string, nl);\n}\n\n/* Print a cell to stdout with all necessary leading/traling space */\nstatic int display_cell(struct column_data *data, int initial_width,\n\t\t\tconst char *empty_cell, int x, int y)\n{\n\tint i, len, newline;\n\n\ti = XY2LINEAR(data, x, y);\n\tif (i >= data->list->nr)\n\t\treturn -1;\n\tlen = data->len[i];\n\tif (COL_LAYOUT(data->colopts) == COL_COLUMN)\n\t\tnewline = i + data->rows >= data->list->nr;\n\telse\n\t\tnewline = x == data->cols - 1 || i == data->list->nr - 1;\n\n\tprintf(\"%s%s%s\",\n\t       x == 0 ? data->opts.indent : \"\",\n\t       data->list->items[i].string,\n\t       newline ? data->opts.nl : empty_cell + len);\n\treturn 0;\n}\n\n/* Display COL_COLUMN or COL_ROW */\nstatic void display_table(const struct string_list *list,\n\t\t\t  unsigned int colopts,\n\t\t\t  const struct column_options *opts)\n{\n\tstruct column_data data;\n\tint x, y, i, initial_width;\n\tchar *empty_cell;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.list = list;\n\tdata.colopts = colopts;\n\tdata.opts = *opts;\n\n\tdata.len = xmalloc(sizeof(*data.len) * list->nr);\n\tfor (i = 0; i < list->nr; i++)\n\t\tdata.len[i] = item_length(colopts, list->items[i].string);\n\n\tlayout(&data, &initial_width);\n\n\tempty_cell = xmalloc(initial_width + 1);\n\tmemset(empty_cell, ' ', initial_width);\n\tempty_cell[initial_width] = '\\0';\n\tfor (y = 0; y < data.rows; y++) {\n\t\tfor (x = 0; x < data.cols; x++)\n\t\t\tif (display_cell(&data, initial_width, empty_cell, x, y))\n\t\t\t\tbreak;\n\t}\n\n\tfree(data.len);\n\tfree(empty_cell);\n}",
  "/* return length of 's' in letters, ANSI escapes stripped */\nstatic int item_length(unsigned int colopts, const char *s)\n{\n\tint len, i = 0;\n\tstruct strbuf str = STRBUF_INIT;\n\n\tstrbuf_addstr(&str, s);\n\twhile ((s = strstr(str.buf + i, \"\\033[\")) != NULL) {\n\t\tint len = strspn(s + 2, \"0123456789;\");\n\t\ti = s - str.buf;\n\t\tstrbuf_remove(&str, i, len + 3); /* \\033[<len><func char> */\n\t}\n\tlen = utf8_strwidth(str.buf);\n\tstrbuf_release(&str);\n\treturn len;\n}\n\n/*\n * Calculate cell width, rows and cols for a table of equal cells, given\n * table width and how many spaces between cells.\n */\nstatic void layout(struct column_data *data, int *width)\n{\n\tint i;\n\n\t*width = 0;\n\tfor (i = 0; i < data->list->nr; i++)\n\t\tif (*width < data->len[i])\n\t\t\t*width = data->len[i];\n\n\t*width += data->opts.padding;\n\n\tdata->cols = (data->opts.width - strlen(data->opts.indent)) / *width;\n\tif (data->cols == 0)\n\t\tdata->cols = 1;\n\n\tdata->rows = DIV_ROUND_UP(data->list->nr, data->cols);\n}\n\nstatic void compute_column_width(struct column_data *data)\n{\n\tint i, x, y;\n\tfor (x = 0; x < data->cols; x++) {\n\t\tdata->width[x] = XY2LINEAR(data, x, 0);\n\t\tfor (y = 0; y < data->rows; y++) {\n\t\t\ti = XY2LINEAR(data, x, y);\n\t\t\tif (i < data->list->nr &&\n\t\t\t    data->len[data->width[x]] < data->len[i])\n\t\t\t\tdata->width[x] = i;\n\t\t}\n\t}\n}\n\n/*\n * Shrink all columns by shortening them one row each time (and adding\n * more columns along the way). Hopefully the longest cell will be\n * moved to the next column, column is shrunk so we have more space\n * for new columns. The process ends when the whole thing no longer\n * fits in data->total_width.\n */\nstatic void shrink_columns(struct column_data *data)\n{\n\tREALLOC_ARRAY(data->width, data->cols);\n\twhile (data->rows > 1) {\n\t\tint x, total_width, cols, rows;\n\t\trows = data->rows;\n\t\tcols = data->cols;\n\n\t\tdata->rows--;\n\t\tdata->cols = DIV_ROUND_UP(data->list->nr, data->rows);\n\t\tif (data->cols != cols)\n\t\t\tREALLOC_ARRAY(data->width, data->cols);\n\t\tcompute_column_width(data);\n\n\t\ttotal_width = strlen(data->opts.indent);\n\t\tfor (x = 0; x < data->cols; x++) {\n\t\t\ttotal_width += data->len[data->width[x]];\n\t\t\ttotal_width += data->opts.padding;\n\t\t}\n\t\tif (total_width > data->opts.width) {\n\t\t\tdata->rows = rows;\n\t\t\tdata->cols = cols;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcompute_column_width(data);\n}\n\n/* Display without layout when not enabled */\nstatic void display_plain(const struct string_list *list,\n\t\t\t  const char *indent, const char *nl)\n{\n\tint i;\n\n\tfor (i = 0; i < list->nr; i++)\n\t\tprintf(\"%s%s%s\", indent, list->items[i].string, nl);\n}\n\n/* Print a cell to stdout with all necessary leading/traling space */\nstatic int display_cell(struct column_data *data, int initial_width,\n\t\t\tconst char *empty_cell, int x, int y)\n{\n\tint i, len, newline;\n\n\ti = XY2LINEAR(data, x, y);\n\tif (i >= data->list->nr)\n\t\treturn -1;\n\n\tlen = data->len[i];\n\tif (data->width && data->len[data->width[x]] < initial_width) {\n\t\t/*\n\t\t * empty_cell has initial_width chars, if real column\n\t\t * is narrower, increase len a bit so we fill less\n\t\t * space.\n\t\t */\n\t\tlen += initial_width - data->len[data->width[x]];\n\t\tlen -= data->opts.padding;\n\t}\n\n\tif (COL_LAYOUT(data->colopts) == COL_COLUMN)\n\t\tnewline = i + data->rows >= data->list->nr;\n\telse\n\t\tnewline = x == data->cols - 1 || i == data->list->nr - 1;\n\n\tprintf(\"%s%s%s\",\n\t       x == 0 ? data->opts.indent : \"\",\n\t       data->list->items[i].string,\n\t       newline ? data->opts.nl : empty_cell + len);\n\treturn 0;\n}\n\n/* Display COL_COLUMN or COL_ROW */\nstatic void display_table(const struct string_list *list,\n\t\t\t  unsigned int colopts,\n\t\t\t  const struct column_options *opts)\n{\n\tstruct column_data data;\n\tint x, y, i, initial_width;\n\tchar *empty_cell;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.list = list;\n\tdata.colopts = colopts;\n\tdata.opts = *opts;\n\n\tdata.len = xmalloc(sizeof(*data.len) * list->nr);\n\tfor (i = 0; i < list->nr; i++)\n\t\tdata.len[i] = item_length(colopts, list->items[i].string);\n\n\tlayout(&data, &initial_width);\n\n\tif (colopts & COL_DENSE)\n\t\tshrink_columns(&data);\n\n\tempty_cell = xmalloc(initial_width + 1);\n\tmemset(empty_cell, ' ', initial_width);\n\tempty_cell[initial_width] = '\\0';\n\tfor (y = 0; y < data.rows; y++) {\n\t\tfor (x = 0; x < data.cols; x++)\n\t\t\tif (display_cell(&data, initial_width, empty_cell, x, y))\n\t\t\t\tbreak;\n\t}\n\n\tfree(data.len);\n\tfree(data.width);\n\tfree(empty_cell);\n}\n"
]
